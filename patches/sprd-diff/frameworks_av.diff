diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index d682632..94de612 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -495,6 +495,8 @@ protected:
     status_t setupEAC3Codec(bool encoder, int32_t numChannels, int32_t sampleRate,
             AudioEncoding encoding = kAudioEncodingPcm16bit);
 
+    status_t setIMAADPCMFormat(int32_t numChannels, int32_t sampleRate, int32_t blockAlign);
+
     status_t selectAudioPortFormat(
             OMX_U32 portIndex, OMX_AUDIO_CODINGTYPE desiredFormat);
 
diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index a9c899d..0c31119 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -46,6 +46,11 @@ public:
         kIsHTTPBasedSource     = 8,
     };
 
+    virtual void getFd(int *fd, int64_t *offset) {
+        *fd = -1;
+        *offset = 0;
+    }
+
     static sp<DataSource> CreateFromURI(
             const sp<IMediaHTTPService> &httpService,
             const char *uri,
diff --git a/include/media/stagefright/FileCache.h b/include/media/stagefright/FileCache.h
new file mode 100644
index 0000000..413cde0
--- /dev/null
+++ b/include/media/stagefright/FileCache.h
@@ -0,0 +1,137 @@
+
+#ifndef FMHALSOURCE_H
+#define FMHALSOURCE_H
+
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <limits.h>
+
+#include <utils/Atomic.h>
+#include <utils/Errors.h>
+#include <utils/threads.h>
+
+#include <utils/SortedVector.h>
+#include <utils/Vector.h>
+#include <utils/KeyedVector.h>
+#include <utils/RefBase.h>
+
+
+namespace android {
+
+class RingBuffer
+{
+
+public:
+
+    struct Buffer {
+        void *mData;
+        size_t mSize;
+    };
+
+    RingBuffer(size_t size);
+    ~RingBuffer();
+
+    int32_t init();
+
+    int getBuf( Buffer * buf, uint32_t wait);
+
+    void putData(Buffer *buf,int wake);
+
+    int getData(Buffer * buf ,uint32_t wait);
+
+    void putBuf(Buffer *buf, int wake);
+
+    size_t dataCount();
+
+    void reset();
+
+    size_t dataRelease(size_t size);
+
+    int dataCopy(uint32_t offset, Buffer *buf, int wait);
+
+    void wakeUpForGetBuf();
+    void  wakeUpForDataCopy();
+    void  wakeUpForGetData();
+    void  cleanNoMoreData();
+    void  wakeUpAndSetNoMoreData();
+private:
+    bool isFull();
+    bool isEmpty();
+
+    uint8_t * buf_addr;
+    size_t rd_index;
+    size_t wr_index;
+    size_t  mSize;
+    int getbuf_wakeup;
+    int getdata_wakeup;
+    int no_more_data;
+    int datacopy_wakeup;
+    mutable     Mutex                   mLock;
+    mutable     Mutex                   mLock_rd;
+    mutable     Mutex                   mLock_wr;
+    Mutex mDataLock;
+    Condition mDataCond;
+    Mutex mBufLock;
+    Condition mBufCond;
+
+
+};
+
+
+class FileCache : public Thread
+{
+public:
+    enum type_t {
+        NOP,
+        READ,
+        SEEK,
+        STOP
+    };
+
+    enum state_t {
+        OK = 0 ,
+        SEEK_ERROR = -1
+    };
+
+    FileCache(int mFd , int64_t length, size_t cacheSize, size_t maxPerRead,size_t preCahceSize);
+     ~FileCache();
+    int32_t    init();
+    virtual status_t    readyToRun() { return NO_ERROR; }
+    virtual bool        threadLoop();
+    void  wakeUpForThreadLoop();
+    void      exit();
+
+    ssize_t readAt(off64_t offset, void *data, size_t size);
+
+private:
+    void commandProcess();
+    void seekTo(off64_t offset);
+    int mFd;
+    int64_t mOffset;
+    int64_t mLength;
+
+    size_t mCacheSize;
+    size_t mPreCacheSize;
+
+    int mCommand;
+    int mState;
+    int errorCount;
+    bool mThreadLoop_wakeup;
+
+    mutable     Mutex       mLock;
+    Condition               mWaitCond;
+
+    mutable     Mutex       mLock_thread;
+    Condition               mCond_thread;
+
+    uint32_t                mMaxPerRead;
+    int  count;
+    static int mcount;
+    class RingBuffer *      mRingBuffer;
+};
+
+}
+#endif
+
+
diff --git a/include/media/stagefright/MP3FileSource.h b/include/media/stagefright/MP3FileSource.h
new file mode 100644
index 0000000..97177fc
--- /dev/null
+++ b/include/media/stagefright/MP3FileSource.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MP3_FILE_SOURCE_H_
+
+#define MP3_FILE_SOURCE_H_
+
+#include <stdio.h>
+
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaErrors.h>
+#include <utils/threads.h>
+#include <drm/DrmManagerClient.h>
+#include <media/stagefright/FileCache.h>
+
+namespace android {
+
+class MP3FileSource : public DataSource {
+public:
+    MP3FileSource(int fd, int64_t offset, int64_t length);
+
+    virtual status_t initCheck() const;
+
+    virtual ssize_t readAt(off64_t offset, void *data, size_t size);
+
+    virtual status_t getSize(off64_t *size);
+
+
+
+protected:
+    virtual ~MP3FileSource();
+
+private:
+    int mFd;
+    int64_t mOffset;
+    int64_t mLength;
+    int32_t mFileCache_flag;
+    Mutex mLock;
+
+    sp<FileCache> mFilecache;
+
+
+    MP3FileSource(const MP3FileSource &);
+    MP3FileSource &operator=(const MP3FileSource &);
+};
+
+}  // namespace android
+
+#endif  // FILE_SOURCE_H_
+
diff --git a/include/media/stagefright/MPEG4Writer.h b/include/media/stagefright/MPEG4Writer.h
index 5932610..f567797 100644
--- a/include/media/stagefright/MPEG4Writer.h
+++ b/include/media/stagefright/MPEG4Writer.h
@@ -118,6 +118,8 @@ private:
     status_t startTracks(MetaData *params);
     size_t numTracks();
     int64_t estimateMoovBoxSize(int32_t bitRate);
+    size_t getNumTracksWithData();
+    void incNumTracksWithData();
 
     struct Chunk {
         Track               *mTrack;        // Owner
diff --git a/include/media/stagefright/MediaCodec.h b/include/media/stagefright/MediaCodec.h
index 05f6581..5dc5cda 100644
--- a/include/media/stagefright/MediaCodec.h
+++ b/include/media/stagefright/MediaCodec.h
@@ -46,6 +46,7 @@ class Surface;
 struct MediaCodec : public AHandler {
     enum ConfigureFlags {
         CONFIGURE_FLAG_ENCODE   = 1,
+        CONFIGURE_FLAG_THUMBNAIL   = 2,
     };
 
     enum BufferFlags {
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index d85d15b..e389992 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -52,22 +52,31 @@ extern const char *MEDIA_MIMETYPE_VIDEO_H263;
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG2;
 extern const char *MEDIA_MIMETYPE_VIDEO_RAW;
 extern const char *MEDIA_MIMETYPE_VIDEO_DOLBY_VISION;
+extern const char *MEDIA_MIMETYPE_VIDEO_MJPG;
 
+extern const char *MEDIA_MIMETYPE_AUDIO_AMR;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_NB;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_WB;
 extern const char *MEDIA_MIMETYPE_AUDIO_MPEG;           // layer III
+extern const char *MEDIA_MIMETYPE_AUDIO_MP3;
+extern const char *MEDIA_MIMETYPE_AUDIO_MPG3;
+extern const char *MEDIA_MIMETYPE_AUDIO_BP3;
 extern const char *MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_I;
 extern const char *MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II;
 extern const char *MEDIA_MIMETYPE_AUDIO_MIDI;
+extern const char *MEDIA_MIMETYPE_AUDIO_MIDI1;
 extern const char *MEDIA_MIMETYPE_AUDIO_AAC;
+extern const char *MEDIA_MIMETYPE_AUDIO_AAC3;
 extern const char *MEDIA_MIMETYPE_AUDIO_QCELP;
 extern const char *MEDIA_MIMETYPE_AUDIO_VORBIS;
 extern const char *MEDIA_MIMETYPE_AUDIO_OPUS;
 extern const char *MEDIA_MIMETYPE_AUDIO_G711_ALAW;
 extern const char *MEDIA_MIMETYPE_AUDIO_G711_MLAW;
 extern const char *MEDIA_MIMETYPE_AUDIO_RAW;
+extern const char *MEDIA_MIMETYPE_AUDIO_IMAADPCM;
 extern const char *MEDIA_MIMETYPE_AUDIO_FLAC;
 extern const char *MEDIA_MIMETYPE_AUDIO_AAC_ADTS;
+extern const char *MEDIA_MIMETYPE_AUDIO_AAC2;
 extern const char *MEDIA_MIMETYPE_AUDIO_MSGSM;
 extern const char *MEDIA_MIMETYPE_AUDIO_AC3;
 extern const char *MEDIA_MIMETYPE_AUDIO_EAC3;
@@ -77,10 +86,13 @@ extern const char *MEDIA_MIMETYPE_AUDIO_EAC3_JOC;
 
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG4;
 extern const char *MEDIA_MIMETYPE_CONTAINER_WAV;
+extern const char *MEDIA_MIMETYPE_CONTAINER_WAV2;
 extern const char *MEDIA_MIMETYPE_CONTAINER_OGG;
+extern const char *MEDIA_MIMETYPE_CONTAINER_OGG2;
 extern const char *MEDIA_MIMETYPE_CONTAINER_MATROSKA;
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2TS;
 extern const char *MEDIA_MIMETYPE_CONTAINER_AVI;
+extern const char *MEDIA_MIMETYPE_CONTAINER_MSVIDEO;
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2PS;
 
 extern const char *MEDIA_MIMETYPE_CONTAINER_WVM;
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 92e2847..fe05e1e 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -577,6 +577,10 @@ ACodec::ACodec()
 }
 
 ACodec::~ACodec() {
+    while( !allYourBuffersAreBelongToUs(kPortIndexOutput)){
+        usleep(2000);
+        ALOGE("peter:~ACodec wait all buffer belong to us");
+    }
 }
 
 status_t ACodec::setupCustomCodec(status_t err, const char *mime, const sp<AMessage> &msg) {
@@ -1614,6 +1618,12 @@ ACodec::BufferInfo *ACodec::dequeueBufferFromNativeWindow() {
 
 status_t ACodec::freeBuffersOnPort(OMX_U32 portIndex) {
     status_t err = OK;
+    if(portIndex == kPortIndexOutput){
+        while(!allYourBuffersAreBelongToUs(kPortIndexOutput)){
+            usleep(2000);
+            ALOGE("peter:freeBuffersOnPort wait all buffer belong to us");
+        }
+    }
     for (size_t i = mBuffers[portIndex].size(); i > 0;) {
         i--;
         status_t err2 = freeBuffer(portIndex, i);
@@ -1780,8 +1790,12 @@ const char *ACodec::getComponentRole(
             "video_decoder.mpeg2", "video_encoder.mpeg2" },
         { MEDIA_MIMETYPE_AUDIO_AC3,
             "audio_decoder.ac3", "audio_encoder.ac3" },
+        { MEDIA_MIMETYPE_AUDIO_IMAADPCM,
+            "audio_decoder.imaadpcm", "audio_encoder.imaadpcm" },
         { MEDIA_MIMETYPE_AUDIO_EAC3,
             "audio_decoder.eac3", "audio_encoder.eac3" },
+        { MEDIA_MIMETYPE_VIDEO_MJPG,
+            "video_decoder.mjpg", "video_encoder.mjpg" },
 #ifdef DOLBY_ENABLE
         { MEDIA_MIMETYPE_AUDIO_EAC3_JOC,
             "audio_decoder.eac3_joc", NULL },
@@ -2366,6 +2380,17 @@ status_t ACodec::configureCodec(
         } else {
             err = setupEAC3Codec(encoder, numChannels, sampleRate, pcmEncoding);
         }
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_IMAADPCM)) {
+        int32_t numChannels;
+        int32_t sampleRate;
+        int32_t blockAlign;
+        if (!msg->findInt32("channel-count", &numChannels)
+                || !msg->findInt32("sample-rate", &sampleRate)
+                || !msg->findInt32("block-align", &blockAlign)) {
+            err = INVALID_OPERATION;
+        }else {
+            err = setIMAADPCMFormat(numChannels, sampleRate, blockAlign);
+        }
     } else {
         err = setupCustomCodec(err, mime, msg);
     }
@@ -2391,6 +2416,10 @@ status_t ACodec::configureCodec(
     int32_t maxInputSize;
     if (msg->findInt32("max-input-size", &maxInputSize)) {
         err = setMinBufferSize(kPortIndexInput, (size_t)maxInputSize);
+        //sprd added. inputPort must be identical to output for raw decoder.
+        if ((err == OK) && !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW) ) {
+            err = setMinBufferSize(kPortIndexOutput, (size_t)maxInputSize);
+        }
     } else if (!strcmp("OMX.Nvidia.aac.decoder", mComponentName.c_str())) {
         err = setMinBufferSize(kPortIndexInput, 8192);  // XXX
     }
@@ -2410,6 +2439,28 @@ status_t ACodec::configureCodec(
         err = setOperatingRate(rateFloat, video);
     }
 
+    //check thumbnail mode
+    int32_t thumbnail;
+    if (msg->findInt32("thumbnail", &thumbnail)) {
+        OMX_INDEXTYPE index;
+
+        status_t err =
+            mOMX->getExtensionIndex(
+                    mNode,
+                    "OMX.sprd.index.ThumbnailMode",
+                    &index);
+
+        if (err == OK) {
+            OMX_BOOL enable = OMX_TRUE;
+            err = mOMX->setConfig(mNode, index, &enable, sizeof(enable));
+        }
+
+        if (err != OK) {
+            ALOGI("[%s] setConfig(OMX.sprd.index.ThumbnailMode') invalid 0x%08x",
+                    mComponentName.c_str(), err);
+        }
+    }
+
     // NOTE: both mBaseOutputFormat and mOutputFormat are outputFormat to signal first frame.
     mBaseOutputFormat = outputFormat;
     // trigger a kWhatOutputFormatChanged msg on first buffer
@@ -2985,6 +3036,47 @@ status_t ACodec::setupEAC3Codec(
             sizeof(def));
 }
 
+status_t ACodec::setIMAADPCMFormat(int32_t numChannels, int32_t sampleRate, int32_t blockAlign) {
+    CHECK(!mIsEncoder);
+
+    // port definition
+    OMX_PARAM_PORTDEFINITIONTYPE def;
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexInput;
+    status_t err = mOMX->getParameter(
+            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+    if (err != OK) {
+        return err;
+    }
+
+    def.format.audio.eEncoding = OMX_AUDIO_CodingIMAADPCM;
+    err = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition,
+            &def, sizeof(def));
+    if (err != OK) {
+        return err;
+    }
+
+    // pcm param
+    OMX_AUDIO_PARAM_IMAADPCMTYPE imaadpcmParams;
+    InitOMXParams(&imaadpcmParams);
+    imaadpcmParams.nPortIndex = kPortIndexInput;
+
+    err = mOMX->getParameter(
+            mNode, OMX_IndexParamAudioImaAdpcm, &imaadpcmParams, sizeof(imaadpcmParams));
+
+    if (err != OK) {
+        return err;
+    }
+
+    imaadpcmParams.nChannels = numChannels;
+    imaadpcmParams.nBitsPerSample = 4;
+    imaadpcmParams.nSampleRate = sampleRate;
+    imaadpcmParams.nBlockAlign = blockAlign;
+
+    return mOMX->setParameter(
+            mNode, OMX_IndexParamAudioImaAdpcm, &imaadpcmParams, sizeof(imaadpcmParams));
+}
+
 static OMX_AUDIO_AMRBANDMODETYPE pickModeFromBitRate(
         bool isAMRWB, int32_t bps) {
     if (isAMRWB) {
@@ -3343,6 +3435,7 @@ static const struct VideoCodingMapEntry {
     { MEDIA_MIMETYPE_VIDEO_MPEG2, OMX_VIDEO_CodingMPEG2 },
     { MEDIA_MIMETYPE_VIDEO_VP8, OMX_VIDEO_CodingVP8 },
     { MEDIA_MIMETYPE_VIDEO_VP9, OMX_VIDEO_CodingVP9 },
+    { MEDIA_MIMETYPE_VIDEO_MJPG, OMX_VIDEO_CodingMJPEG },
     { MEDIA_MIMETYPE_VIDEO_DOLBY_VISION, OMX_VIDEO_CodingDolbyVision },
 };
 
@@ -5214,6 +5307,24 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     // Fall through to set up mime.
                 }
 
+                case OMX_AUDIO_CodingIMAADPCM:
+                {
+                    OMX_AUDIO_PARAM_PCMMODETYPE params;
+                    InitOMXParams(&params);
+                    params.nPortIndex = portIndex;
+
+                    CHECK_EQ((status_t)OK, mOMX->getParameter(
+                            mNode,
+                            (OMX_INDEXTYPE)OMX_IndexParamAudioImaAdpcm,
+                            &params,
+                            sizeof(params)));
+
+                    notify->setString("mime", MEDIA_MIMETYPE_AUDIO_IMAADPCM);
+                    notify->setInt32("channel-count", params.nChannels);
+                    notify->setInt32("sample-rate", params.nSamplingRate);
+                    break;
+                }
+
                 default:
                 {
                     if (!mIsEncoder && !strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
@@ -7842,6 +7953,34 @@ status_t ACodec::setParameters(const sp<AMessage> &params) {
             err = OK;
         }
     }
+
+    AString mode;
+    if (params->findString("scene-mode", &mode)){
+        OMX_VIDEO_CONFIG_ENCODERSCENEMODE configParams;
+        InitOMXParams(&configParams);
+        configParams.nPortIndex = kPortIndexOutput;
+        if (mode==AString("Volte")) {
+            configParams.nMode = 1;
+        }
+        else  if (mode==AString("Wfd")) {
+            configParams.nMode = 2;
+        }
+        else {
+            configParams.nMode = 0;
+        }
+
+        status_t err = mOMX->setConfig(
+                mNode,
+                OMX_IndexConfigEncSceneMode,
+                &configParams,
+                sizeof(configParams));
+
+        if (err != OK) {
+            ALOGE("setConfig(OMX_IndexConfigEncSceneMode) failed w/ err %d",
+                    err);
+            return err;
+        }
+    }
 #ifdef DOLBY_ENABLE
     return setDolbyParameterOnProcessedAudio(params);
 #endif // DOLBY_END
@@ -8016,7 +8155,14 @@ bool ACodec::OutputPortSettingsChangedState::onOMXEvent(
                             mCodec->mBuffers[kPortIndexOutput].size());
                     err = FAILED_TRANSACTION;
                 } else {
-                    mCodec->mDealer[kPortIndexOutput].clear();
+                    while(1){
+                        if(mCodec->allYourBuffersAreBelongToUs(kPortIndexOutput)){
+                            mCodec->mDealer[kPortIndexOutput].clear();
+                            break;
+                        }
+                        ALOGE("peter: wait all out buffer belong to us");
+                        usleep(2000);
+                    }
                 }
 
                 if (err == OK) {
diff --git a/media/libstagefright/AMRExtractor.cpp b/media/libstagefright/AMRExtractor.cpp
index 2892520..43b1118 100644
--- a/media/libstagefright/AMRExtractor.cpp
+++ b/media/libstagefright/AMRExtractor.cpp
@@ -126,7 +126,8 @@ AMRExtractor::AMRExtractor(const sp<DataSource> &source)
         return;
     }
 
-    mIsWide = (mimeType == MEDIA_MIMETYPE_AUDIO_AMR_WB);
+    mIsWide = (mimeType == MEDIA_MIMETYPE_AUDIO_AMR_WB) ||
+		      (mimeType == MEDIA_MIMETYPE_AUDIO_AMR);
 
     mMeta = new MetaData;
     mMeta->setCString(
diff --git a/media/libstagefright/AVIExtractor.cpp b/media/libstagefright/AVIExtractor.cpp
index 5a6211e..a29ba20 100644
--- a/media/libstagefright/AVIExtractor.cpp
+++ b/media/libstagefright/AVIExtractor.cpp
@@ -35,6 +35,13 @@
 
 namespace android {
 
+enum {
+    WAVE_FORMAT_PCM = 1,
+    WAVE_FORMAT_ALAW = 6,
+    WAVE_FORMAT_MULAW = 7,
+    WAVE_FORMAT_IMAADPCM = 0x11
+};
+
 struct AVIExtractor::AVISource : public MediaSource {
     AVISource(const sp<AVIExtractor> &extractor, size_t trackIndex);
 
@@ -69,6 +76,7 @@ struct AVIExtractor::MP3Splitter : public RefBase {
     void clear();
     void append(MediaBuffer *buffer);
     status_t read(MediaBuffer **buffer);
+    status_t readparam(int type, int16_t &param_value);
 
 protected:
     virtual ~MP3Splitter();
@@ -77,6 +85,7 @@ private:
     bool mFindSync;
     int64_t mBaseTimeUs;
     int64_t mNumSamplesRead;
+    int16_t nChannelnum;
     sp<ABuffer> mBuffer;
 
     bool resync();
@@ -101,12 +110,21 @@ AVIExtractor::AVISource::~AVISource() {
 }
 
 status_t AVIExtractor::AVISource::start(MetaData *params) {
+    if (params) {
+        ALOGI("%s, have MetaData: %p", __FUNCTION__, params);
+    }
+
     CHECK(!mBufferGroup);
 
     mBufferGroup = new MediaBufferGroup;
 
-    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
-    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
+    if (8 == mTrack.mBitsPerSample) {
+        mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize<<1));
+        mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize<<1));
+    } else {
+        mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
+        mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxSampleSize));
+    }
     mSampleIndex = 0;
 
     const char *mime;
@@ -144,7 +162,8 @@ status_t AVIExtractor::AVISource::read(
 
     int64_t seekTimeUs;
     ReadOptions::SeekMode seekMode;
-    if (options && options->getSeekTo(&seekTimeUs, &seekMode)) {
+    if (options && options->getSeekTo(&seekTimeUs, &seekMode)
+        && mExtractor->mIndexType != NO_INDEX) {
         status_t err =
             mExtractor->getSampleIndexAtTime(
                     mTrackIndex, seekTimeUs, seekMode, &mSampleIndex);
@@ -158,14 +177,28 @@ status_t AVIExtractor::AVISource::read(
         }
     }
 
-    for (;;) {
+    for (int i=0;; i++) {
         if (mSplitter != NULL) {
             status_t err = mSplitter->read(buffer);
 
             if (err == OK) {
+                int16_t channel_data = 0;
+                int32_t channel_data_old = 0;
+                mSplitter->readparam(0 , channel_data);
+
+                mTrack.mMeta->findInt32(kKeyChannelCount, &channel_data_old);
+		if (channel_data_old != channel_data) {
+                    mTrack.mMeta->setInt32(kKeyChannelCount, channel_data);
+                }
                 break;
             } else if (err != -EAGAIN) {
                 return err;
+            } else { /* (err == -EAGAIN) */
+                 if (i > 100) {
+                    // to avoid dead loop.
+                    ALOGE("AVIExtractor, mSplitter read() failed > 100 times, stop. \n");
+                    return ERROR_END_OF_STREAM;
+                }
             }
         }
 
@@ -179,19 +212,60 @@ status_t AVIExtractor::AVISource::read(
         ++mSampleIndex;
 
         if (err != OK) {
-            return ERROR_END_OF_STREAM;
+            if (mSampleIndex < mTrack.mSamples.size()) {
+                continue;
+            } else {
+                return ERROR_END_OF_STREAM;
+            }
         }
 
         MediaBuffer *out;
         CHECK_EQ(mBufferGroup->acquire_buffer(&out), (status_t)OK);
 
+        if (size > mTrack.mMaxSampleSize) {
+            size = mTrack.mMaxSampleSize; //buffer is not enough
+        }
         ssize_t n = mExtractor->mDataSource->readAt(offset, out->data(), size);
 
         if (n < (ssize_t)size) {
+            int64_t length = 0;
+            mExtractor->mDataSource->getSize(&length);
+            if ((int64_t)(offset + size) > length) {
+                ALOGE("read error, n: %zd, size: %zd, offset: %lld, file size: %lld", n, size, (long long)offset, (long long)length);
+                out->release();
+                out = NULL;
+                return ERROR_END_OF_STREAM;
+            }
+
             return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
         }
 
-        out->set_range(0, size);
+        const char *mime;
+        CHECK(mTrack.mMeta->findCString(kKeyMIMEType, &mime));
+
+        if ( !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)  && (mTrack.mBitsPerSample == 8)) {
+            // Convert 8-bit unsigned samples to 16-bit signed.
+            MediaBuffer *tmp;
+            CHECK_EQ(mBufferGroup->acquire_buffer(&tmp), (status_t)OK);
+
+            // The new buffer holds the sample number of samples, but each
+            // one is 2 bytes wide.
+            tmp->set_range(0, 2 * n);
+
+            int16_t *dst = (int16_t *)tmp->data();
+            const uint8_t *src = (const uint8_t *)out->data();
+            ssize_t numBytes = n;
+
+            while (numBytes-- > 0) {
+                *dst++ = ((int16_t)(*src) - 128) * 256;
+                ++src;
+            }
+
+            out->release();
+            out = tmp;
+        }else {
+            out->set_range(0, size);
+        }
 
         out->meta_data()->setInt64(kKeyTime, timeUs);
 
@@ -338,10 +412,13 @@ status_t AVIExtractor::MP3Splitter::read(MediaBuffer **out) {
     size_t frameSize;
     int sampleRate;
     int numSamples;
+    int channel_mode;
     if (!GetMPEGAudioFrameSize(
-                header, &frameSize, &sampleRate, NULL, NULL, &numSamples)) {
-        return ERROR_MALFORMED;
+                header, &frameSize, &sampleRate, &channel_mode, NULL, &numSamples)) {
+        clear();
+        return -EAGAIN;
     }
+    nChannelnum = channel_mode;
 
     if (mBuffer->size() < frameSize) {
         return -EAGAIN;
@@ -363,6 +440,16 @@ status_t AVIExtractor::MP3Splitter::read(MediaBuffer **out) {
     return OK;
 }
 
+status_t AVIExtractor::MP3Splitter::readparam(int type, int16_t &param_value)
+{
+    if (type) {
+        ALOGI("%s, type: %d", __FUNCTION__, type);
+    }
+    param_value = nChannelnum;
+
+    return OK;
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 
 AVIExtractor::AVIExtractor(const sp<DataSource> &dataSource)
@@ -381,12 +468,15 @@ size_t AVIExtractor::countTracks() {
     return mTracks.size();
 }
 
-sp<MediaSource> AVIExtractor::getTrack(size_t index) {
+sp<IMediaSource> AVIExtractor::getTrack(size_t index) {
     return index < mTracks.size() ? new AVISource(this, index) : NULL;
 }
 
 sp<MetaData> AVIExtractor::getTrackMetaData(
         size_t index, uint32_t flags) {
+    if (flags) {
+        ALOGI("%s, type: %d", __FUNCTION__, flags);
+    }
     return index < mTracks.size() ? mTracks.editItemAt(index).mMeta : NULL;
 }
 
@@ -400,19 +490,85 @@ sp<MetaData> AVIExtractor::getMetaData() {
     return meta;
 }
 
+uint32_t AVIExtractor::flags() const {
+    if (mIndexType == NO_INDEX) { //don't support seek if no index in broken files
+        return CAN_PAUSE;
+    } else {
+        return MediaExtractor::flags();
+    }
+}
+
 status_t AVIExtractor::parseHeaders() {
     mTracks.clear();
     mMovieOffset = 0;
     mFoundIndex = false;
     mOffsetsAreAbsolute = false;
+    mIndexType = NO_INDEX;
+
+    //ssize_t res = parseChunk(0ll, -1ll);
+    off64_t dataSize = 0;
+    status_t err = mDataSource->getSize(&dataSize);
+    if (err == ERROR_UNSUPPORTED) {
+        dataSize = -1;
+    } else if (err != OK) {
+        return err;
+    }
 
-    ssize_t res = parseChunk(0ll, -1ll);
+    ssize_t res = parseChunk(0ll, dataSize);
 
     if (res < 0) {
         return (status_t)res;
     }
 
-    if (mMovieOffset == 0ll || !mFoundIndex) {
+    if(mIndexType == NO_INDEX)
+    {
+        ALOGV("NO index existed!");
+        mOffsetsAreAbsolute = true;
+        //init all track's first sample position to movi's first sample position.
+        for (size_t i = 0; i < mTracks.size(); ++i) {
+            Track *track = &mTracks.editItemAt(i);
+            track->mCurSamplePos = mMovieOffset + 12;
+        }
+    }
+    //cut from parseindex()
+    for (size_t i = 0; i < mTracks.size(); ++i) {
+        Track *track = &mTracks.editItemAt(i);
+        const char *tmp;
+        CHECK(track->mMeta->findCString(kKeyMIMEType, &tmp));
+
+        AString mime = tmp;
+
+        if (!strncasecmp("video/", mime.c_str(), 6)) {
+            if (track->mThumbnailSampleIndex >= 0) {
+                int64_t thumbnailTimeUs;
+
+                if ((status_t)OK !=
+                        (err = getSampleTime(i, track->mThumbnailSampleIndex,
+                                             &thumbnailTimeUs))) {
+                    ALOGE("getSampleTime failed(%d)", err);
+                    return err;
+                }
+
+                track->mMeta->setInt64(kKeyThumbnailTime, thumbnailTimeUs);
+            }
+
+            err = OK;
+
+            if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_MPEG4)) {
+                if( OK != addMPEG4CodecSpecificData(i)) {
+                    ALOGE("parseHeaders, addMPEG4CodecSpecificData failed, trackidx=%zd",i);
+                }
+            } else if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_AVC)) {
+                err = addH264CodecSpecificData(i);
+            }
+
+            if (err != OK) {
+                return err;
+            }
+        }
+    }
+
+    if (mMovieOffset == 0ll/* || !mFoundIndex*/) {
         return ERROR_MALFORMED;
     }
 
@@ -435,7 +591,8 @@ ssize_t AVIExtractor::parseChunk(off64_t offset, off64_t size, int depth) {
     uint32_t chunkSize = U32LE_AT(&tmp[4]);
 
     if (size >= 0 && chunkSize + 8 > size) {
-        return ERROR_MALFORMED;
+        //return ERROR_MALFORMED;
+        chunkSize = size - 8;
     }
 
     static const char kPrefix[] = "                              ";
@@ -459,7 +616,7 @@ ssize_t AVIExtractor::parseChunk(off64_t offset, off64_t size, int depth) {
 
         ALOGV("%s offset 0x%08llx LIST of '%c%c%c%c', size %d",
              prefix,
-             offset,
+             (unsigned long long)offset,
              (char)(subFourcc >> 24),
              (char)((subFourcc >> 16) & 0xff),
              (char)((subFourcc >> 8) & 0xff),
@@ -488,7 +645,7 @@ ssize_t AVIExtractor::parseChunk(off64_t offset, off64_t size, int depth) {
     } else {
         ALOGV("%s offset 0x%08llx CHUNK '%c%c%c%c'",
              prefix,
-             offset,
+             (unsigned long long)offset,
              (char)(fourcc >> 24),
              (char)((fourcc >> 16) & 0xff),
              (char)((fourcc >> 8) & 0xff),
@@ -511,7 +668,18 @@ ssize_t AVIExtractor::parseChunk(off64_t offset, off64_t size, int depth) {
 
             case FOURCC('i', 'd', 'x', '1'):
             {
-                err = parseIndex(offset + 8, chunkSize);
+                if(mIndexType == NO_INDEX) //IF indx found, don't care idx1
+                {
+                    err = parseIdx1(offset + 8, chunkSize);
+                    mIndexType = IDX1;
+                }
+                break;
+            }
+            case FOURCC('i', 'n', 'd', 'x'):
+            {
+                //don't check return values, since broken file may miss some std index
+                parseIndx(offset, chunkSize + 8);
+                mIndexType = INDX;
                 break;
             }
 
@@ -519,6 +687,13 @@ ssize_t AVIExtractor::parseChunk(off64_t offset, off64_t size, int depth) {
                 break;
         }
 
+        if(((tmp[0] == 'i') && tmp[1] == 'x') ||
+           ((tmp[2] == 'i') && tmp[3] == 'x'))
+        {
+            parseIndx(offset, chunkSize + 8);
+            mIndexType = INDX;
+        }
+
         if (err != OK) {
             return err;
         }
@@ -571,16 +746,33 @@ static const char *GetMIMETypeForHandler(uint32_t handler) {
         case FOURCC('X', 'v', 'i', 'D'):
         case FOURCC('x', 'v', 'i', 'd'):
         case FOURCC('X', 'V', 'I', 'X'):
+        case FOURCC('f', 'f', 'd', 's'):
+        case FOURCC('y', 'v', '1', '2'):
             return MEDIA_MIMETYPE_VIDEO_MPEG4;
 
         // from http://wiki.multimedia.cx/index.php?title=H264
         case FOURCC('a', 'v', 'c', '1'):
         case FOURCC('d', 'a', 'v', 'c'):
         case FOURCC('x', '2', '6', '4'):
+        case FOURCC('h', '2', '6', '4'):
         case FOURCC('H', '2', '6', '4'):
         case FOURCC('v', 's', 's', 'h'):
             return MEDIA_MIMETYPE_VIDEO_AVC;
 
+        case FOURCC('h', '2', '6', '3'):
+        case FOURCC('H', '2', '6', '3'):
+        case FOURCC('F', 'L', 'V', '1'):
+            return MEDIA_MIMETYPE_VIDEO_H263;
+
+        case FOURCC('m', 'j', 'p', 'g'):
+        case FOURCC('M', 'J', 'P', 'G'):
+            return MEDIA_MIMETYPE_VIDEO_MJPG;
+        // Support mime type of VP80.
+        /** SPRD: add { */
+        case FOURCC('V', 'P', '8', '0'):
+            return MEDIA_MIMETYPE_VIDEO_VP8;
+        /** SPRD: add } */
+
         default:
             return NULL;
     }
@@ -606,17 +798,19 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
 
     uint32_t type = U32_AT(data);
     uint32_t handler = U32_AT(&data[4]);
-    uint32_t flags = U32LE_AT(&data[8]);
+    //uint32_t flags = U32LE_AT(&data[8]);
 
     sp<MetaData> meta = new MetaData;
 
     uint32_t rate = U32LE_AT(&data[20]);
     uint32_t scale = U32LE_AT(&data[24]);
+    uint32_t length = U32LE_AT(&data[32]);
 
     uint32_t sampleSize = U32LE_AT(&data[44]);
 
     const char *mime = NULL;
     Track::Kind kind = Track::OTHER;
+    int32_t maxSampleSize = 0;
 
     if (type == FOURCC('v', 'i', 'd', 's')) {
         mime = GetMIMETypeForHandler(handler);
@@ -634,12 +828,14 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
         }
 
         kind = Track::VIDEO;
+        maxSampleSize = AVI_VIDEO_SAMPLE_MAX_SIZE;
     } else if (type == FOURCC('a', 'u', 'd', 's')) {
         if (mime && strncasecmp(mime, "audio/", 6)) {
             return ERROR_MALFORMED;
         }
 
         kind = Track::AUDIO;
+        maxSampleSize = AVI_AUDIO_SAMPLE_MAX_SIZE;
     }
 
     if (!mime) {
@@ -648,6 +844,15 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
 
     meta->setCString(kKeyMIMEType, mime);
 
+    //set duration and maxsamplesize first anyway, may be changed in parseIndex()
+    if (scale == 0) {
+        scale = 1;
+    } if (rate == 0) {
+        rate = 1;
+    }
+    meta->setInt64(kKeyDuration, (int64_t)(length * 1000000ll * rate / scale));
+    meta->setInt32(kKeyMaxInputSize, maxSampleSize);
+
     mTracks.push();
     Track *track = &mTracks.editItemAt(mTracks.size() - 1);
 
@@ -659,9 +864,11 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
     track->mNumSyncSamples = 0;
     track->mThumbnailSampleSize = 0;
     track->mThumbnailSampleIndex = -1;
-    track->mMaxSampleSize = 0;
+    track->mMaxSampleSize = maxSampleSize;
     track->mAvgChunkSize = 1.0;
     track->mFirstChunkSize = 0;
+    track->mCurSamplePos = 0;
+    track->mBitsPerSample = 0;
 
     return OK;
 }
@@ -695,22 +902,70 @@ status_t AVIExtractor::parseStreamFormat(off64_t offset, size_t size) {
     const uint8_t *data = buffer->data();
 
     if (isVideo) {
+        const char *mime = NULL;
         uint32_t width = U32LE_AT(&data[4]);
         uint32_t height = U32LE_AT(&data[8]);
+        uint32_t handler = U32_AT(&data[16]);
+
+        mime = GetMIMETypeForHandler(handler);
+        if ((!mime)||(mime && strncasecmp(mime, "video/", 6))) {
+            ALOGI("strh Unsupported video format '%c%c%c%c'",
+                 (char)(handler >> 24),
+                 (char)((handler >> 16) & 0xff),
+                 (char)((handler >> 8) & 0xff),
+                 (char)(handler & 0xff));
+        }else{
+            track->mMeta->setCString(kKeyMIMEType, mime);
+        }
 
         track->mMeta->setInt32(kKeyWidth, width);
         track->mMeta->setInt32(kKeyHeight, height);
     } else {
         uint32_t format = U16LE_AT(data);
-
-        if (format == 0x55) {
-            track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
-        } else {
-            ALOGW("Unsupported audio format = 0x%04x", format);
-        }
-
         uint32_t numChannels = U16LE_AT(&data[2]);
         uint32_t sampleRate = U32LE_AT(&data[4]);
+        uint32_t blockAlign = U16LE_AT(&data[12]);
+        uint32_t bitsPerSample = U16LE_AT(&data[14]);
+
+        switch(format){
+            case 0x55:
+            case 0x50:
+                track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
+                break;
+            case WAVE_FORMAT_PCM:
+                if ((16 == bitsPerSample) || (8 == bitsPerSample)){
+                    track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+                    track->mBitsPerSample = bitsPerSample;
+                } else {
+                    ALOGW("Unsupported WAVE_FORMAT_PCM but wrong bits = %d", bitsPerSample);
+                }
+                break;
+            case WAVE_FORMAT_ALAW:
+                if (8 == bitsPerSample) {
+                    track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_G711_ALAW);
+                } else {
+                    ALOGW("Unsupported WAVE_FORMAT_ALAW but wrong bits = %d", bitsPerSample);
+                }
+                break;
+            case WAVE_FORMAT_MULAW:
+                if (8 == bitsPerSample) {
+                    track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_G711_MLAW);
+                } else {
+                    ALOGW("Unsupported WAVE_FORMAT_MULAW but wrong bits = %d", bitsPerSample);
+                }
+                break;
+            case WAVE_FORMAT_IMAADPCM:
+                if  (4 == bitsPerSample) {
+                    track->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_IMAADPCM);
+                    track->mMeta->setInt32(kKeyBlockAlign, blockAlign);
+                } else {
+                    ALOGW("Unsupported WAVE_FORMAT_IMAADPCM but wrong bits = 0x%04x", bitsPerSample);
+                }
+                break;
+             default:
+                ALOGW("Unsupported audio format = 0x%04x", format);
+                break;
+        };
 
         track->mMeta->setInt32(kKeyChannelCount, numChannels);
         track->mMeta->setInt32(kKeySampleRate, sampleRate);
@@ -728,6 +983,7 @@ bool AVIExtractor::IsCorrectChunkType(
         case Track::VIDEO:
         {
             if (chunkBase != FOURCC(0, 0, 'd', 'c')
+                    && chunkBase != FOURCC(0, 0, 's', 'b')
                     && chunkBase != FOURCC(0, 0, 'd', 'b')) {
                 return false;
             }
@@ -764,28 +1020,31 @@ bool AVIExtractor::IsCorrectChunkType(
     return true;
 }
 
-status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
-    if ((size % 16) != 0) {
+status_t AVIExtractor::parseIdx1(off64_t offset, size_t size) {
+    /*if ((size % 16) != 0) {
         return ERROR_MALFORMED;
-    }
+    }*/
 
     sp<ABuffer> buffer = new ABuffer(size);
     ssize_t n = mDataSource->readAt(offset, buffer->data(), buffer->size());
 
     if (n < (ssize_t)size) {
-        return n < 0 ? (status_t)n : ERROR_MALFORMED;
+        //return n < 0 ? (status_t)n : ERROR_MALFORMED;
     }
 
     const uint8_t *data = buffer->data();
 
-    while (size > 0) {
+    while (n >= 16) {
         uint32_t chunkType = U32_AT(data);
 
         uint8_t hi = chunkType >> 24;
         uint8_t lo = (chunkType >> 16) & 0xff;
 
         if (hi < '0' || hi > '9' || lo < '0' || lo > '9') {
-            return ERROR_MALFORMED;
+            //return ERROR_MALFORMED;
+            data += 16;
+            n -= 16;
+            continue;
         }
 
         size_t trackIndex = 10 * (hi - '0') + (lo - '0');
@@ -802,7 +1061,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
 
         if (track->mKind == Track::OTHER) {
             data += 16;
-            size -= 16;
+            n -= 16;
             continue;
         }
 
@@ -822,6 +1081,15 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
         info->mOffset = offset;
         info->mIsKey = (flags & 0x10) != 0;
 
+        if (track->mSamples.size() > 1) {
+            track->mLengthTotal += track->mPreChunkSize;
+        } else {
+            track->mLengthTotal = 0;
+        }
+
+        track->mPreChunkSize = chunkSize;
+        info->mLengthTotal = track->mLengthTotal;
+
         if (info->mIsKey) {
             static const size_t kMaxNumSyncSamplesToScan = 20;
 
@@ -838,7 +1106,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
         }
 
         data += 16;
-        size -= 16;
+        n -= 16;
     }
 
     if (!mTracks.isEmpty()) {
@@ -864,7 +1132,8 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
     for (size_t i = 0; i < mTracks.size(); ++i) {
         Track *track = &mTracks.editItemAt(i);
 
-        if (track->mBytesPerSample > 0) {
+        if (Track::AUDIO==track->mKind) {
+            if(track->mBytesPerSample > 0) {
             // Assume all chunks are roughly the same size for now.
 
             // Compute the avg. size of the first 128 chunks (if there are
@@ -877,7 +1146,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
 
             double avgChunkSize = 0;
             size_t j;
-            for (j = 0; j <= numSamplesToAverage; ++j) {
+            for (j = 0; j < numSamplesToAverage; ++j) {
                 off64_t offset;
                 size_t size;
                 bool isKey;
@@ -900,20 +1169,34 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
                 avgChunkSize += size;
             }
 
-            avgChunkSize /= numSamplesToAverage;
+            if (numSamplesToAverage > 1) {
+                avgChunkSize /= (numSamplesToAverage - 1);
+            }
 
             track->mAvgChunkSize = avgChunkSize;
+            } else {
+            continue;
+            }
         }
 
         int64_t durationUs;
+        /* SPRD: modify code for bug 522420. */
+        /*
         CHECK_EQ((status_t)OK,
                  getSampleTime(i, track->mSamples.size() - 1, &durationUs));
 
-        ALOGV("track %d duration = %.2f secs", i, durationUs / 1E6);
+        */
+        status_t error = getSampleTime(i, track->mSamples.size() - 1, &durationUs);
+        if (error != (status_t)OK){
+            return error;
+        }
+        /* @} */
+        ALOGV("track %zu duration = %.2f secs", i, durationUs / 1E6);
 
         track->mMeta->setInt64(kKeyDuration, durationUs);
         track->mMeta->setInt32(kKeyMaxInputSize, track->mMaxSampleSize);
 
+        /*
         const char *tmp;
         CHECK(track->mMeta->findCString(kKeyMIMEType, &tmp));
 
@@ -941,6 +1224,7 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
                 return err;
             }
         }
+        */
     }
 
     mFoundIndex = true;
@@ -948,6 +1232,109 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
     return OK;
 }
 
+status_t AVIExtractor::parseIndx(off64_t offset, size_t size) {
+    if (size < 32) return ERROR_MALFORMED;
+
+    sp<ABuffer> buffer = new ABuffer(size);
+    ssize_t n = mDataSource->readAt(offset, buffer->data(), buffer->size());
+
+    if (n < (ssize_t)size) {
+        return n < 0 ? (status_t)n : ERROR_MALFORMED;
+    }
+
+    const uint8_t *data = buffer->data();
+    Track *track = &mTracks.editItemAt(mTracks.size() - 1); //directly after strh&strf
+    uint32_t sizePerIndexEntry   = U16LE_AT(&data[8]) * 4;
+    uint8_t indextype      = data[11];
+    uint32_t entriesInUse  = U32LE_AT(&data[12]);
+    off64_t  baseoffset    = U64LE_AT(&data[20]);
+
+    if (!sizePerIndexEntry) return ERROR_MALFORMED;
+
+    uint32_t maxEntries = (size - 32)/sizePerIndexEntry;
+    if(entriesInUse > maxEntries) {
+        entriesInUse = maxEntries;
+    }
+
+#define AVI_INDEX_OF_INDEXES  0x00
+#define AVI_INDEX_OF_CHUNKS   0x01
+
+    mOffsetsAreAbsolute = true;
+    data += 32; //step into aIndex[]
+
+    if(indextype == AVI_INDEX_OF_CHUNKS) {
+        double avgChunkSize = 0;
+
+        for(size_t i=0; i<entriesInUse; i++) {
+            track->mSamples.push();
+            SampleInfo *info =
+                &track->mSamples.editItemAt(track->mSamples.size() - 1);
+            info->mOffset = (uint32_t)baseoffset + U32LE_AT(data) - 8;//need to point ##wb ##dc
+
+            size_t chunkSize = U32LE_AT(&data[4]);
+            info->mIsKey  = ((int32_t)chunkSize) > 0;//bit31 indicate keyframe
+
+            chunkSize = chunkSize & 0x7fffffff;
+            if (chunkSize > track->mMaxSampleSize) {
+		ALOGE("parse Indx track->maxSize:%zd, size:%zu", track->mMaxSampleSize, chunkSize );
+                track->mMaxSampleSize = chunkSize;
+		track->mMeta->setInt32(kKeyMaxInputSize, track->mMaxSampleSize);
+            }
+
+            if (track->mSamples.size() > 1) {
+                track->mLengthTotal += track->mPreChunkSize;
+            } else {
+                track->mLengthTotal = 0;
+            }
+
+            track->mPreChunkSize = chunkSize;
+            info->mLengthTotal = track->mLengthTotal;
+            if(track->mBytesPerSample > 0)
+            ALOGV("parseIndx, num=%zu, chunkSize=%zu, mLengthTotal=%d",i, chunkSize, info->mLengthTotal);
+
+            if (info->mIsKey) {
+                static const size_t kMaxNumSyncSamplesToScan = 20;
+
+                if (track->mNumSyncSamples < kMaxNumSyncSamplesToScan) {
+                    if (chunkSize > track->mThumbnailSampleSize) {
+                        track->mThumbnailSampleSize = chunkSize;
+
+                        track->mThumbnailSampleIndex =
+                        track->mSamples.size() - 1;
+                    }
+                }
+                ++track->mNumSyncSamples;
+            }
+
+            data += sizePerIndexEntry;
+            if (i == 0) {
+                track->mFirstChunkSize = size;
+                continue;
+            }
+            avgChunkSize += chunkSize;
+        }
+
+        if (entriesInUse > 1) {
+            avgChunkSize /= entriesInUse;
+        }
+        track->mAvgChunkSize = avgChunkSize;
+    }
+    else if(indextype == AVI_INDEX_OF_INDEXES)
+    {
+        for(size_t i=0; i<entriesInUse; i++) {
+            off64_t stdIndexOffset = U64LE_AT(data);
+            uint32_t stdIndexSize  = U32LE_AT(&data[8]);
+            status_t err = parseIndx(stdIndexOffset, stdIndexSize);
+            if (err) {
+                return err;
+            }
+            data += sizePerIndexEntry;
+        }
+    }
+
+    return OK;
+}
+
 static size_t GetSizeWidth(size_t x) {
     size_t n = 1;
     while (x > 127) {
@@ -958,18 +1345,46 @@ static size_t GetSizeWidth(size_t x) {
 }
 
 static uint8_t *EncodeSize(uint8_t *dst, size_t x) {
-    while (x > 127) {
-        *dst++ = (x & 0x7f) | 0x80;
+    size_t  size_len = GetSizeWidth(x);
+    uint8_t  cnt_7bit_rightshift = 0;
+
+    ALOGI("EncodeSize,  x=0x%x, size_len=%d",
+        (uint32_t)x,  (uint32_t)size_len
+    );
+
+    // if use several bytes to save the length,  the bytes shold be in big endia mode.
+    // save the hightest 7bits in the first byte with bit7=1, which means the lower 7bits  are saved in the followed byte.
+    // save the higher 7bits in the followed byte with bit7=1.
+    // save the lowest 7bits in the lastest byte with bit7=0.
+    dst += size_len;
+    while (cnt_7bit_rightshift < size_len) {
+        dst--;
+        // save the latest bytes firstly.
+        if (cnt_7bit_rightshift == 0) {
+            *dst = (x & 0x7f); 
+        } else {
+            *dst = (x & 0x7f) | 0x80;
+        }
+
         x >>= 7;
+        cnt_7bit_rightshift++;
     }
-    *dst++ = x;
+    dst += size_len;
+
+    ALOGI("EncodeSize,  x=0x%x,  [0,1]=0x%x,%x",
+        (uint32_t)x,  *(dst-2), *(dst-1)
+    );
+
     return dst;
 }
 
 sp<ABuffer> MakeMPEG4VideoCodecSpecificData(const sp<ABuffer> &config) {
     size_t len1 = config->size() + GetSizeWidth(config->size()) + 1;
-    size_t len2 = len1 + GetSizeWidth(len1) + 1 + 13;
-    size_t len3 = len2 + GetSizeWidth(len2) + 1 + 3;
+    
+    /* SPRD: modify for Video of AVI displaying divisive picture in Gallery{ */
+    size_t len2 = len1 + GetSizeWidth(len1 + 13) + 1 + 13;
+    size_t len3 = len2 + GetSizeWidth(len2 + 3) + 1 + 3;
+    /* SPRD: modify } */
 
     sp<ABuffer> csd = new ABuffer(len3);
     uint8_t *dst = csd->data();
@@ -1003,11 +1418,20 @@ status_t AVIExtractor::addMPEG4CodecSpecificData(size_t trackIndex) {
     size_t size;
     bool isKey;
     int64_t timeUs;
-    status_t err =
-        getSampleInfo(trackIndex, 0, &offset, &size, &isKey, &timeUs);
+    size_t sampleIndex = 0;
 
-    if (err != OK) {
-        return err;
+    for (;;) {
+        status_t err = getSampleInfo(trackIndex, sampleIndex, &offset, &size, &isKey, &timeUs);
+
+        if (err != OK) {
+            return err;
+        }
+
+        if (size <= 0) {
+            sampleIndex ++;
+        } else {
+            break;
+        }
     }
 
     sp<ABuffer> buffer = new ABuffer(size);
@@ -1109,13 +1533,76 @@ status_t AVIExtractor::getSampleInfo(
         return -ERANGE;
     }
 
-    const Track &track = mTracks.itemAt(trackIndex);
+    Track *track = &mTracks.editItemAt(trackIndex);
+    uint32_t chunkType;
+    if (sampleIndex >= track->mSamples.size()) {
+        if(mIndexType == NO_INDEX) { //parse movi data to get index info
+            while(sampleIndex >= track->mSamples.size()) {
+                uint8_t tmp[12];
+                ssize_t n = mDataSource->readAt(track->mCurSamplePos, tmp, 8);
+                if (n < 8) {
+                    return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+                }
+                chunkType = U32_AT(tmp);
 
-    if (sampleIndex >= track.mSamples.size()) {
-        return -ERANGE;
+                if(chunkType == FOURCC('L', 'I', 'S', 'T')) {
+                    track->mCurSamplePos += 12; //skip LIST rec
+                    continue;
+                }
+
+                uint8_t hi = chunkType >> 24;
+                uint8_t lo = (chunkType >> 16) & 0xff;
+
+                if (hi < '0' || hi > '9' || lo < '0' || lo > '9') {
+                    return ERROR_MALFORMED;
+                }
+
+                size_t tmpIndex = 10 * (hi - '0') + (lo - '0');
+
+                if (tmpIndex >= mTracks.size()) {
+                    return ERROR_MALFORMED;
+                }
+
+                uint32_t sampleSize = U32LE_AT(&tmp[4]);
+                if (trackIndex != tmpIndex) {
+                    track->mCurSamplePos += (sampleSize + 8);
+                    if (track->mCurSamplePos & 1) { //careful
+                        ++track->mCurSamplePos;
+                    }
+                    continue;
+                }
+                //new sample
+                track->mSamples.push();
+                if (track->mSamples.size() > 1) {
+                    track->mLengthTotal += track->mPreChunkSize;
+                } else {
+                    track->mLengthTotal = 0;
+                }
+                track->mPreChunkSize = sampleSize;
+
+                SampleInfo *info =
+                    &track->mSamples.editItemAt(track->mSamples.size() - 1);
+                info->mOffset = track->mCurSamplePos;
+                info->mIsKey = true;//don't know.
+                info->mLengthTotal = track->mLengthTotal;
+
+                track->mCurSamplePos += (sampleSize + 8);
+                if (track->mCurSamplePos & 1) {
+                    ++track->mCurSamplePos;
+                }
+
+                if (sampleIndex == 0) {
+                    track->mFirstChunkSize = sampleSize;
+                    track->mAvgChunkSize = sampleSize; //don't care it
+                }
+            }
+            //TODO: actually don't need to execute the following data, should return now?
+        } else {
+            return -ERANGE;
+        }
     }
 
-    const SampleInfo &info = track.mSamples.itemAt(sampleIndex);
+    const SampleInfo &info = track->mSamples.itemAt(sampleIndex);
 
     if (!mOffsetsAreAbsolute) {
         *offset = info.mOffset + mMovieOffset + 8;
@@ -1132,9 +1619,9 @@ status_t AVIExtractor::getSampleInfo(
         return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
     }
 
-    uint32_t chunkType = U32_AT(tmp);
+    chunkType = U32_AT(tmp);
 
-    if (!IsCorrectChunkType(trackIndex, track.mKind, chunkType)) {
+    if (!IsCorrectChunkType(trackIndex, track->mKind, chunkType)) {
         return ERROR_MALFORMED;
     }
 
@@ -1143,19 +1630,11 @@ status_t AVIExtractor::getSampleInfo(
 
     *isKey = info.mIsKey;
 
-    if (track.mBytesPerSample > 0) {
-        size_t sampleStartInBytes;
-        if (sampleIndex == 0) {
-            sampleStartInBytes = 0;
-        } else {
-            sampleStartInBytes =
-                track.mFirstChunkSize + track.mAvgChunkSize * (sampleIndex - 1);
-        }
-
-        sampleIndex = sampleStartInBytes / track.mBytesPerSample;
+    if ((Track::AUDIO==track->mKind) && (track->mBytesPerSample > 0)) {
+        sampleIndex = info.mLengthTotal / track->mBytesPerSample;
     }
 
-    *sampleTimeUs = (sampleIndex * 1000000ll * track.mRate) / track.mScale;
+    *sampleTimeUs = (sampleIndex * 1000000ll * track->mRate) / track->mScale;
 
     return OK;
 }
@@ -1181,7 +1660,7 @@ status_t AVIExtractor::getSampleIndexAtTime(
 
     ssize_t closestSampleIndex;
 
-    if (track.mBytesPerSample > 0) {
+    if ((Track::AUDIO==track.mKind) && (track.mBytesPerSample > 0)) {
         size_t closestByteOffset =
             (timeUs * track.mBytesPerSample)
                 / track.mRate * track.mScale / 1000000ll;
@@ -1189,9 +1668,27 @@ status_t AVIExtractor::getSampleIndexAtTime(
         if (closestByteOffset <= track.mFirstChunkSize) {
             closestSampleIndex = 0;
         } else {
-            closestSampleIndex =
-                (closestByteOffset - track.mFirstChunkSize)
-                    / track.mAvgChunkSize;
+            if (NO_INDEX != mIndexType && track.mSamples.size() > 0) {
+                uint32_t i = 0;
+                const SampleInfo *info = &track.mSamples.itemAt(0);
+                while (info->mLengthTotal < closestByteOffset) {
+                    ++i;
+                    if (i >= track.mSamples.size()) {
+                        break;
+                    }
+                    info = &track.mSamples.itemAt(i);
+                    ALOGV("audiotrack seek, num=%d, mLengthTotal=%d",i, info->mLengthTotal);
+                }
+                closestSampleIndex = (info->mLengthTotal == closestByteOffset)? i: (i - 1);
+                ALOGI("mIndexType=%d, closestSampleIndex=%zd, closestByteOffset=%zu, \
+                      info->mLengthTotal=%d, rate=%d, scale=%d, samplesize=%d",
+                      mIndexType, closestSampleIndex, closestByteOffset, info->mLengthTotal, 
+                      track.mRate, track.mScale, track.mBytesPerSample);
+            } else {
+                closestSampleIndex =
+                    (closestByteOffset - track.mFirstChunkSize)
+                        / track.mAvgChunkSize;
+            }
         }
     } else {
         // Each chunk contains a single sample.
@@ -1199,6 +1696,9 @@ status_t AVIExtractor::getSampleIndexAtTime(
     }
 
     ssize_t numSamples = track.mSamples.size();
+    if (!numSamples) {
+        return NOT_ENOUGH_DATA;
+    }
 
     if (closestSampleIndex < 0) {
         closestSampleIndex = 0;
@@ -1236,6 +1736,9 @@ status_t AVIExtractor::getSampleIndexAtTime(
         ++nextSyncSampleIndex;
     }
 
+    ALOGI("Track=%d, seek_mode=%d, sampleIndex=%zu, closestSampleIndex=%zd",
+                    track.mKind, mode, *sampleIndex, closestSampleIndex);
+
     switch (mode) {
         case MediaSource::ReadOptions::SEEK_PREVIOUS_SYNC:
         {
@@ -1254,7 +1757,12 @@ status_t AVIExtractor::getSampleIndexAtTime(
         case MediaSource::ReadOptions::SEEK_CLOSEST_SYNC:
         {
             if (prevSyncSampleIndex < 0 && nextSyncSampleIndex >= numSamples) {
-                return UNKNOWN_ERROR;
+                if (closestSampleIndex >= 0 && closestSampleIndex < numSamples) {
+                    *sampleIndex = closestSampleIndex; // seek to closestSampleIndex
+                    return OK;
+                } else {
+                    return UNKNOWN_ERROR;
+                }
             }
 
             if (prevSyncSampleIndex < 0) {
@@ -1266,12 +1774,34 @@ status_t AVIExtractor::getSampleIndexAtTime(
                 *sampleIndex = prevSyncSampleIndex;
                 return OK;
             }
-
+ 
             size_t dist1 = closestSampleIndex - prevSyncSampleIndex;
             size_t dist2 = nextSyncSampleIndex - closestSampleIndex;
 
-            *sampleIndex =
-                (dist1 < dist2) ? prevSyncSampleIndex : nextSyncSampleIndex;
+            if(Track::VIDEO==track.mKind) {
+                ALOGV("sampleIndex=%zu, closestSampleIndex=%zd",
+                    *sampleIndex, closestSampleIndex);
+
+                if(*sampleIndex < (size_t)closestSampleIndex) { //forward seek
+                    if(dist1 < dist2 && *sampleIndex  < (size_t)prevSyncSampleIndex + 1) {
+                        *sampleIndex = prevSyncSampleIndex;
+                    } else {
+                        *sampleIndex = nextSyncSampleIndex;
+                    }
+                } else { //backward seek
+                    if (dist1 > dist2 && *sampleIndex  > (size_t)nextSyncSampleIndex + 1) {
+                        *sampleIndex = nextSyncSampleIndex;
+                    } else {
+                        *sampleIndex = prevSyncSampleIndex;
+                    }
+                }
+            } else {
+                *sampleIndex =
+                    (dist1 < dist2) ? prevSyncSampleIndex : nextSyncSampleIndex;
+            }
+
+            ALOGI("sampleIndex=%zu, prevSyncSampleIndex=%zd, nextSyncSampleIndex=%zd",
+                *sampleIndex, prevSyncSampleIndex, nextSyncSampleIndex);
 
             return OK;
         }
@@ -1296,7 +1826,7 @@ bool SniffAVI(
         // Just a tad over the mp3 extractor's confidence, since
         // these .avi files may contain .mp3 content that otherwise would
         // mistakenly lead to us identifying the entire file as a .mp3 file.
-        *confidence = 0.21;
+        *confidence = 0.31;
 
         return true;
     }
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index e708f68..2a52d04 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -78,6 +78,10 @@ LOCAL_SRC_FILES:=                         \
         XINGSeeker.cpp                    \
         avc_utils.cpp                     \
         FFMPEGSoftCodec.cpp               \
+        AVIExtractor.cpp                  \
+        FLVExtractor.cpp                  \
+        FileCache.cpp                     \
+        MP3FileSource.cpp                 \
 
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/ \
@@ -202,6 +206,10 @@ LOCAL_C_INCLUDES += \
 	$(TOP)/hardware/samsung/exynos4/include
 endif
 
+ifeq ($(BOARD_USE_SPRD_COLORFORMAT), true)
+LOCAL_CFLAGS += -DUSE_SPRD_COLORFORMAT
+endif
+
 LOCAL_MODULE:= libstagefright
 
 LOCAL_MODULE_TAGS := optional
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index bb4ea41..96847bf 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -130,6 +130,8 @@ static int32_t getColorFormat(const char* colorFormat) {
 #ifdef USE_SAMSUNG_COLORFORMAT
         static const int OMX_SEC_COLOR_FormatNV12LPhysicalAddress = 0x7F000002;
         return OMX_SEC_COLOR_FormatNV12LPhysicalAddress;
+#elif USE_SPRD_COLORFORMAT
+        return OMX_SPRD_COLOR_FormatYVU420SemiPlanar;
 #else
         return OMX_COLOR_FormatYUV420SemiPlanar;
 #endif
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 485aefa..0c804e1 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -33,8 +33,11 @@
 #include "include/WAVExtractor.h"
 #include "include/WVMExtractor.h"
 
+#include "include/AVIExtractor.h"
+#include "include/FLVExtractor.h"
 #include "matroska/MatroskaExtractor.h"
 
+#include "include/PSXSTRExtractor.h"
 #include <media/IMediaHTTPConnection.h>
 #include <media/IMediaHTTPService.h>
 #include <media/stagefright/foundation/ADebug.h>
@@ -196,6 +199,9 @@ void DataSource::RegisterDefaultSniffers() {
         RegisterSniffer_l(SniffWVM);
     }
     RegisterSniffer_l(SniffMidi);
+    RegisterSniffer_l(SniffAVI);
+    RegisterSniffer_l(SniffPSXSTR);
+    RegisterSniffer_l(SniffFLV);
     RegisterSniffer_l(AVUtils::get()->getExtendedSniffer());
     RegisterSniffer_l(FFMPEGSoftCodec::getSniffer());
 
diff --git a/media/libstagefright/FLVExtractor.cpp b/media/libstagefright/FLVExtractor.cpp
new file mode 100644
index 0000000..868b873
--- /dev/null
+++ b/media/libstagefright/FLVExtractor.cpp
@@ -0,0 +1,1392 @@
+/* *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License. */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "FLVExtractor"
+#include <utils/Log.h>
+
+#include "include/avc_utils.h"
+#include "include/FLVExtractor.h"
+
+#include <binder/ProcessState.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <media/stagefright/MediaBufferGroup.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
+
+namespace android {
+
+struct FLVExtractor::FLVSource : public MediaSource {
+public:
+    FLVSource(const sp<FLVExtractor> &extractor, size_t trackIndex);
+
+    virtual status_t start(MetaData *params);
+    virtual status_t stop();
+
+    virtual sp<MetaData> getFormat();
+
+    virtual status_t read(
+            MediaBuffer **buffer, const ReadOptions *options);
+
+protected:
+    virtual ~FLVSource();
+
+private:
+    sp<FLVExtractor> mExtractor;
+    size_t mTrackIndex;
+    const FLVExtractor::Track &mTrack;
+    MediaBufferGroup *mBufferGroup;
+    size_t mTagIndex;
+
+    // for AVC.
+    bool mIsAVC;
+    size_t mNALLengthSize;
+    uint8_t *mSrcBuffer;
+
+    //for AAC.
+    bool mIsAAC;
+
+    //sp<MP3Splitter> mSplitter;
+
+    bool mIsStartAfterEOS;
+    size_t parseNALSize(const uint8_t *data) const;
+
+    DISALLOW_EVIL_CONSTRUCTORS(FLVSource);
+};
+
+FLVExtractor::FLVSource::FLVSource(
+        const sp<FLVExtractor> &extractor, size_t trackIndex)
+    : mExtractor(extractor),
+      mTrackIndex(trackIndex),
+      mTrack(mExtractor->mTracks.itemAt(trackIndex)),
+      mBufferGroup(NULL),
+      mIsStartAfterEOS(false){
+
+    const char *mime;
+    bool success = mTrack.mMeta->findCString(kKeyMIMEType, &mime);
+    CHECK(success);
+    mIsAVC = !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC);
+    mIsAAC = !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC);
+
+    if (mIsAVC) {
+        uint32_t type;
+        const void *data;
+        size_t size;
+        CHECK(mTrack.mMeta->findData(kKeyAVCC, &type, &data, &size));
+
+        const uint8_t *ptr = (const uint8_t *)data;
+
+        CHECK(size >= 7);
+        CHECK_EQ((unsigned)ptr[0], 1u);  // configurationVersion == 1
+
+        // The number of bytes used to encode the length of a NAL unit.
+        mNALLengthSize = 1 + (ptr[4] & 3);
+    }
+    ALOGE("mIsAVC=%d, mNALLengthSize=%zd",mIsAVC,mNALLengthSize);
+
+}
+
+FLVExtractor::FLVSource::~FLVSource() {
+    if (mBufferGroup) {
+        stop();
+    }
+}
+
+status_t FLVExtractor::FLVSource::start(MetaData *params) {
+    if (params) {
+        ALOGI("%s, have MetaData: %p", __FUNCTION__, params);
+    }
+
+    CHECK(!mBufferGroup);
+
+    mBufferGroup = new MediaBufferGroup;
+
+    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxTagSize));
+    mBufferGroup->add_buffer(new MediaBuffer(mTrack.mMaxTagSize));
+    mTagIndex = 0;
+
+    mSrcBuffer = NULL;
+    if(mIsAVC)
+    {
+        mSrcBuffer = new uint8_t[mTrack.mMaxTagSize]; ;
+    }
+
+    return OK;
+}
+
+status_t FLVExtractor::FLVSource::stop() {
+    CHECK(mBufferGroup);
+
+    delete mBufferGroup;
+    mBufferGroup = NULL;
+
+    if(NULL != mSrcBuffer)
+    {
+        delete[] mSrcBuffer;
+        mSrcBuffer = NULL;
+    }
+    return OK;
+}
+
+sp<MetaData> FLVExtractor::FLVSource::getFormat() {
+    return mTrack.mMeta;
+}
+
+size_t FLVExtractor::FLVSource::parseNALSize(const uint8_t *data) const {
+    switch (mNALLengthSize) {
+        case 1:
+            return *data;
+        case 2:
+            return U16_AT(data);
+        case 3:
+            return ((size_t)data[0] << 16) | U16_AT(&data[1]);
+        case 4:
+            return U32_AT(data);
+    }
+
+    // This cannot happen, mNALLengthSize springs to life by adding 1 to
+    // a 2-bit integer.
+    CHECK(!"Should not be here.");
+
+    return 0;
+}
+
+status_t FLVExtractor::FLVSource::read(
+        MediaBuffer **buffer, const ReadOptions *options) {
+     CHECK(mBufferGroup);
+
+    *buffer = NULL;
+
+    int64_t seekTimeUs;
+    ReadOptions::SeekMode seekMode;
+    status_t status;
+    if(mIsAAC)
+    {
+        if (options && options->getSeekTo(&seekTimeUs, &seekMode)
+            && mExtractor->mCurrentTimeUs>=0)
+        {
+            status = mExtractor->getKeyFramePosition(mTrackIndex, seekTimeUs,mTrack.mMaxTagSize);
+            if(mIsStartAfterEOS && (ERROR_MALFORMED == status)) {
+                mExtractor->setInitTagPos(mTrackIndex);
+            }
+            if(mIsStartAfterEOS)
+                mIsStartAfterEOS = false;
+        }
+        else if(options && options->getSeekTo(&seekTimeUs, &seekMode)
+            && mExtractor->mLastseekTimeUs<0 && seekTimeUs!=0)
+        {
+            ALOGE("seek before play !trackid:%d ,save seektime:%lld",mTrack.mKind, (long long)seekTimeUs);
+            mExtractor->mLastseekTimeUs = seekTimeUs;
+        }
+        else if(mExtractor->mCurrentTimeUs > 0 && mExtractor->mLastseekTimeUs > 0
+                  && mTrack.mKind == Track::AUDIO)
+        {
+            ALOGE("seek track:%d with mLastseekTimeUs %lld",mTrack.mKind,(long long)mExtractor->mLastseekTimeUs);
+            mExtractor->getKeyFramePosition(mTrackIndex, mExtractor->mLastseekTimeUs,mTrack.mMaxTagSize);
+            mExtractor->mLastseekTimeUs = -1;
+        }
+    }
+    else
+    {
+        if (options && options->getSeekTo(&seekTimeUs, &seekMode))
+        {
+            status = mExtractor->getKeyFramePosition(mTrackIndex, seekTimeUs,mTrack.mMaxTagSize);
+            if(((0 == seekTimeUs) || mIsStartAfterEOS) && (ERROR_MALFORMED == status)) {
+                mExtractor->setInitTagPos(mTrackIndex);
+            }
+
+            if(mIsStartAfterEOS)
+                mIsStartAfterEOS = false;
+
+        }
+    }
+
+    for (;;) {
+        off64_t offset;
+        size_t size;
+        bool isKey;
+        int64_t timeUs;
+        status_t err = mExtractor->getTagInfoWithOffset(mTrackIndex, mTrack.mCurTagPos,
+            &offset, &size, &isKey, &timeUs);
+        if(mIsAAC)
+        {
+            mExtractor->mCurrentTimeUs = timeUs;
+        }
+        ++mTagIndex;
+
+        //ALOGE("getTagInfo offset:%4lld, size:%d, trackID:%d,  tagId:%d,time:%4lld", offset, size,mTrackIndex, mTagIndex, timeUs);
+        if (err != OK) {
+           // if( mTagIndex < mTrack.mTags.size() ) {
+            //    continue;
+            //} else {
+            if(mIsAAC) {
+                mExtractor->mCurrentTimeUs = 0;
+            }
+            mIsStartAfterEOS = true;
+
+                return ERROR_END_OF_STREAM;
+            //}
+        }
+        if(size > mTrack.mMaxTagSize)
+        {
+            ALOGE("buffer is not enough, size=%zu,maxsize=%zu",size, mTrack.mMaxTagSize);
+            return ERROR_MALFORMED;
+        }
+
+        MediaBuffer *out;
+        CHECK_EQ(mBufferGroup->acquire_buffer(&out), (status_t)OK);
+        //
+        out->meta_data()->setInt64(kKeyTime, timeUs);
+        if (isKey) {
+            out->meta_data()->setInt32(kKeyIsSyncFrame, 1);
+        }
+
+        if(!mIsAVC)
+        {
+            ssize_t n = mExtractor->mDataSource->readAt(offset, out->data(), size);
+            if (n < (ssize_t)size) {
+                out->release();
+                return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
+            }
+
+            if(!mIsAAC)
+            {
+                out->set_range(0, size);
+            }
+            else
+            {
+                // read out one AACAUDIODATA(the 1Byte head of AUDIODATA has been skipped).
+                /*   struct for AACAUDIODATA
+                AACPacketType       UI8         0: AAC sequence header
+                                                1: AAC raw
+                Data                UI8[n]      if AACPacketType == 0
+                                                    AudioSpecificConfig
+                                                else if AACPacketType == 1
+                                                    Raw AAC frame data
+                */
+                 // NOTE: skip the  the header of AACAUDIODATA(1Bytes).
+                out->set_range(1, (size>1)?(size-1):0);
+            }
+
+            *buffer = out;
+        }
+        else
+        {
+            // Whole NAL units are returned but each fragment is prefixed by
+            // the start code (0x00 00 00 01).
+            uint8_t *dstData;
+            uint8_t *srcData;
+            size_t srcOffset;
+            size_t dstOffset;
+
+            /* Read one AVCVIdeoPacket  to the temp buffer( the 1Byte header of VIDEODATA has
+                 been skipped ).  */
+            ssize_t n = mExtractor->mDataSource->readAt(offset, mSrcBuffer, size);
+            if ((n < (ssize_t)size ) || (size < 4)) {
+                out->release();
+                return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
+            }
+
+            // check the AVCPacketType.  Only  send out AVC NALU.
+            if( mSrcBuffer[0] != 1)
+            {
+                // AVCPacketType has been saved in meta data. discard it.
+                ALOGE("AVCPacketType = %d, discard. ",mSrcBuffer[0]);
+                out->release();
+                continue;
+            }
+            // skip the header of AVCVIdeoPacket(4Bytes).
+            size  -= 4;
+            srcData = mSrcBuffer + 4;
+            srcOffset = 0;
+            dstData = (uint8_t *)out->data();
+            dstOffset = 0;
+
+            while (srcOffset < size) {
+                bool isMalFormed = (srcOffset + mNALLengthSize > size);
+                size_t nalLength = 0;
+                if (!isMalFormed) {
+                    nalLength = parseNALSize(&srcData[srcOffset]);
+                    srcOffset += mNALLengthSize;
+                    isMalFormed = srcOffset + nalLength > size;
+                }
+
+                if (isMalFormed) {
+                    ALOGE("Video is malformed,srcOffset=%zu, nalLength=%zu, size=%zu",srcOffset,nalLength,size);
+                    out->release();
+                    return ERROR_MALFORMED;
+                }
+
+                if (nalLength == 0) {
+                    ALOGE("nalLength is error or end of the tag");
+                    break;
+                }
+
+                CHECK(dstOffset + 4 <= out->size());
+
+                dstData[dstOffset++] = 0;
+                dstData[dstOffset++] = 0;
+                dstData[dstOffset++] = 0;
+                dstData[dstOffset++] = 1;
+                memcpy(&dstData[dstOffset], &srcData[srcOffset], nalLength);
+                srcOffset += nalLength;
+                dstOffset += nalLength;
+            }
+            CHECK_EQ(srcOffset, size);
+            CHECK(out != NULL);
+            out->set_range(0, dstOffset);
+
+             *buffer = out;
+        }
+       break;
+    }
+
+    return OK;
+}
+
+FLVExtractor::FLVExtractor(const sp<DataSource> &dataSource)
+    : mDataSource(dataSource),
+    mKeyFrameEntries(NULL),
+    mKeyFrameNum(0),
+    mCurrentTimeUs(0),
+    mIsMetadataPresent(false),
+    mLastseekTimeUs(-1) {
+    mInitCheck = parseHeaders();
+
+    /*check video height and width to avoid Native Crash*/
+    for(size_t i = 0; i < mTracks.size(); i++) {
+        sp<MetaData> mdata = mTracks.editItemAt(i).mMeta;
+        const char *mime;
+        CHECK(mdata->findCString(kKeyMIMEType, &mime));
+        if (!strncasecmp(mime, "video/", 6)) {
+            int32_t width, height;
+            bool success = mdata->findInt32(kKeyWidth, &width);
+            success = success && mdata->findInt32(kKeyHeight, &height);
+            if(!success) {
+                ALOGE("the video track has no height or width profile");
+                mInitCheck = UNKNOWN_ERROR;
+            }
+        }
+    }
+
+    if (mInitCheck != OK) {
+        mTracks.clear();
+    }
+}
+
+FLVExtractor::~FLVExtractor(){
+    delete[] mKeyFrameEntries;
+    mKeyFrameEntries = NULL;
+}
+
+size_t FLVExtractor::countTracks() {
+    return mTracks.size();
+}
+
+sp<IMediaSource> FLVExtractor::getTrack(size_t index) {
+    return index < mTracks.size() ? new FLVSource(this, index) : NULL;
+}
+
+sp<MetaData> FLVExtractor::getTrackMetaData(
+        size_t index, uint32_t flags) {
+    if (flags) {
+        ALOGI("%s, type: %d", __FUNCTION__, flags);
+    }
+    return index < mTracks.size() ? mTracks.editItemAt(index).mMeta : NULL;
+}
+
+sp<MetaData> FLVExtractor::getMetaData() {
+    sp<MetaData> meta = new MetaData;
+
+    if (1){//mInitCheck == OK) {
+        meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_CONTAINER_FLV);
+    }
+
+    return meta;
+}
+
+uint32_t FLVExtractor::flags() const {
+    if(mKeyFrameEntries != NULL)
+    {
+        return MediaExtractor::flags();
+    }
+    else
+    {
+        ALOGI("key frame entries is null, can't seek");
+        return CAN_PAUSE;
+    }
+}
+
+status_t FLVExtractor::parseHeaders() {
+    mTracks.clear();
+
+    off64_t dataSize = 0;
+    status_t err = mDataSource->getSize(&dataSize);
+    if(err == ERROR_UNSUPPORTED)
+    {
+        dataSize = -1;
+    }
+    else if(err != OK)
+    {
+        return err;
+    }
+
+    ssize_t res = parseTagHeaders(0ll, dataSize);
+
+    if (res < 0) {
+        return (status_t)res;
+    }
+
+    return OK;
+}
+
+status_t FLVExtractor::parseTagHeaders(off64_t offset, off64_t size) {
+    sp<MetaData> meta = new MetaData;
+    int32_t maxTagSize = 0;
+
+    if (size >= 0 && size < 9) {
+        return ERROR_MALFORMED;
+    }
+
+    uint8_t hdr[9];
+    if (mDataSource->readAt(offset, hdr, 9) < 9) {
+        return ERROR_IO;
+    }
+    //ALOGE("parseTagHeaders hdr:0x%x %x %x %x %x %x %x %x %x", hdr[0],hdr[1],hdr[2],hdr[3],hdr[4],hdr[5],hdr[6],hdr[7],hdr[8] );
+
+    if(hdr[4]&0x4) {//Audio tags are present
+        ALOGE(" detect audio tags");
+        mTracks.push();
+        Track *track = &mTracks.editItemAt( mTracks.size() - 1 );
+        maxTagSize = FLV_AUDIO_TAG_MAX_SIZE;
+        sp<MetaData> meta = new MetaData;
+        meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
+        track->mKind = Track::AUDIO;
+        track->mMeta = meta;
+        track->mMaxTagSize = maxTagSize;
+     }
+
+    if(hdr[4]&0x1) {//Video tags are present
+        ALOGE(" detect video tags");
+        mTracks.push();
+        Track *track = &mTracks.editItemAt( mTracks.size() - 1 );
+        maxTagSize = FLV_VIDEO_TAG_MAX_SIZE;
+        sp<MetaData> meta = new MetaData;
+        meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_H263);
+        meta->setInt32(kKeyWidth,1920); //give default value for Width
+        meta->setInt32(kKeyHeight,1088); //give default value for Height
+        track->mKind = Track::VIDEO;
+        track->mMeta = meta;
+        track->mMaxTagSize = maxTagSize;
+    }
+
+    uint32_t DataOffset = U32_AT(&hdr[5]);
+
+    ssize_t res = parseTag(offset+DataOffset, size);
+
+    if (res < 0) {
+        return (status_t)res;
+    }
+
+    //store mInitTagPos
+    for(size_t i = 0; i<mTracks.size(); i++) {
+        Track *track = &mTracks.editItemAt(i);
+        track->mInitTagPos = track->mCurTagPos;
+    }
+
+    return OK;
+}
+
+void FLVExtractor:: setInitTagPos(size_t trackIndex) {
+    if (trackIndex >= mTracks.size()) {
+        ALOGE("trackId:%zd, size:%zd", trackIndex, mTracks.size());
+        return;
+    }
+
+    Track *track = &mTracks.editItemAt(trackIndex);
+    track->mCurTagPos= track->mInitTagPos;
+}
+
+status_t FLVExtractor::parseTag(off_t offset, off64_t size) {
+     if (size >= 0 && size < (4 + SIZE_OF_TAG_HEAD + 1) ) {
+        return ERROR_MALFORMED;
+    }
+    uint8_t tmp[4 + SIZE_OF_TAG_HEAD + 1];
+
+    ssize_t n = mDataSource->readAt(offset, tmp, 4 + SIZE_OF_TAG_HEAD + 1);
+
+    if (n < (4 + SIZE_OF_TAG_HEAD + 1)) {
+        ALOGE("readSize:%zd", n );
+        return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+    }
+
+    uint32_t type, len, flags;
+    Track *Vtrack = NULL, *Atrack=NULL;
+    //ALOGE("parseTag hdr:0x%x %x %x %x %x %x %x %x %x", tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[15]);
+    type    = tmp[4];
+    len    = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+    //*p_pts  = (tmp[8] << 16) | (tmp[9] << 8) | (tmp[10]);
+    flags   = tmp[4 + SIZE_OF_TAG_HEAD];
+
+    //ALOGE("parseTag first run: type:0x%x, len:0x%x, flags:0x%x", type, len, flags);
+
+    if (FLV_TAG_TYPE_META == type) {
+        ALOGI("Metadata is presented");
+        mIsMetadataPresent = true;
+    }
+
+    for( uint32_t i=0; i<mTracks.size(); i++) {
+        Track *track = &mTracks.editItemAt( i );
+        if (mIsMetadataPresent) {
+            track->mCurTagPos = offset + 4 + SIZE_OF_TAG_HEAD + len;
+        } else{
+            track->mCurTagPos = offset;
+        }
+
+        if( track->mKind == Track::VIDEO ) {
+            ALOGI("Track::VIDEO");
+            Vtrack = track;
+        } else if ( track->mKind == Track::AUDIO) {
+            ALOGI("Track::AUDIO");
+            Atrack = track;
+        } else
+            ALOGE("parseTag error, track is invalid");
+    }
+
+    if( FLV_TAG_TYPE_META == type) {
+        flv_read_metabody(offset+4+SIZE_OF_TAG_HEAD);
+    }
+
+    if( Vtrack) {
+        offset = Vtrack->mCurTagPos;
+        for(;;) {
+        if( mIsMetadataPresent) {
+            ssize_t n = mDataSource->readAt(offset, tmp, 4 + SIZE_OF_TAG_HEAD + 1);
+
+            if (n < (4 + SIZE_OF_TAG_HEAD + 1)) {
+                ALOGE("readSize:%zd", n );
+                return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+            }
+
+            //ALOGE("parseVideoTagHeaders hdr:0x%x,%x,%x,%x,%x,%x,%x,%x,%x", tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[15]);
+            type    = tmp[4];
+            len    = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+            flags   = tmp[4 + SIZE_OF_TAG_HEAD];
+        }
+
+            if(FLV_TAG_TYPE_VIDEO==type) {
+                Vtrack->mCurTagPos = offset;
+                ALOGE("get video tag Header! Vtrack->mCurTagPos %d",Vtrack->mCurTagPos);
+                switch(flags&0x0f)
+                {
+                case FLV_CODECID_H263:
+                    Vtrack->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_H263);
+                    break;
+                case FLV_CODECID_AVC:
+                    Vtrack->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
+                    // NOTE: skip the head of VIDEODATA(1Byte) and the header of AVCPacketType(4Bytes).
+                    if( len > 5 ) // 1+4
+                    {
+                        /*   struct for AVCVIDEOPACKET
+                            AVCPacketType       UI8         0: AVC sequence header
+                                                            1: AVC NALU
+                                                            2: AVC end of sequence (lower level NALU
+                                                                sequence ender is not required or supported)
+                            CompositionTime     SI24        if AVCPacketType == 1
+                                                                Composition time offset
+                                                            else
+                                                                0
+                            Data                            UI8[n]      if AVCPacketType == 0
+                                                                AVCDecoderConfigurationRecord
+                                                            else if AVCPacketType == 1
+                                                                One or more NALUs (can be individual
+                                                                slices per FLV packets; that is, full frames
+                                                                are not strictly required)
+                                                            else if AVCPacketType == 2
+                                                                Empty
+                        */
+                        uint8_t *pSrcBuffer;
+                        ssize_t n, l;
+
+                        pSrcBuffer = new uint8_t[len-1];
+                        if(NULL ==  pSrcBuffer)
+                        {
+                            return MEDIA_ERROR_BASE;
+                        }
+
+                        // read one AVCVIdeoPacket. skip the head of VIDEODATA(1Byte).
+                        n = mDataSource->readAt(offset + 4 + SIZE_OF_TAG_HEAD + 1, pSrcBuffer, len-1);
+                        l = len - 1;
+                        if (n < l) {
+                            ALOGE("read AVCVIdeoPacket error, size:%lld vs %zd", (long long)size, n);
+                            delete[] pSrcBuffer;
+                            return ERROR_MALFORMED;
+                        }
+
+                        // check the AVCPacketType.
+                        if(pSrcBuffer[0] == 0)
+                        {
+                            // save the AVCDecoderConfigurationRecord in meta data.
+                            // skip the head of AVCVIdeoPacket(4Bytes).
+                            Vtrack->mMeta->setData(kKeyAVCC, kTypeAVCC, &(pSrcBuffer[4]), len-5);
+                        }
+                        // TODO: else.
+
+                        delete[] pSrcBuffer;
+                    }
+                    break;
+                case FLV_CODECID_SCREEN:
+                case FLV_CODECID_SCREEN2:
+                case FLV_CODECID_VP6:
+                case FLV_CODECID_VP6A:
+                default:
+                    break;
+                }
+                break;
+            } else {
+                offset += 4 + SIZE_OF_TAG_HEAD + len;
+                continue;
+            }
+        }
+    }
+
+   if(Atrack) {
+        offset = Atrack->mCurTagPos;
+        for(;;) {
+            ssize_t n = mDataSource->readAt(offset, tmp, 4 + SIZE_OF_TAG_HEAD + 1);
+
+            if (n < (4 + SIZE_OF_TAG_HEAD + 1)) {
+                ALOGE("readSize:%zd", n );
+                return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+            }
+
+            //ALOGE("parseAudioTagHeaders hdr:0x%x,%x,%x,%x,%x,%x,%x,%x,%x", tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[15]);
+            type    = tmp[4];
+            len    = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+            flags   = tmp[4 + SIZE_OF_TAG_HEAD];
+
+            if(FLV_TAG_TYPE_AUDIO==type) {
+                ALOGE("get audio tag Header!");
+                Atrack->mCurTagPos = offset;
+                uint8_t audio_codec = flags&FLV_AUDIO_CODECID_MASK;
+                switch(audio_codec)
+                {
+                    case FLV_CODECID_MP3:
+                        Atrack->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
+                        break;
+                    case FLV_CODECID_AAC:
+                    Atrack->mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC);
+
+                    // NOTE: skip the head of AUDIODATA(1Byte) and the header of AACPacketType(1Bytes).
+                    if ( len > 2 )  {
+                        /*   struct for AACAUDIODATA
+                        AACPacketType       UI8         0: AAC sequence header
+                                                        1: AAC raw
+                        Data                            UI8[n]      if AACPacketType == 0
+                        AudioSpecificConfig
+                        else if AACPacketType == 1
+                        Raw AAC frame data
+                        */
+                        uint8_t *esds;
+                        ssize_t n, l;
+
+                        esds = new uint8_t[22+len-2];
+                        if (NULL ==  esds) {
+                            ALOGE("esds alloc failed");
+                            return MEDIA_ERROR_BASE;
+                        }
+                        memset(esds, 0, 22+len-2);
+
+                        // read one AACAUDIODATA. skip the head of AUDIODATA(1Byte).
+                        n = mDataSource->readAt(offset + 4 + SIZE_OF_TAG_HEAD + 1, &(esds[21]), len-1);
+                        l = len - 1;
+                        if (n < l) {
+                            ALOGE("read AACAUDIODATA error, size:%lld vs %zd", (long long)size, n);
+                            delete[] esds;
+                            return ERROR_MALFORMED;
+                        }
+
+                        // check the AACPacketType.
+                        if (0 == esds[21] ) {
+                            // packet the AudioSpecificConfig into ESDS
+                            // skip the head of AACPacketType(1Bytes)
+                            esds[0] = 0x3;
+                            esds[1] = 18+len;
+                            esds[5] = 0x4;
+                            esds[6] = 13+len;
+                            esds[20] = 0x5;
+                            esds[21] = len-2;
+
+                            //saved esds in meta data.
+                            Atrack->mMeta->setData(kKeyESDS, kTypeESDS, esds, 22+len-2);
+
+                            //skip AudioSpecificConfig auidodata
+                            Atrack->mCurTagPos += 4 + SIZE_OF_TAG_HEAD + len;
+                        }
+                        // TODO: else.
+
+                        delete[] esds;
+                    }
+                    break;
+                case FLV_CODECID_NELLYMOSER_8HZ_MONO:
+                case FLV_CODECID_NELLYMOSER:
+                case FLV_CODECID_PCM_BE:
+                case FLV_CODECID_ADPCM:
+                case FLV_CODECID_PCM_LE:
+                default:
+                    const char *mime = "application/octet-stream";
+                    Atrack->mMeta->setCString(kKeyMIMEType, mime);
+                    break;
+                }
+
+                //--sample rate.(Hz).bit[3:2].
+                if( audio_codec != FLV_CODECID_NELLYMOSER_8HZ_MONO)
+                {
+                    switch( flags & FLV_AUDIO_RATE_MASK )
+                    {
+                        case FLV_AUDIO_RATE_5500:
+                            Atrack->mMeta->setInt32(kKeySampleRate, 5500);
+                            break;
+                        case FLV_AUDIO_RATE_11000:
+                            Atrack->mMeta->setInt32(kKeySampleRate, 11025);
+                            break;
+                        case FLV_AUDIO_RATE_22000:
+                            Atrack->mMeta->setInt32(kKeySampleRate, 22050);
+                            break;
+                        case FLV_AUDIO_RATE_44000:
+                            Atrack->mMeta->setInt32(kKeySampleRate, 44100);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+
+                //--sample size(8/16 bits/sample),bit[1]
+                if( flags & FLV_AUDIO_SIZE_MASK )
+                {
+                   //bitspersample = 16;
+                }
+                else
+                {
+                    //bitspersample = 8;
+                }
+
+                //--sample channnel(mono/stereo),bit[0]
+                if( flags & FLV_AUDIO_CHANNEL_MASK )
+                {
+                    Atrack->mMeta->setInt32(kKeyChannelCount, 2);
+                }
+                else
+                {
+                    Atrack->mMeta->setInt32(kKeyChannelCount, 1);
+                }
+
+                break;
+            } else {
+                offset += 4 + SIZE_OF_TAG_HEAD + len;
+                continue;
+            }
+        }
+    }
+
+    return OK;
+}
+
+ssize_t FLVExtractor::flv_read_metabody(off_t offset)
+{
+    uint8_t buffer[11]; //only needs to hold the string "onMetaData". Anything longer is something we don't want.
+
+    //first object needs to be "onMetaData" string
+    if(mDataSource->readAt(offset, buffer, 4) <1)
+        return ERROR_IO;
+
+    CHECK (buffer[0] == AMF_DATA_TYPE_STRING );
+    if (amf_get_string(offset+1, buffer, sizeof(buffer)) <= 11) {
+	   return ERROR_MALFORMED;
+    }
+    CHECK (!strcmp((const char *)buffer, "onMetaData"));
+
+    offset += (1+12);
+    //parse the second object (we want a mixed array)
+    //ALOGE("flv_read_metabody, offset:%d", offset);
+    return amf_parse_object((const char *)buffer, offset, 0);
+}
+
+ssize_t FLVExtractor::amf_get_string(uint32_t offset, uint8_t *buffer, int32_t buffsize)
+{
+   int length;
+   mDataSource->readAt(offset, buffer, 2);
+   length =U16_AT(buffer);
+   //ALOGE("amf_get_string keylen:%d", length);
+    if (length >= buffsize) {
+        return -1;
+    }
+
+    mDataSource->readAt(offset+2, buffer, length);
+    buffer[length] = '\0';
+    //ALOGE("amf_get_string %s", buffer);
+    return length+2;
+}
+
+status_t FLVExtractor::alloc_keyframe_entry(uint32_t array_num) {
+    if(mKeyFrameEntries == NULL) {
+        mKeyFrameNum = array_num;
+        mKeyFrameEntries = new TKeyFrameEntry[mKeyFrameNum];
+        if(mKeyFrameEntries == NULL) {
+            return ERROR_MALFORMED;
+        }
+    } else if(mKeyFrameNum != array_num) {
+        ALOGE("the two arrays have not the same number of elements!!");
+        return ERROR_MALFORMED;
+    }
+    return OK;
+}
+
+static double av_int2dbl(int64_t v)
+{
+    //if(v+v > 0xFFEULL<<52)
+//      return 0.0/0.0;
+//      return ldexp( (double)(  ( (v&((1LL<<52)-1))  +  (1LL<<52)  )  *  (v>>63|1)  ),(int)((v>>52&0x7FF)-1075) );
+
+    off64_t tmp;
+    off64_t k_tmp;
+    double x;
+    int exp_p;
+    int i =0;
+
+    //--(fract<<52).
+    k_tmp = 1;
+    k_tmp = (k_tmp<<52) -1;
+    tmp = v & k_tmp;
+
+    //--add signal and 1.fract.
+    k_tmp = 1;
+    k_tmp = (k_tmp<<52);
+    tmp += k_tmp;	//(1+fract)<<52.
+    k_tmp = (v>>63) | 1 ; //-- x*(-1)^signal.
+    tmp = tmp * k_tmp;
+
+    //--exponent.
+    exp_p = (int)( (v>>52&0x7FF) - 52 - 1023 );
+    if(exp_p>=0)
+    {
+        tmp = ( tmp << exp_p);
+    }
+    else
+    {
+        exp_p = -exp_p;
+
+        //tmp = (tmp >> exp_p);
+        for(i=0;i < exp_p;i++)
+        {
+            tmp = tmp>>1;
+        }
+    }
+
+    x= (double)tmp;
+    return x;
+}
+
+double FLVExtractor::amf_get_doublenum(uint32_t offset) {
+    uint8_t buffer[8];
+    mDataSource->readAt(offset, buffer, 1);
+    if(buffer[0]!=0) {
+        ALOGE("amf_get_doublenum not double num");
+        return 0;
+    }
+    mDataSource->readAt(offset+1, buffer, 8);
+    return av_int2dbl(U64_AT(buffer));
+}
+
+ssize_t FLVExtractor::amf_parse_object(const char *key, uint32_t offset, int depth)
+{
+    AMFDataType amf_type;
+    uint8_t str_val[256], tmp[8];
+    double num_val = 0;
+    uint32_t len = 0;
+    uint32_t array_num;
+
+    if(mDataSource->readAt(offset, tmp, 4)<1)
+        return ERROR_IO;
+
+    //ALOGE("amf_parse_object,offset:%d, tmp:%x, %x, %x, %x", offset, tmp[0],tmp[1],tmp[2],tmp[3]);
+    amf_type = (AMFDataType)tmp[0];
+
+    offset += 1;
+    //ALOGE("amf_parse_object, amf-type:0x%x", amf_type);
+    switch(amf_type) {
+        case AMF_DATA_TYPE_NUMBER:
+            mDataSource->readAt(offset, tmp, 8);
+            //ALOGE("amf_parse_object,tmp:%x, %x, %x, %x,%x, %x, %x, %x", tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5],tmp[6],tmp[7]);
+            offset += 8;
+            num_val = av_int2dbl(U64_AT(tmp));
+            //ALOGE("AMF_DATA_TYPE_NUMBER, %4llf", num_val);
+            break;
+        case AMF_DATA_TYPE_BOOL:
+            mDataSource->readAt(offset, &num_val, 1);
+            offset+=1;
+            break;
+        case AMF_DATA_TYPE_STRING:
+	    {
+		int i = amf_get_string(offset, str_val, sizeof(str_val));
+		if(i < 0)
+			return -1;
+		len = i;
+                offset += len;
+	    }
+            break;
+        case AMF_DATA_TYPE_OBJECT:
+        /*        while((uint32_t)stream_Tell(p_stream) < max_pos - 2 && amf_get_string(str_val, sizeof(str_val)) > 0) {
+                    if(amf_parse_object(str_val, max_pos, depth + 1) < 0)
+                        return -1; //if we couldn't skip, bomb out.
+                }
+                if(get_byte(p_stream) != AMF_END_OF_OBJECT)
+                    return -1;
+        */
+
+        if(key && depth ==1) {
+            if(!strcmp(key,"keyframes")) {
+                len = amf_get_string(offset, str_val, sizeof(str_val));//"times"
+                offset += len;
+                offset = amf_parse_object((const char*)str_val, offset, depth + 1);
+                len = amf_get_string(offset, str_val, sizeof(str_val));//"filepositions"
+                offset += len;
+                offset = amf_parse_object((const char*)str_val, offset, depth + 1);
+            }
+        }
+
+        mDataSource->readAt(offset, &str_val, 3);
+        offset +=3;
+        if((str_val[0]|str_val[1]|str_val[2] )!= AMF_END_OF_OBJECT)
+            return -1;
+
+        return offset;
+
+        break;
+    case AMF_DATA_TYPE_NULL:
+    case AMF_DATA_TYPE_UNDEFINED:
+    case AMF_DATA_TYPE_UNSUPPORTED:
+        break; //these take up no additional space
+    case AMF_DATA_TYPE_MIXEDARRAY:
+        mDataSource->readAt(offset, tmp, 4);
+        offset += 4;
+
+        array_num = U32_AT(tmp);
+        //ALOGE("AMF_DATA_TYPE_MIXEDARRAY, array_num:%d",array_num );
+
+        for(uint32_t i=0; i<array_num; i++) {
+            len = amf_get_string(offset, str_val, sizeof(str_val));
+            offset += len;
+            offset = amf_parse_object((const char*)str_val, offset, depth + 1);
+        }
+
+        mDataSource->readAt(offset, &str_val, 3);
+        offset +=3;
+        if((str_val[0]|str_val[1]|str_val[2] )!= AMF_END_OF_OBJECT)
+            return -1;
+
+        return offset;
+        break;
+    case AMF_DATA_TYPE_ARRAY:
+        mDataSource->readAt(offset, tmp, 4);
+        offset += 4;
+        array_num = U32_AT(tmp);
+        ALOGE("AMF_DATA_TYPE_ARRAY,array name:%s, array_num:%d",key,array_num );
+
+        if(depth == 2 && key) {
+            if(!strcmp(key,"times")) {
+                if(alloc_keyframe_entry(array_num) != OK) {
+                    break;
+                }
+                TKeyFrameEntry * temp = mKeyFrameEntries;
+                for(uint32_t i=0; i<array_num; i++) {
+                    num_val = amf_get_doublenum(offset);
+                    temp->timestamp = (uint32_t) num_val;
+                    //LOGD("times AMF_DATA_TYPE_ARRAY:%d num is %ld",i,temp->timestamp);
+                    offset += 9;
+                    temp += 1;
+                }
+            } else if(!strcmp(key,"filepositions")) {
+                if(alloc_keyframe_entry(array_num) != OK) {
+                    break;
+                }
+                TKeyFrameEntry * temp = mKeyFrameEntries;
+                for(uint32_t i=0; i<array_num; i++) {
+                    num_val = amf_get_doublenum(offset);
+                    //LOGD("filepositions AMF_DATA_TYPE_ARRAY:%d num is %4llf",i,num_val);
+                    temp->pos = (uint32_t)num_val;
+                    offset += 9;
+                    temp += 1;
+                }
+            }
+        }
+        return offset;
+        /*    unsigned int arraylen, i;
+
+            arraylen = get_be32(p_stream);//--length of the array.
+
+            if (depth == 2 && key)
+            {
+                uint32_t array_elem_size = 0;
+
+                //--arraylen of two tables must be equal.
+                if(!strcmp(key,"filepositions"))
+                {
+                    p_sys->haskeyframe = 1;
+                    p_sys->key_table_pos = stream_Tell(p_stream);
+                    p_sys->key_table_len = arraylen;
+                    array_elem_size = 9;//-9B per element.
+                }
+                else if(!strcmp(key,"times"))
+                {
+                    p_sys->key_table_tim = stream_Tell(p_stream);
+                    array_elem_size = 9;
+                }
+
+                if (array_elem_size > 0)
+                {
+                    mplayer_SetSeekable(SCI_TRUE);
+                }
+
+                if(array_elem_size > 0 )
+                {
+                    uint32_t cur_pos = stream_Tell(p_stream);
+                    uint32_t next_pos;
+
+                    next_pos = cur_pos + arraylen*array_elem_size;
+                    if(next_pos >= max_pos)
+                    {
+                        return -1;
+                    }
+                    else
+                    {
+                        FILE_SEEK(p_stream,next_pos,SEEK_SET);
+                        break;
+                    }
+                }
+            }
+
+            for(i = 0; i < arraylen && (uint32_t)stream_Tell(p_stream) < max_pos - 1; i++) {
+                if(amf_parse_object(NULL, max_pos, depth + 1) < 0)
+                    return -1; //if we couldn't skip, bomb out.
+            }*/
+            break;
+        case AMF_DATA_TYPE_DATE:
+            offset+=(8+2);
+            break;
+        default: //unsupported type, we couldn't skip
+            return -1;
+    }
+
+    if (depth == 1 && key)
+    {
+        Track *vtrack=NULL, *atrack=NULL;
+        for( uint32_t i=0; i<mTracks.size(); i++) {
+            Track *track = &mTracks.editItemAt( i );
+            if( track->mKind == Track::VIDEO )
+                vtrack = track;
+            else if ( track->mKind == Track::AUDIO)
+                atrack = track;
+            else
+                ALOGE("parseTag error, track is invalid");
+        }
+
+        //ALOGE("amf_parse_object, key:%s", key);
+        //only look for metadata values when we are not nested and key != NULL
+        if(amf_type == AMF_DATA_TYPE_BOOL) {
+            if(!strcmp(key,"hasAudio"))
+            {
+            }
+            else if(!strcmp(key, "stereo"))
+            {
+                if(atrack ) atrack->mMeta->setInt32(kKeyChannelCount, 2);
+            }
+            else if(!strcmp(key,"hasVideo"))
+            {
+            }
+            else if(!strcmp(key,"hasKeyframes"))
+            {
+            }
+            else if(!strcmp(key,"canSeekToEnd"))
+            {
+            }
+        } else if(amf_type== AMF_DATA_TYPE_NUMBER) {
+            if(!strcmp(key, "duration"))
+            {
+                ALOGE("amf_parse_object, duration:%.2fs", num_val);
+                if(vtrack) {
+                    vtrack->mMeta->setInt64(kKeyDuration, (num_val)*FLV_MOVIE_TIMESCALE);
+                    vtrack->mMeta->setInt32(kKeyMaxInputSize, vtrack->mMaxTagSize);
+                }
+
+                if(atrack) {
+                    atrack->mMeta->setInt64(kKeyDuration, (num_val)*FLV_MOVIE_TIMESCALE);
+                    atrack->mMeta->setInt32(kKeyMaxInputSize, atrack->mMaxTagSize);
+                }
+            }
+            else if(!strcmp(key, "videocodecid"))
+            {
+            }
+            else if(!strcmp(key, "width") && num_val > 0)
+            {
+               ALOGE("amf_parse_object, width:%4f", num_val);
+               if(vtrack )
+                   vtrack->mMeta->setInt32(kKeyWidth, num_val);
+            }
+            else if(!strcmp(key, "height") && num_val > 0)
+            {
+                ALOGE("amf_parse_object, height:%4f", num_val);
+                if(vtrack ) vtrack->mMeta->setInt32(kKeyHeight, num_val);
+            }
+            else if(!strcmp(key,"lastkeyframetimestamp"))
+            {
+            }
+            else if(!strcmp(key,"framerate")&& num_val > 0)
+            {
+            }
+            else if(!strcmp(key, "audiocodecid"))
+            {
+                //flv_set_audio_codec((int)num_val << FLV_AUDIO_CODECID_OFFSET);
+            }
+            else if(!strcmp(key,"audiosamplerate")&& num_val > 0)
+            {
+                ALOGE("amf_parse_object, audiosamplerate:%4f", num_val);
+               if(atrack) atrack->mMeta->setInt32(kKeySampleRate, num_val);
+            }
+            else if(!strcmp(key,"audiosamplesize")&& num_val >= 0)
+            {
+            }
+        }//--end of "else if(amf_type == AMF_DATA_TYPE_NUMBER)"
+    }
+
+    return offset;
+}
+
+status_t FLVExtractor::getTagInfo(
+        size_t trackIndex, size_t tagIndex,
+        off64_t *offset, size_t *size, bool *isKey,
+        int64_t *tagTimeUs) {
+    if (trackIndex >= mTracks.size()) {
+        ALOGE("trackId:%zd, size:%zu", trackIndex, mTracks.size());
+        return -ERANGE;
+    }
+    uint32_t tagType;
+    Track *track = &mTracks.editItemAt(trackIndex);
+    //ALOGE("getTagInfo trackID:%d, tagId:%d, tagNum:%d",trackIndex, tagIndex, track->mTags.size());
+    while(tagIndex >= track->mTags.size()) {
+            uint8_t tmp[4+SIZE_OF_TAG_HEAD+1];
+            ssize_t n = mDataSource->readAt(track->mCurTagPos, tmp, 4+SIZE_OF_TAG_HEAD+1);
+            //ALOGE("getTagInfo pos:%x, tmp:%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x", track->mCurTagPos,
+            //    tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[12],tmp[13],tmp[14],tmp[15]);
+            if (n < (4+SIZE_OF_TAG_HEAD+1)) {
+                return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+            }
+
+            tagType = tmp[4]&0x1F;
+            uint32_t tagSize = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+            if( ((FLV_TAG_TYPE_AUDIO== tagType)&&(track->mKind != Track::AUDIO)) || ((FLV_TAG_TYPE_VIDEO== tagType)&&(track->mKind != Track::VIDEO)) ) {
+                track->mCurTagPos += (tagSize + 4 + SIZE_OF_TAG_HEAD);
+                continue;
+            }
+            //new tag
+            track->mTags.push();
+            TagInfo *info = &track->mTags.editItemAt(track->mTags.size() - 1);
+            info->mOffset = track->mCurTagPos;
+            info->mIsKey = true;//don't know.
+
+            //ALOGE("getTagInfo push pos:%x, info:%x ", track->mCurTagPos, info->mOffset);
+
+            track->mCurTagPos += (tagSize + 4+SIZE_OF_TAG_HEAD);
+
+            if(tagIndex == 0)
+            {
+                track->mFirstTagSize = tagSize;
+                track->mAvgTagSize = tagSize; //don't care it
+            }
+    //TODO: actually don't need to execute the following data, should return now?
+    }
+
+    const TagInfo &info = track->mTags.itemAt(tagIndex);
+    *offset = info.mOffset;
+
+    *size = 0;
+
+    uint8_t tmp[4+SIZE_OF_TAG_HEAD+1];
+    ssize_t n = mDataSource->readAt(info.mOffset, tmp, 4+SIZE_OF_TAG_HEAD+1);
+
+    //ALOGE("getTagInfo pos:%x, tmp:%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x", info.mOffset,
+    //    tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],tmp[10],tmp[11],tmp[12],tmp[13],tmp[14],tmp[15]);
+
+    if (n < (4+SIZE_OF_TAG_HEAD+1) ) {
+        return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
+    }
+
+    *offset = info.mOffset+4+SIZE_OF_TAG_HEAD+1;
+    *size = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+    *size -= 1;
+    *isKey = info.mIsKey;
+    //*tagTimeUs = ( (tmp[8] << 16) | (tmp[9] << 8) | (tmp[10]) )*1000;
+    int64_t tagTimeMs = ( (tmp[8] << 16) | (tmp[9] << 8) | (tmp[10]) );
+    *tagTimeUs = tagTimeMs*1000;
+    //ALOGE("getTagInfo timeUs:%4lld", *tagTimeUs);
+
+    return OK;
+}
+
+status_t FLVExtractor::getTagInfoWithOffset(
+    size_t trackIndex,off64_t inoffset,
+    off64_t *outoffset, size_t *size, bool *isKey,
+    int64_t *tagTimeUs) {
+
+    if (trackIndex >= mTracks.size()) {
+        ALOGE("trackId:%zu, size:%zd", trackIndex, mTracks.size());
+        return -ERANGE;
+    }
+
+    uint32_t tagType;
+    off64_t tagpos;
+    Track *track = &mTracks.editItemAt(trackIndex);
+    tagpos = inoffset;
+
+    while(1) {
+        uint8_t tmp[4+SIZE_OF_TAG_HEAD+1];
+        ssize_t n = mDataSource->readAt(tagpos, tmp, 4+SIZE_OF_TAG_HEAD+1);
+        //LOGE("getTagInfo2:  %x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,",tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5],tmp[6],tmp[7],tmp[8],tmp[9],
+        //tmp[10],tmp[11]);
+        if (n < (4+SIZE_OF_TAG_HEAD+1)) {
+            return (n < 0) ? n : (ssize_t)ERROR_MALFORMED;
+        }
+
+        tagType = tmp[4]&0x1F;
+        uint32_t tagSize = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+
+        if( ((FLV_TAG_TYPE_AUDIO== tagType)&&(track->mKind != Track::AUDIO))
+                || ((FLV_TAG_TYPE_VIDEO== tagType)&&(track->mKind != Track::VIDEO)) ) {
+            tagpos += (tagSize + 4 + SIZE_OF_TAG_HEAD);
+            continue;
+        } else if(tagType != FLV_TAG_TYPE_AUDIO && tagType != FLV_TAG_TYPE_VIDEO) {
+            ALOGE("The tag type is error,tagType is %d",tagType);
+            return ERROR_MALFORMED;
+        }
+
+        break;
+    }
+
+    uint8_t tmp[4+SIZE_OF_TAG_HEAD+1];
+    mDataSource->readAt(tagpos, tmp, 4+SIZE_OF_TAG_HEAD+1);
+
+
+    *outoffset = tagpos+4+SIZE_OF_TAG_HEAD+1;
+    *size = (tmp[5] << 16) | (tmp[6] << 8) | (tmp[7]);
+    *size -= 1;
+    *isKey = 0;
+    //*tagTimeUs = ( (tmp[8] << 16) | (tmp[9] << 8) | (tmp[10]) )*1000;
+    int64_t tagTimeMs = ( (tmp[8] << 16) | (tmp[9] << 8) | (tmp[10]) );
+    *tagTimeUs = tagTimeMs*1000;
+    //LOGE("inoffset is %lld,outoffset is %lld,size is %ld,%lld",inoffset,*outoffset,*size,*tagTimeUs);
+    //set offset to next tag
+    track->mCurTagPos = *outoffset+*size;
+    return OK;
+}
+
+status_t FLVExtractor::getKeyFramePosition(size_t trackIndex,int64_t seekTimeUs,size_t maxTagSize) {
+    off64_t offset;
+    off64_t inoffset;
+    size_t size;
+    bool isKey;
+    int64_t timeUs;
+    int64_t seekTimeS;
+    ALOGE("the %zu track seek time is %lld",trackIndex,(long long)seekTimeUs);
+    if (trackIndex >= mTracks.size()) {
+        ALOGE("trackId:%zu, size:%zu", trackIndex, mTracks.size());
+        return -ERANGE;
+    }
+    if(mKeyFrameEntries != NULL) {
+
+        Track *track = &mTracks.editItemAt(trackIndex);
+        seekTimeS = seekTimeUs/1000000ll;
+        int i = 0;
+        if(OK != getKeyFrameEntriesIndex(seekTimeUs,&i)) {
+            return ERROR_MALFORMED;
+        }
+        inoffset = mKeyFrameEntries[i].pos-4;
+        status_t err = getTagInfoWithOffset(trackIndex,inoffset,&offset, &size, &isKey, &timeUs);
+        if(err == OK && size <= maxTagSize) {
+            //LOGD("get a audio or video track");
+            track->mCurTagPos = offset-4-SIZE_OF_TAG_HEAD-1;
+            return OK;
+        }
+
+    }
+    return ERROR_MALFORMED;
+}
+
+status_t FLVExtractor::getKeyFrameEntriesIndex(int64_t seekTimeUs,int32_t *index) {
+    if(mKeyFrameEntries != NULL) {
+        int64_t seekTimeS;
+        off64_t inoffset = 0;
+        seekTimeS = seekTimeUs/1000000ll;
+        int i,start = 0,end = 0;
+        end = mKeyFrameNum-1;
+        i = (end-start)/2+start;
+        while( start<i && i<end ) {
+            inoffset = mKeyFrameEntries[i].pos-4;
+            if(inoffset <= 0) {
+                ALOGE("the keyframe fileposition is abnormal!");
+                return ERROR_MALFORMED;
+            }
+            if(mKeyFrameEntries[i].timestamp < seekTimeS) {
+                start = i;
+            } else if(mKeyFrameEntries[i].timestamp > seekTimeS) {
+                end = i;
+            } else {
+                break;
+            }
+            i = (end - start)/2+start;
+        }
+        *index = i;
+        ALOGE("the key frame index is %d ,the pos is %lld,the time is %d",
+              i, (long long)inoffset, mKeyFrameEntries[i].timestamp);
+        return OK;
+
+    }
+
+    return ERROR_MALFORMED;
+}
+
+bool SniffFLV(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+        sp<AMessage> *) {
+    char tmp[4];
+    if (source->readAt(0, tmp, 4) < 4) {
+        return false;
+    }
+
+    if ( !memcmp(tmp, "FLV", 3)) {
+         ALOGE("detect FLV files!!!!");
+        mimeType->setTo(MEDIA_MIMETYPE_CONTAINER_FLV);
+
+        // Just a tad over the mp3 extractor's confidence, since
+        // these FLV files may contain mp3 content that otherwise would
+        // mistakenly lead to us identifying the entire file as a .mp3 file.
+        *confidence = 0.31;
+
+        return true;
+    }
+
+    return false;
+}
+
+}
+
diff --git a/media/libstagefright/FileCache.cpp b/media/libstagefright/FileCache.cpp
new file mode 100644
index 0000000..25efb02
--- /dev/null
+++ b/media/libstagefright/FileCache.cpp
@@ -0,0 +1,562 @@
+
+#define LOG_TAG "FileCache"
+#define LOG_DEBUG 0
+
+#include <media/stagefright/FileCache.h>
+
+#if LOG_DEBUG>=1
+#define ALOGD(...)  printf("FileCache: " __VA_ARGS__), printf("  \n")
+#define ALOGE(...) ALOGD(__VA_ARGS__)
+#endif
+
+
+namespace android {
+
+
+
+RingBuffer::RingBuffer(size_t size):buf_addr(NULL),rd_index(0),
+wr_index(0),getbuf_wakeup(0),getdata_wakeup(0),no_more_data(0),datacopy_wakeup(false)
+{
+    mSize=size;
+}
+
+RingBuffer::~RingBuffer()
+{
+    if(buf_addr){
+        free(buf_addr);
+        buf_addr = NULL;
+    }
+}
+
+int32_t   RingBuffer:: init()
+{
+#if 0
+    if(mSize < 0) {
+        ALOGD("Error size:%d",mSize);
+        return -1;
+    }
+#endif
+
+    buf_addr=(uint8_t *)malloc(mSize);
+    if(buf_addr != NULL) {
+        return 0;
+    }
+    else {
+        ALOGD("buffer Malloc ERROR");
+        return -1;
+    }
+}
+
+bool RingBuffer::isFull()
+{
+    return (dataCount() >= mSize);
+}
+
+bool  RingBuffer::isEmpty()
+{
+    return (wr_index == rd_index );
+}
+
+void  RingBuffer::reset()
+{
+    mLock_wr.lock();
+    mLock_rd.lock();
+    wr_index = 0;
+    rd_index = 0;
+    mLock_rd.unlock();
+    mLock_wr.unlock();
+}
+
+
+size_t RingBuffer::dataCount()
+{
+    return (wr_index - rd_index);
+}
+
+int  RingBuffer::getBuf( Buffer * buf, uint32_t wait)
+{
+    uint32_t wr = 0;
+    mLock_wr.lock();
+
+    mBufLock.lock();
+    if(isFull()) {
+        if(wait) {
+            if(!getbuf_wakeup) {
+                //ALOGD("getBuf Wait. isFull:%d,wr_index:%zd,rd_index:%zd,this %p",isFull(),wr_index,rd_index,this);
+                mBufCond.wait(mBufLock);
+                //ALOGD("getBuf After wait. isFull:%d,wr_index:%zd,rd_index:%zd this %p",isFull(),wr_index,rd_index,this);
+            }
+            if(isFull() || getbuf_wakeup) {
+                getbuf_wakeup = 0;
+                mBufLock.unlock();
+                mLock_wr.unlock();
+                return -1;
+            }
+        }
+        else {
+            buf->mData = NULL;
+            buf->mSize = 0;
+            getbuf_wakeup = 0;
+            mBufLock.unlock();
+            mLock_wr.unlock();
+            return -1;
+        }
+    }
+
+    if(getbuf_wakeup){
+        getbuf_wakeup = 0;
+        mBufLock.unlock();
+        mLock_wr.unlock();
+        return -1;
+    }
+
+    //wr = wr_index & (mSize - 1);
+    wr = wr_index % mSize;
+    buf->mData= buf_addr + wr;
+    if ((mSize - wr) > (mSize - dataCount()))
+        buf->mSize = mSize - dataCount();
+    else
+        buf->mSize = mSize - wr;
+
+    mBufLock.unlock();
+    return 0;
+
+}
+
+
+void  RingBuffer::putData(Buffer *buf,int wake)
+{
+    mDataLock.lock();
+    if(isFull()){
+        // to do error
+    }
+    wr_index += buf->mSize;
+    if(wake){
+        mDataCond.signal();
+        //ALOGD("putData wr signal,wr_index:%zd,rd_index:%zd,this %p",wr_index,rd_index,this);
+    }
+    mDataLock.unlock();
+    mLock_wr.unlock();
+    return ;
+}
+
+int  RingBuffer::getData(Buffer * buf ,uint32_t wait)
+{
+    uint32_t rd = 0;
+    mLock_rd.lock();
+    mDataLock.lock();
+    if(isEmpty()){
+        if(wait ){
+            if(!getdata_wakeup) {
+                if(no_more_data) {
+                    getdata_wakeup = 0;
+                    buf->mSize = 0;
+                    mDataLock.unlock();
+                    mLock_rd.unlock();
+                    return -1;
+                }
+              //  ALOGD("getData Wait. isEmpty:%d,wr_index:%zd,rd_index:%zd,this %p",isEmpty(),wr_index,rd_index,this);
+                mDataCond.wait(mDataLock);
+             //   ALOGD("getData After wait. isEmpty:%d,wr_index:%zd,rd_index:%zd, this %p",isEmpty(),wr_index,rd_index,this);
+            }
+            if(isEmpty() || getdata_wakeup){
+                getdata_wakeup = 0;
+                buf->mSize = 0;
+                mDataLock.unlock();
+                mLock_rd.unlock();
+                return -1;
+            }
+        }
+        else{
+            getdata_wakeup = 0;
+            buf->mSize = 0;
+            mDataLock.unlock();
+            mLock_rd.unlock();
+            return -1;
+        }
+    }
+
+    if(getdata_wakeup) {
+        getdata_wakeup = 0;
+        buf->mSize = 0;
+        mDataLock.unlock();
+        mLock_rd.unlock();
+        return -1;
+    }
+
+    //rd = rd_index & (mSize - 1);
+    rd = rd_index % mSize;
+    buf->mData = buf_addr + rd;
+    if ((mSize - rd) > dataCount())
+        buf->mSize = dataCount();
+    else
+        buf->mSize = mSize - rd;
+
+    mDataLock.unlock();
+    return 0;
+}
+
+
+
+void  RingBuffer::putBuf(Buffer *buf, int wake)
+{
+    mBufLock.lock();
+    if(isFull()){
+        // to do error
+    }
+    rd_index += buf->mSize;
+    if(wake){
+        mBufCond.signal();
+    }
+    mBufLock.unlock();
+    mLock_rd.unlock();
+    return ;
+}
+
+int  RingBuffer::dataCopy(uint32_t offset, Buffer *buf, int wait)
+{
+    uint32_t rd = 0;
+    size_t read_size = buf->mSize;
+    size_t avail = 0;
+    size_t tail_avail = 0;
+    uint8_t *cur_buf = (uint8_t *)buf->mData;
+    mLock_rd.lock();
+    mDataLock.lock();
+    if(wait) {
+        while(dataCount()<= offset && (!datacopy_wakeup)) {
+            if(no_more_data) {
+                datacopy_wakeup = 0;
+                buf->mSize = 0;
+                mDataLock.unlock();
+                mLock_rd.unlock();
+                return -1;
+            }
+         //   ALOGD("dataCopy. Need more data. Wait data count:%zd,offset:%d,flag:%d,size:%zd",dataCount(),offset,datacopy_wakeup,read_size);
+            mDataCond.wait(mDataLock);
+        //    ALOGD("dataCopy. After wait count:%zd,offset:%d,flag:%d",dataCount(),offset,datacopy_wakeup);
+        }
+    }
+    else {
+        if(offset >= dataCount()){
+            datacopy_wakeup = 0;
+            buf->mSize = 0;
+            mDataLock.unlock();
+            mLock_rd.unlock();
+            return -1;
+        }
+    }
+    if(datacopy_wakeup) {
+        datacopy_wakeup = 0;
+        buf->mSize = 0;
+        mDataLock.unlock();
+        mLock_rd.unlock();
+        return -1;
+    }
+
+    rd = rd_index % mSize;
+    avail = dataCount();
+    mDataLock.unlock();
+    tail_avail = mSize - rd;
+    read_size = read_size > (avail - offset)? (avail - offset) : read_size;
+    if(offset <= tail_avail) {
+        if((tail_avail - offset) >= read_size) {
+            memcpy(cur_buf, buf_addr + rd + offset, read_size);
+        }
+        else {
+            memcpy(cur_buf, buf_addr + rd + offset, tail_avail - offset);
+            memcpy(cur_buf + (tail_avail - offset),buf_addr, read_size - (tail_avail - offset));
+        }
+    }
+    else {
+        memcpy(cur_buf, buf_addr + (offset - tail_avail), read_size);
+    }
+    buf->mSize = read_size;
+    mLock_rd.unlock();
+    return 0;
+
+}
+
+size_t  RingBuffer::dataRelease(size_t size)
+{
+    Buffer buf;
+    int ret = 0;
+    size_t size_to_release = size;
+    size_t cur_size = 0;
+    while(size) {
+        ret = getData(&buf,true);
+        if(!ret) {
+            cur_size = buf.mSize > size ? size:buf.mSize;
+            buf.mSize = cur_size;
+            putBuf(&buf, true);
+            size -= cur_size;
+        }
+        else {
+            break;
+        }
+    }
+
+    return (size_to_release - size);
+}
+
+void  RingBuffer::wakeUpForGetBuf()
+{
+    Mutex::Autolock l(mBufLock);
+    getbuf_wakeup = 1;
+    mBufCond.signal();
+}
+void  RingBuffer::wakeUpForDataCopy()
+{
+    Mutex::Autolock l (mDataLock);
+    datacopy_wakeup = 1;
+    mDataCond.signal();
+    ALOGD("wakeUpForDataCopy wr signal");
+}
+
+void  RingBuffer::wakeUpForGetData()
+{
+    Mutex::Autolock l (mDataLock);
+    getdata_wakeup = 1;
+    mDataCond.signal();
+    ALOGD("wakeUpForGetData wr signal");
+}
+
+void  RingBuffer::wakeUpAndSetNoMoreData()
+{
+    Mutex::Autolock l (mDataLock);
+    no_more_data = 1;
+    mDataCond.signal();
+    ALOGD("wakeUpAndSetNomoreData wr signal");
+}
+
+void  RingBuffer::cleanNoMoreData()
+{
+    Mutex::Autolock l (mDataLock);
+    no_more_data = 0;
+    ALOGD("cleanNomoreData ");
+}
+
+
+
+
+FileCache::FileCache(int Fd , int64_t length, size_t cacheSize, size_t maxPerRead, size_t preCacheSize):
+mFd(Fd), mOffset(0), mLength(length), mCacheSize(cacheSize), mPreCacheSize(preCacheSize), errorCount(0), mThreadLoop_wakeup(false), mMaxPerRead(maxPerRead)
+{
+    mCommand = READ;
+    mState = OK;
+    mcount++;
+    count = mcount;
+}
+
+FileCache::~FileCache()
+{
+    if(mRingBuffer) {
+        delete mRingBuffer;
+        mRingBuffer = NULL;
+    }
+}
+
+
+
+
+int32_t   FileCache:: init()
+{
+    if(mFd < 0) {
+        return -1;
+    }
+    if((long long)mCacheSize > (long long)mLength) {
+        mCacheSize = mLength;
+    }
+    if(mMaxPerRead  >  mCacheSize/2) {
+        return -1;
+    }
+    if(mPreCacheSize  >  mCacheSize/2) {
+        return -1;
+    }
+
+    mRingBuffer = new RingBuffer(mCacheSize);
+    ALOGE(" mRingBuffer %p",mRingBuffer);
+    if(mRingBuffer != NULL) {
+        int32_t status = mRingBuffer->init();
+        if(!status) {
+            const size_t SIZE = 256;
+            char buffer[SIZE];
+            snprintf(buffer, SIZE, "mp3 FileCahce Thread %p", this);
+            run(buffer, PRIORITY_AUDIO);
+            seekTo(mOffset);
+            return 0;
+        }
+        else
+            return -1;
+    }
+    else {
+        ALOGD("init Malloc ERROR");
+        return -1;
+    }
+}
+
+ int  FileCache::mcount = 0;
+
+void  FileCache::wakeUpForThreadLoop()
+{
+    Mutex::Autolock l (mLock_thread);
+    mThreadLoop_wakeup = true;
+    mCond_thread.signal();
+}
+void FileCache::exit()
+{
+    requestExit();
+    wakeUpForThreadLoop();
+    mRingBuffer->wakeUpForGetBuf();
+    mRingBuffer->wakeUpForDataCopy();
+    mRingBuffer->wakeUpForGetData();
+    requestExitAndWait();
+}
+
+
+void FileCache:: seekTo(off64_t offset)
+{
+    mLock.lock();
+    mOffset = offset;
+    //ALOGD("SEEK offset:%lld,mOffset:%lld, %d",(long long)offset,(long long)mOffset, count);
+    mCommand = SEEK;
+    mRingBuffer->cleanNoMoreData();
+    wakeUpForThreadLoop();
+    mRingBuffer->wakeUpForGetBuf();
+    ALOGD("seekTo Wait count %d",count);
+    mWaitCond.wait(mLock);
+    ALOGD("seekTo After Wait %d",count);
+    mLock.unlock();
+}
+
+ssize_t FileCache::readAt(off64_t offset, void *data, size_t size)
+{
+    RingBuffer::Buffer  buf;
+    size_t readSize;
+    int ret = 0;
+    size_t size_release = 0;
+    if (mLength >= 0) {
+        if (offset >= mLength) {
+            return 0;  // read beyond EOF.
+        }
+        int64_t numAvailable = mLength - offset;
+        if ((int64_t)size > numAvailable) {
+            size = numAvailable;
+        }
+    }
+    readSize = size;
+    if((long long)offset >= (long long)mOffset&&offset<(long long)(mOffset+mCacheSize)) {
+        buf.mData = data;
+        while(readSize >0 ) {
+            buf.mSize = readSize > mCacheSize? mCacheSize: readSize;
+            if((long long)(offset - mOffset) >= (long long)(mMaxPerRead+mPreCacheSize)) {
+                size_release = mRingBuffer->dataRelease(mMaxPerRead);
+                mOffset += size_release;
+            }
+            ret = mRingBuffer->dataCopy(offset - mOffset,&buf,true);
+            if(ret < 0) {
+               // ALOGD("readAt offset:%lld,mOffset:%lld,count %d",(long long)offset,(long long)mOffset,count);
+                return (size - readSize);
+            }
+            buf.mData = (uint8_t *)buf.mData + buf.mSize;
+            readSize -= buf.mSize;
+            offset += buf.mSize;
+        }
+        return size;
+    }
+    else {
+        if((long long)offset>(long long)mPreCacheSize) {
+            seekTo(offset-mPreCacheSize);
+        }
+        else {
+            seekTo(0);
+        }
+        if(mState == OK) {
+            return readAt(offset, data, size);
+        }
+        else {
+            return SEEK_ERROR;
+        }
+    }
+return 0;
+}
+void FileCache:: commandProcess()
+{
+    mLock.lock();
+    switch(mCommand) {
+        case NOP:
+            break;
+        case SEEK:
+            off64_t result = lseek64(mFd, mOffset, SEEK_SET);
+            if (result == -1) {
+                ALOGD("seek to %lld failed",  (long long)mOffset);
+                mState = SEEK_ERROR;
+            }
+            else {
+                mState = OK;
+            }
+            mRingBuffer->reset();
+            errorCount = 0;
+            mCommand = NOP;
+            mWaitCond.signal();
+            break;
+    }
+    mLock.unlock();
+}
+
+bool FileCache:: threadLoop()
+{
+    sp <FileCache> strongMe = this;
+    //uint8_t * trackBuf = NULL;
+    int ret = 0;
+    size_t preread_size = 0;
+    RingBuffer::Buffer buffer;
+
+    ALOGD("threadLoop start %d",count);
+    while (!exitPending()) {
+        commandProcess();
+        ret = mRingBuffer->getBuf(&buffer,true);
+        if(0==ret) {
+            preread_size = buffer.mSize > mMaxPerRead ? mMaxPerRead: buffer.mSize;
+            buffer.mSize = ::read(mFd, buffer.mData, preread_size);
+            if(buffer.mSize <= preread_size /*&& buffer.mSize >= 0*/) {
+                mRingBuffer->putData(&buffer,true);
+                errorCount = 0;
+                if(buffer.mSize < preread_size) {
+                    mLock_thread.lock();
+                    if(mThreadLoop_wakeup) {
+                        mThreadLoop_wakeup = false;
+                    }
+                    else {
+                        //ALOGD("threadLoop read EOS! Real read Size:%zd. And wait,%d",buffer.mSize,count);
+                        mRingBuffer->wakeUpAndSetNoMoreData();
+                        mCond_thread.wait(mLock_thread);
+                        mRingBuffer->cleanNoMoreData();
+                        ALOGD("threadLoop read EOS! After Wait, %d", count);
+                    }
+                    mLock_thread.unlock();
+                }
+            }
+            else {
+                errorCount++;
+                if(errorCount>=10) {
+                   // ALOGD("threadLoop read data ERROR size:%zd, count %d",buffer.mSize,count);
+                    buffer.mSize = preread_size;
+                    mRingBuffer->putData(&buffer,true);
+                }
+                else {
+                  //  ALOGD("threadLoop read data ERROR 0 size:%zd, %d",buffer.mSize,count);
+                    buffer.mSize = 0;
+                    mRingBuffer->putData(&buffer,true);
+                }
+            }
+        }
+        else
+            ALOGD("threadLoop getBuf SEEK,count %d",count);
+    }
+    ALOGD("thread loop exit refcount is %d,count %d",this->getStrongCount(), count);
+    return false;
+}
+
+}
+
+
diff --git a/media/libstagefright/MP3Extractor.cpp b/media/libstagefright/MP3Extractor.cpp
index 82e7a26..c0dd6ad 100644
--- a/media/libstagefright/MP3Extractor.cpp
+++ b/media/libstagefright/MP3Extractor.cpp
@@ -214,7 +214,7 @@ public:
     MP3Source(
             const sp<MetaData> &meta, const sp<DataSource> &source,
             off64_t first_frame_pos, uint32_t fixed_header,
-            const sp<MP3Seeker> &seeker);
+            const sp<MP3Seeker> &seeker, bool Is_Vbr_S);
 
     virtual status_t start(MetaData *params = NULL);
     virtual status_t stop();
@@ -241,17 +241,86 @@ private:
 
     int64_t mBasisTimeUs;
     int64_t mSamplesRead;
+    bool mIsVbr_S;
 
     MP3Source(const MP3Source &);
     MP3Source &operator=(const MP3Source &);
 };
 
+#define BYTE_TO_CHECK 1024*30
+#define BYTE_CAL_AVGB BYTE_TO_CHECK*10
+bool MP3Extractor::TestVBR(const sp<DataSource> &source, int *avg_bitrate, uint32_t match_header,
+        off64_t inout_pos){
+
+    off64_t pos = inout_pos;
+    bool vbr_valid = false;
+    size_t kMaxBytesChecked = BYTE_TO_CHECK;
+    int total_bitrate = 0;
+    int total_count =0;
+    int prev_bitrate = -1;
+    uint8_t tmp[4];
+
+    if(!mMeta->findInt32(kKeyBitRate, &prev_bitrate))
+    {
+        prev_bitrate = -1;
+    }
+
+    do {
+        if (pos >=(off64_t)( inout_pos + kMaxBytesChecked)) {
+            // Don't scan forever.
+            //ALOGE("wangzuo:giving up at offset %lld", pos);
+            break;
+        }
+        if (source->readAt(pos, tmp, 4) < 4) {
+            ALOGE("wangzuo:end of the file");
+            break;
+        }
+
+        uint32_t header = U32_AT(tmp);
+        size_t frame_size;
+        int sample_rate, num_channels, bitrate;
+        if ((match_header != 0 && (header & kMask) != (match_header & kMask))||!GetMPEGAudioFrameSize(
+            header, &frame_size,&sample_rate, &num_channels, &bitrate)) {
+            ALOGE("wangzuo:to do resync");
+            if (!Resync(mDataSource, mFixedHeader, &pos, NULL, NULL)) {
+                ALOGE("wangzuo:Unable to resync. break");
+                break ;
+            }
+            continue;
+        }
+        //ALOGE("wangzuo0:AVG_Bitrate %d,count %d pos %lld",(*avg_bitrate),total_count,pos);
+        if (prev_bitrate == -1) {
+            prev_bitrate = bitrate;
+            total_bitrate += bitrate;
+            total_count ++;
+            //ALOGE("wangzuo1:AVG_Bitrate %d,count %d pos %lld frame_size %d",(*avg_bitrate),total_count,pos,frame_size);
+        } else {
+            if ((prev_bitrate != bitrate)&&!vbr_valid)
+            {
+                vbr_valid = true;
+                kMaxBytesChecked = BYTE_CAL_AVGB;
+            };
+            prev_bitrate = bitrate;
+            total_bitrate += bitrate;
+            total_count ++;
+            //ALOGE("wangzuo2:AVG_Bitrate %d,count %d pos %lld frame_size %d",(*avg_bitrate),total_count,pos,frame_size);
+        }
+        //ALOGE("wangzuo3:AVG_Bitrate %d,count %d pos %lld frame_size %d",(*avg_bitrate),total_count,pos,frame_size);
+        pos = pos + frame_size;
+        //ALOGE("wangzuo4:AVG_Bitrate %d,count %d pos %lld frame_size %d",(*avg_bitrate),total_count,pos,frame_size);
+    } while (1);
+    *avg_bitrate = (total_bitrate + (total_count >>1))/total_count;
+    //ALOGE("wangzuo:AVG_Bitrate %d,count %d vbr_valid %d",(*avg_bitrate),total_count,vbr_valid);
+    return vbr_valid;
+}
+
 MP3Extractor::MP3Extractor(
         const sp<DataSource> &source, const sp<AMessage> &meta)
     : mInitCheck(NO_INIT),
       mDataSource(source),
       mFirstFramePos(-1),
-      mFixedHeader(0) {
+      mFixedHeader(0),
+      mIsVbr(false){
 
     off64_t pos = 0;
     off64_t post_id3_pos;
@@ -348,7 +417,15 @@ MP3Extractor::MP3Extractor(
 
     int64_t durationUs;
 
-    if (mSeeker == NULL || !mSeeker->getDuration(&durationUs)) {
+    int64_t tempPos = 0;
+    int64_t tempTime = 0;
+    int32_t AVG_Bitrate = 0;
+    if (mSeeker == NULL || !mSeeker->getDuration(&durationUs) || !mSeeker->getOffsetForTime(&tempTime,&tempPos)) {
+        if (TestVBR(mDataSource,&AVG_Bitrate,mFixedHeader,mFirstFramePos)) {
+            bitrate = AVG_Bitrate;
+            mMeta->setInt32(kKeyBitRate, bitrate * 1000);
+            mIsVbr = true;
+        }
         off64_t fileSize;
         if (mDataSource->getSize(&fileSize) == OK) {
             off64_t dataLength = fileSize - mFirstFramePos;
@@ -414,7 +491,7 @@ sp<IMediaSource> MP3Extractor::getTrack(size_t index) {
 
     return new MP3Source(
             mMeta, mDataSource, mFirstFramePos, mFixedHeader,
-            mSeeker);
+            mSeeker, mIsVbr);
 }
 
 sp<MetaData> MP3Extractor::getTrackMetaData(
@@ -438,7 +515,7 @@ const size_t MP3Source::kMaxFrameSize = (1 << 12); /* 4096 bytes */
 MP3Source::MP3Source(
         const sp<MetaData> &meta, const sp<DataSource> &source,
         off64_t first_frame_pos, uint32_t fixed_header,
-        const sp<MP3Seeker> &seeker)
+        const sp<MP3Seeker> &seeker, bool Is_Vbr_S)
     : mMeta(meta),
       mDataSource(source),
       mFirstFramePos(first_frame_pos),
@@ -449,7 +526,8 @@ MP3Source::MP3Source(
       mSeeker(seeker),
       mGroup(NULL),
       mBasisTimeUs(0),
-      mSamplesRead(0) {
+      mSamplesRead(0),
+      mIsVbr_S(Is_Vbr_S) {
 }
 
 MP3Source::~MP3Source() {
@@ -498,7 +576,7 @@ status_t MP3Source::read(
     int64_t seekTimeUs;
     ReadOptions::SeekMode mode;
     bool seekCBR = false;
-
+    int32_t bitrate_l;
     if (options != NULL && options->getSeekTo(&seekTimeUs, &mode)) {
         int64_t actualSeekTimeUs = seekTimeUs;
         if (mSeeker == NULL
@@ -509,10 +587,20 @@ status_t MP3Source::read(
                 ALOGI("no bitrate");
 
                 return ERROR_UNSUPPORTED;
+            } else {
+                bitrate_l = bitrate;
+                ALOGE(" bitrate_l %d",bitrate_l);
             }
 
             mCurrentTimeUs = seekTimeUs;
             mCurrentPos = mFirstFramePos + seekTimeUs * bitrate / 8000000;
+            off64_t fileSize;
+            if ((mDataSource->getSize(&fileSize) == OK)&&(mCurrentPos > fileSize)) {
+                int64_t durationUs;
+                mMeta->findInt64(kKeyDuration, &durationUs);
+                if (durationUs != 0)
+                    mCurrentPos = mFirstFramePos + ((actualSeekTimeUs*(fileSize - mFirstFramePos)) + (durationUs >> 1))/durationUs;
+            }
             seekCBR = true;
         } else {
             mCurrentTimeUs = actualSeekTimeUs;
@@ -550,6 +638,10 @@ status_t MP3Source::read(
 
             // re-calculate mCurrentTimeUs because we might have called Resync()
             if (seekCBR) {
+                if (mIsVbr_S) {
+                    ALOGE("mIsVbr_S is true.");
+                    bitrate = bitrate_l/1000;
+                }
                 mCurrentTimeUs = (mCurrentPos - mFirstFramePos) * 8000 / bitrate;
                 mBasisTimeUs = mCurrentTimeUs;
             }
diff --git a/media/libstagefright/MP3FileSource.cpp b/media/libstagefright/MP3FileSource.cpp
new file mode 100644
index 0000000..6a8e79d
--- /dev/null
+++ b/media/libstagefright/MP3FileSource.cpp
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "MP3FileSource"
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/MP3FileSource.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <media/stagefright/FileCache.h>
+
+#define CACHE_SIZE 1024*320
+#define PRE_SIZE 1024*4
+#define PER_READ 1024*16
+namespace android {
+
+MP3FileSource::MP3FileSource(int fd, int64_t offset, int64_t length)
+    : mFd(fd),
+      mOffset(offset),
+      mLength(length),
+      mFileCache_flag(-1) {
+    CHECK(offset >= 0);
+    CHECK(length >= 0);
+
+    //ALOGD("use  MP3FileSource fd:%d,offset:%lld,length:%lld",fd,(long long)offset,(long long)length);
+    int64_t cacheSize = CACHE_SIZE;
+    size_t perRead = PER_READ;
+    size_t preSize = PRE_SIZE;
+    if(length < CACHE_SIZE) {
+        cacheSize = length;
+    }
+    if(PER_READ > length/2) {
+        perRead = length/2;
+    }
+    if(PRE_SIZE > length/2) {
+        preSize = length/2;
+    }
+    //ALOGD("use  MP3FileSource after change   cacheSize:%lld,perRead:%zd,preSize:%zd",(long long)cacheSize,perRead,preSize);
+
+    mFilecache = new FileCache(fd,length+mOffset,cacheSize,perRead,preSize);
+    mFileCache_flag = mFilecache->init();
+
+}
+
+MP3FileSource::~MP3FileSource() {
+//ALOGD("~MP3filesource fd:%d,length:%lld",mFd,(long long)mLength);
+    if(!(mFilecache == NULL)) {
+        mFilecache->exit();
+    }
+    mFilecache.clear();
+}
+
+status_t MP3FileSource::initCheck() const {
+    return mFd >= 0 ? OK : NO_INIT;
+}
+ssize_t MP3FileSource::readAt(off64_t offset, void *data, size_t size) {
+    if (mFd < 0) {
+        return NO_INIT;
+    }
+    Mutex::Autolock autoLock(mLock);
+
+    if (mLength >= 0) {
+        if (offset >= mLength) {
+            return 0;  // read beyond EOF.
+        }
+        int64_t numAvailable = mLength - offset;
+        if ((int64_t)size > numAvailable) {
+            size = numAvailable;
+        }
+    }
+
+    if(mFileCache_flag < 0) {
+        off64_t result = lseek64(mFd, offset + mOffset, SEEK_SET);
+        if (result == -1) {
+            ALOGE("seek to failed");
+            return UNKNOWN_ERROR;
+        }
+        return ::read(mFd, data, size);
+    }
+    else {
+        ssize_t readsize = mFilecache->readAt(offset+ mOffset,data,size);
+        if(readsize>=0)
+            return readsize;
+        else
+            return UNKNOWN_ERROR;
+    }
+
+}
+
+status_t MP3FileSource::getSize(off64_t *size) {
+    Mutex::Autolock autoLock(mLock);
+
+    if (mFd < 0) {
+        return NO_INIT;
+    }
+    *size = mLength;
+    return OK;
+}
+
+
+}  // namespace android
+
diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index 6f746f2..450a932 100644
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -374,6 +374,10 @@ static const char *FourCC2MIME(uint32_t fourcc) {
         case FOURCC('h', 'v', 'c', '1'):
         case FOURCC('h', 'e', 'v', '1'):
             return MEDIA_MIMETYPE_VIDEO_HEVC;
+
+        case FOURCC('j', 'p', 'e', 'g'):
+        case FOURCC('M', 'J', 'P', 'G'):
+            return MEDIA_MIMETYPE_VIDEO_MJPG;
 #ifdef DOLBY_ENABLE
         case FOURCC('a', 'c', '-', '3'):
             ALOGV("@DDP Track FOURCC = 'ac-3'");
@@ -534,7 +538,7 @@ sp<MetaData> MPEG4Extractor::getTrackMetaData(
                 }
             } else {
                 uint32_t sampleIndex;
-                uint32_t sampleTime;
+                uint64_t sampleTime;
                 if (track->timescale != 0 &&
                         track->sampleTable->findThumbnailSample(&sampleIndex) == OK
                         && track->sampleTable->getMetaDataForSample(
@@ -1436,6 +1440,7 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('e', 'n', 'c', 'a'):
         case FOURCC('s', 'a', 'm', 'r'):
         case FOURCC('s', 'a', 'w', 'b'):
+        case FOURCC('.', 'm', 'p', '3'):
 #ifdef DOLBY_ENABLE
         case FOURCC('a', 'c', '-', '3'):
         case FOURCC('e', 'c', '-', '3'):
@@ -1645,6 +1650,8 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('a', 'v', 'c', '1'):
         case FOURCC('h', 'v', 'c', '1'):
         case FOURCC('h', 'e', 'v', '1'):
+        case FOURCC('j', 'p', 'e', 'g'):
+        case FOURCC('M', 'J', 'P', 'G'):
         {
             uint8_t buffer[78];
             if (chunk_data_size < (ssize_t)sizeof(buffer)) {
@@ -1956,6 +1963,69 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             mLastTrack->meta->setData(
                     kKeyESDS, kTypeESDS, &buffer[4], chunk_data_size - 4);
 
+            {
+                //add esds parser to find true MIME type from fake mp4v stream
+                //by wenan.hu
+                const char *mime;
+                mLastTrack->meta->findCString(kKeyMIMEType, &mime);
+                if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4)) {
+                    #define MP4ESDescrTag                   0x03
+                    #define MP4DecConfigDescrTag            0x04
+
+                    int tag, size, flags;
+                    int idx = 4;
+                    int count = 4;
+
+                    tag = buffer[idx];
+                    idx++;
+
+                    while (count--) {
+                        size = buffer[idx];
+                        idx++;
+                        if (!(size & 0x80))
+                            break;
+                    }
+
+                    if (tag == MP4ESDescrTag) {
+                        idx += 2;  //skip es id
+                        flags = buffer[idx];
+                        idx++;
+                        if (flags & 0x80)
+                            idx += 2;  //skip streamDependenceFlag
+                        if (flags & 0x40) {
+                            int len = buffer[idx];
+                            idx++;
+                            idx += len;  //skip URL_Flag
+                        }
+                        if (flags & 0x20)
+                            idx += 2;  //skip OCRstreamFlag
+                    } else {
+                        idx += 2;  //skip ID
+                    }
+
+                    tag = buffer[idx];
+                    idx++;
+                    count = 4;
+
+                    while (count--) {
+                        size = buffer[idx];
+                        idx++;
+                        if (!(size & 0x80))
+                            break;
+                    }
+
+                    if (tag == MP4DecConfigDescrTag) {
+                        int object_type_id = buffer[idx];
+
+                        ALOGD("object type id: 0x%x", object_type_id);
+                        if (object_type_id >= 0x61 && object_type_id <= 0x65) {
+                            ALOGD("find MPEG2 video stream!");
+                            mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_MPEG2);
+                        }
+                    }
+                }
+            }
+
             if (mPath.size() >= 2
                     && mPath[mPath.size() - 2] == FOURCC('m', 'p', '4', 'a')) {
                 // Information from the ESDS must be relied on for proper
@@ -2098,7 +2168,7 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('m', 'e', 't', 'a'):
         {
             off64_t stop_offset = *offset + chunk_size;
-            *offset = data_offset;
+            //*offset = data_offset;
             bool isParsingMetaKeys = underQTMetaPath(mPath, 2);
             if (!isParsingMetaKeys) {
                 uint8_t buffer[4];
@@ -2123,7 +2193,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                     *offset = stop_offset;
                     return OK;
                 }
-                *offset +=  sizeof(buffer);
+                *offset = data_offset + sizeof(buffer);
+            } else {
+                *offset = data_offset;
             }
 
             while (*offset < stop_offset) {
@@ -4511,7 +4583,7 @@ status_t MPEG4Source::read(
                     sampleIndex, &syncSampleIndex, findFlags);
         }
 
-        uint32_t sampleTime;
+        uint64_t sampleTime;
         if (err == OK) {
             err = mSampleTable->getMetaDataForSample(
                     sampleIndex, NULL, NULL, &sampleTime);
@@ -4535,7 +4607,7 @@ status_t MPEG4Source::read(
         }
 
 #if 0
-        uint32_t syncSampleTime;
+        uint64_t syncSampleTime;
         CHECK_EQ(OK, mSampleTable->getMetaDataForSample(
                     syncSampleIndex, NULL, NULL, &syncSampleTime));
 
@@ -4557,7 +4629,8 @@ status_t MPEG4Source::read(
 
     off64_t offset;
     size_t size;
-    uint32_t cts, stts;
+    uint64_t cts;
+    uint32_t stts;
     bool isSyncSample;
     bool newBuffer = false;
     if (mBuffer == NULL) {
@@ -4568,6 +4641,9 @@ status_t MPEG4Source::read(
                     mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);
 
         if (err != OK) {
+            if (err == ERROR_OUT_OF_RANGE) {
+                err = ERROR_END_OF_STREAM;
+            }
             return err;
         }
 
@@ -4696,6 +4772,14 @@ status_t MPEG4Source::read(
                     nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                     srcOffset += mNALLengthSize;
                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);
+                    if (isMalFormed) {
+                        if (srcOffset + nalLength > size) {
+                            nalLength = size - srcOffset;
+                            isMalFormed = false;
+                            ALOGI("second, srcOffset: %zd, nalLength: %zd, size: %zd, isMalFormed: %d",
+                                srcOffset,nalLength,size,isMalFormed);
+                        }
+                    }
                 }
 
                 if (isMalFormed) {
@@ -5130,6 +5214,7 @@ static bool isCompatibleBrand(uint32_t fourcc) {
         FOURCC('3', 'g', 'p', '4'),
         FOURCC('m', 'p', '4', '1'),
         FOURCC('m', 'p', '4', '2'),
+        FOURCC('w', 'm', 'f', ' '),
 
         // Won't promise that the following file types can be played.
         // Just give these file types a chance.
diff --git a/media/libstagefright/MediaCodec.cpp b/media/libstagefright/MediaCodec.cpp
index a8e801f..1f26494 100644
--- a/media/libstagefright/MediaCodec.cpp
+++ b/media/libstagefright/MediaCodec.cpp
@@ -1770,6 +1770,10 @@ void MediaCodec::onMessageReceived(const sp<AMessage> &msg) {
                 mFlags |= kFlagIsEncoder;
             }
 
+            if (flags & CONFIGURE_FLAG_THUMBNAIL) {
+                format->setInt32("thumbnail", true);
+            }
+
             extractCSD(format);
 
             mCodec->initiateConfigureComponent(format);
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index fd6a84c..41f3765 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -47,14 +47,21 @@ const char *MEDIA_MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";
 const char *MEDIA_MIMETYPE_VIDEO_H263 = "video/3gpp";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
+const char *MEDIA_MIMETYPE_VIDEO_MJPG = "video/mjpg";
 const char *MEDIA_MIMETYPE_VIDEO_DOLBY_VISION = "video/dolby-vision";
 
+const char *MEDIA_MIMETYPE_AUDIO_AMR = "audio/amr";
 const char *MEDIA_MIMETYPE_AUDIO_AMR_NB = "audio/3gpp";
 const char *MEDIA_MIMETYPE_AUDIO_AMR_WB = "audio/amr-wb";
 const char *MEDIA_MIMETYPE_AUDIO_MPEG = "audio/mpeg";
+const char *MEDIA_MIMETYPE_AUDIO_MP3 = "audio/mp3";
+const char *MEDIA_MIMETYPE_AUDIO_MPG3 = "audio/mpg3";
+const char *MEDIA_MIMETYPE_AUDIO_BP3 = "audio/bp3";
+
 const char *MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_I = "audio/mpeg-L1";
 const char *MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II = "audio/mpeg-L2";
 const char *MEDIA_MIMETYPE_AUDIO_MIDI = "audio/midi";
+const char *MEDIA_MIMETYPE_AUDIO_MIDI1= "audio/sp-midi";
 const char *MEDIA_MIMETYPE_AUDIO_AAC = "audio/mp4a-latm";
 const char *MEDIA_MIMETYPE_AUDIO_QCELP = "audio/qcelp";
 const char *MEDIA_MIMETYPE_AUDIO_VORBIS = "audio/vorbis";
@@ -62,7 +69,10 @@ const char *MEDIA_MIMETYPE_AUDIO_OPUS = "audio/opus";
 const char *MEDIA_MIMETYPE_AUDIO_G711_ALAW = "audio/g711-alaw";
 const char *MEDIA_MIMETYPE_AUDIO_G711_MLAW = "audio/g711-mlaw";
 const char *MEDIA_MIMETYPE_AUDIO_RAW = "audio/raw";
+const char *MEDIA_MIMETYPE_AUDIO_IMAADPCM = "audio/ima-adpcm";
 const char *MEDIA_MIMETYPE_AUDIO_FLAC = "audio/flac";
+const char *MEDIA_MIMETYPE_AUDIO_AAC2 = "audio/x-aac";
+const char *MEDIA_MIMETYPE_AUDIO_AAC3 = "audio/aac";
 const char *MEDIA_MIMETYPE_AUDIO_AAC_ADTS = "audio/aac-adts";
 const char *MEDIA_MIMETYPE_AUDIO_MSGSM = "audio/gsm";
 const char *MEDIA_MIMETYPE_AUDIO_AC3 = "audio/ac3";
@@ -73,10 +83,13 @@ const char *MEDIA_MIMETYPE_AUDIO_EAC3_JOC = "audio/eac3-joc";
 
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG4 = "video/mp4";
 const char *MEDIA_MIMETYPE_CONTAINER_WAV = "audio/x-wav";
+const char *MEDIA_MIMETYPE_CONTAINER_WAV2 = "audio/wav";
 const char *MEDIA_MIMETYPE_CONTAINER_OGG = "application/ogg";
+const char *MEDIA_MIMETYPE_CONTAINER_OGG2 = "audio/ogg";
 const char *MEDIA_MIMETYPE_CONTAINER_MATROSKA = "video/x-matroska";
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG2TS = "video/mp2ts";
 const char *MEDIA_MIMETYPE_CONTAINER_AVI = "video/avi";
+const char *MEDIA_MIMETYPE_CONTAINER_MSVIDEO = "video/x-msvideo";
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG2PS = "video/mp2p";
 
 const char *MEDIA_MIMETYPE_CONTAINER_WVM = "video/wvm";
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index 31476e5..98a1afa 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -32,6 +32,8 @@
 #include "include/FLACExtractor.h"
 #include "include/AACExtractor.h"
 #include "include/MidiExtractor.h"
+#include "include/AVIExtractor.h"
+#include "include/FLVExtractor.h"
 
 #include "matroska/MatroskaExtractor.h"
 
@@ -48,6 +50,7 @@
 #include <cutils/properties.h>
 #include <utils/String8.h>
 #include <private/android_filesystem_config.h>
+#include <media/stagefright/MP3FileSource.h>
 
 #include <media/stagefright/FFMPEGSoftCodec.h>
 #include <stagefright/AVExtensions.h>
@@ -241,29 +244,53 @@ sp<MediaExtractor> MediaExtractor::CreateFromService(
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)
             || !strcasecmp(mime, "audio/mp4")) {
         ret = new MPEG4Extractor(source);
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {
-        ret = new MP3Extractor(source, meta);
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG) ||
+            !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_BP3) ||
+            !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MP3) ||
+            !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPG3)) {
+        int fd = 0;
+        int64_t offset = 0;
+        int64_t length = 0;
+        source->getFd(&fd,&offset);
+        source->getSize(&length);
+        //ALOGD("fd:%d,length:%lld,offset:%lld",fd,(long long)length,(long long)offset);
+        if(fd > 0 && !isDrm)
+            ret = new MP3Extractor(new MP3FileSource(fd, offset, length), meta);
+        else
+            ret = new MP3Extractor(source, meta);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)
-            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) {
+            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)
+            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR)) {
         ret = new AMRExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {
         ret = new FLACExtractor(source);
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) {
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WAV) ||
+    		   !strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WAV2)) {
         ret = new WAVExtractor(source);
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) {
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG) ||
+    		   !strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG2)) {
         ret = new OggExtractor(source);
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MATROSKA)) {
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MATROSKA) ||
+           !strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WEBM)) {
         ret = new MatroskaExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) {
         ret = new MPEG2TSExtractor(source);
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_AVI) ||
+                    !strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MSVIDEO)) {
+        ret = new AVIExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WVM) && getuid() == AID_MEDIA) {
         // Return now.  WVExtractor should not have the DrmFlag set in the block below.
         return new WVMExtractor(source);
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS)) {
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_FLV)) {
+        ret = new FLVExtractor(source);
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS) ||
+                   !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC2) ||
+                   !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC3)) {
         ret = new AACExtractor(source, meta);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) {
         ret = new MPEG2PSExtractor(source);
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MIDI)) {
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MIDI) ||
+                   !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MIDI1)) {
         ret = new MidiExtractor(source);
     } else if (!isDrm) {
         ret = FFMPEGSoftCodec::createExtractor(source, mime, meta);
diff --git a/media/libstagefright/SampleIterator.cpp b/media/libstagefright/SampleIterator.cpp
index 54c9fa3..05bdcd4 100644
--- a/media/libstagefright/SampleIterator.cpp
+++ b/media/libstagefright/SampleIterator.cpp
@@ -108,6 +108,10 @@ status_t SampleIterator::seekTo(uint32_t sampleIndex) {
 
         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
             size_t sampleSize;
+            if (firstChunkSampleIndex + i >= mTable->mNumSampleSizes) {
+                ALOGI("wrong sample count");
+                break;
+            }
             if ((err = getSampleSizeDirect(
                             firstChunkSampleIndex + i, &sampleSize)) != OK) {
                 ALOGE("getSampleSizeDirect return error");
@@ -300,7 +304,7 @@ status_t SampleIterator::getSampleSizeDirect(
 }
 
 status_t SampleIterator::findSampleTimeAndDuration(
-        uint32_t sampleIndex, uint32_t *time, uint32_t *duration) {
+        uint32_t sampleIndex, uint64_t *time, uint32_t *duration) {
     if (sampleIndex >= mTable->mNumSampleSizes) {
         return ERROR_OUT_OF_RANGE;
     }
@@ -325,7 +329,7 @@ status_t SampleIterator::findSampleTimeAndDuration(
     if ((offset < 0 && *time < (offset == INT32_MIN ?
             INT32_MAX : uint32_t(-offset))) ||
             (offset > 0 && *time > UINT32_MAX - offset)) {
-        ALOGE("%u + %d would overflow", *time, offset);
+        ALOGE("%llu + %d would overflow", *time, offset);
         return ERROR_OUT_OF_RANGE;
     }
     if (offset > 0) {
diff --git a/media/libstagefright/SampleTable.cpp b/media/libstagefright/SampleTable.cpp
index de6ee73..ed62147 100644
--- a/media/libstagefright/SampleTable.cpp
+++ b/media/libstagefright/SampleTable.cpp
@@ -614,7 +614,7 @@ status_t SampleTable::getMaxSampleSize(size_t *max_size) {
     return OK;
 }
 
-uint32_t abs_difference(uint32_t time1, uint32_t time2) {
+uint64_t abs_difference(uint64_t time1, uint64_t time2) {
     return time1 > time2 ? time1 - time2 : time2 - time1;
 }
 
@@ -662,7 +662,7 @@ void SampleTable::buildSampleEntriesTable() {
     }
 
     uint32_t sampleIndex = 0;
-    uint32_t sampleTime = 0;
+    uint64_t sampleTime = 0;
 
     for (uint32_t i = 0; i < mTimeToSampleCount; ++i) {
         uint32_t n = mTimeToSample[2 * i];
@@ -685,7 +685,7 @@ void SampleTable::buildSampleEntriesTable() {
                                 INT32_MAX : uint32_t(-compTimeDelta)))
                         || (compTimeDelta > 0 &&
                                 sampleTime > UINT32_MAX - compTimeDelta)) {
-                    ALOGE("%u + %d would overflow, clamping",
+                    ALOGE("%llu + %d would overflow, clamping",
                             sampleTime, compTimeDelta);
                     if (compTimeDelta < 0) {
                         sampleTime = 0;
@@ -856,19 +856,19 @@ status_t SampleTable::findSyncSampleNear(
             if (err != OK) {
                 return err;
             }
-            uint32_t sample_time = mSampleIterator->getSampleTime();
+            uint64_t sample_time = mSampleIterator->getSampleTime();
 
             err = mSampleIterator->seekTo(mSyncSamples[left]);
             if (err != OK) {
                 return err;
             }
-            uint32_t upper_time = mSampleIterator->getSampleTime();
+            uint64_t upper_time = mSampleIterator->getSampleTime();
 
             err = mSampleIterator->seekTo(mSyncSamples[left - 1]);
             if (err != OK) {
                 return err;
             }
-            uint32_t lower_time = mSampleIterator->getSampleTime();
+            uint64_t lower_time = mSampleIterator->getSampleTime();
 
             // use abs_difference for safety
             if (abs_difference(upper_time, sample_time) >
@@ -936,7 +936,7 @@ status_t SampleTable::getMetaDataForSample(
         uint32_t sampleIndex,
         off64_t *offset,
         size_t *size,
-        uint32_t *compositionTime,
+        uint64_t *compositionTime,
         bool *isSyncSample,
         uint32_t *sampleDuration) {
     Mutex::Autolock autoLock(mLock);
diff --git a/media/libstagefright/StagefrightMetadataRetriever.cpp b/media/libstagefright/StagefrightMetadataRetriever.cpp
index f00b8b7..9ccafa6 100644
--- a/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -184,7 +184,8 @@ static VideoFrame *extractVideoFrame(
         return NULL;
     }
 
-    err = decoder->configure(videoFormat, NULL /* surface */, NULL /* crypto */, 0 /* flags */);
+    err = decoder->configure(videoFormat, NULL /* surface */, NULL /* crypto */,
+                                            MediaCodec::CONFIGURE_FLAG_THUMBNAIL/* flags */);
     if (err != OK) {
         ALOGW("configure returned error %d (%s)", err, asString(err));
         decoder->release();
diff --git a/media/libstagefright/codecs/mp3dec/SoftMP3.cpp b/media/libstagefright/codecs/mp3dec/SoftMP3.cpp
index a059a24..9f55f5c 100644
--- a/media/libstagefright/codecs/mp3dec/SoftMP3.cpp
+++ b/media/libstagefright/codecs/mp3dec/SoftMP3.cpp
@@ -351,7 +351,9 @@ void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {
             }
         } else if (mConfig->samplingRate != mSamplingRate
                 || mConfig->num_channels != mNumChannels) {
-            mSamplingRate = mConfig->samplingRate;
+            if (0 != mConfig->samplingRate) {
+                mSamplingRate = mConfig->samplingRate;
+            }
             mNumChannels = mConfig->num_channels;
 
             notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
@@ -374,6 +376,10 @@ void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {
             outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);
         }
 
+        if (0 == mConfig->samplingRate) {
+            mConfig->samplingRate = mSamplingRate;
+        }
+
         outHeader->nTimeStamp =
             mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;
         tmpTime = outHeader->nTimeStamp;
diff --git a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
index be04e08..c154b8e 100644
--- a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
+++ b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
@@ -401,6 +401,7 @@ void SoftVorbis::onQueueFilled(OMX_U32 portIndex) {
 #else
             ALOGW("vorbis_dsp_synthesis returned %d", err);
 #endif
+        mNumFramesLeftOnPage = -1; //parameter need to init when seeking action
         } else {
             size_t numSamplesPerBuffer = kMaxNumSamplesPerBuffer;
             if (numSamplesPerBuffer > outHeader->nAllocLen / sizeof(int16_t)) {
diff --git a/media/libstagefright/include/AVIExtractor.h b/media/libstagefright/include/AVIExtractor.h
index 3be505c..ca400da 100644
--- a/media/libstagefright/include/AVIExtractor.h
+++ b/media/libstagefright/include/AVIExtractor.h
@@ -25,12 +25,16 @@
 
 namespace android {
 
+//for broken files, cannot get samplesize
+#define AVI_VIDEO_SAMPLE_MAX_SIZE (192<<10)
+#define AVI_AUDIO_SAMPLE_MAX_SIZE (12 <<10)
+
 struct AVIExtractor : public MediaExtractor {
     AVIExtractor(const sp<DataSource> &dataSource);
 
     virtual size_t countTracks();
 
-    virtual sp<MediaSource> getTrack(size_t index);
+    virtual sp<IMediaSource> getTrack(size_t index);
 
     virtual sp<MetaData> getTrackMetaData(
             size_t index, uint32_t flags);
@@ -38,6 +42,8 @@ struct AVIExtractor : public MediaExtractor {
     virtual sp<MetaData> getMetaData();
     virtual const char * name() { return "AVIExtractor"; }
 
+    virtual uint32_t flags() const;
+
 protected:
     virtual ~AVIExtractor();
 
@@ -48,6 +54,7 @@ private:
     struct SampleInfo {
         uint32_t mOffset;
         bool mIsKey;
+        uint32_t mLengthTotal;
     };
 
     struct Track {
@@ -73,11 +80,28 @@ private:
         ssize_t mThumbnailSampleIndex;
         size_t mMaxSampleSize;
 
+        // if no index
+        uint32_t mCurSamplePos;
+
         // If mBytesPerSample > 0:
         double mAvgChunkSize;
         size_t mFirstChunkSize;
+
+        //for avi seeking
+        size_t mPreChunkSize;
+        uint32_t mLengthTotal;
+
+        //bits per sample for pcm
+        size_t mBitsPerSample;
     };
 
+    enum IndexType
+    {
+        IDX1,        //avi1.0 index
+        INDX,        //Open-DML-Index-chunk
+        NO_INDEX     //normally no idx1, since indx is stored  with a/v data together
+    } mIndexType;
+
     sp<DataSource> mDataSource;
     status_t mInitCheck;
     Vector<Track> mTracks;
@@ -89,7 +113,8 @@ private:
     ssize_t parseChunk(off64_t offset, off64_t size, int depth = 0);
     status_t parseStreamHeader(off64_t offset, size_t size);
     status_t parseStreamFormat(off64_t offset, size_t size);
-    status_t parseIndex(off64_t offset, size_t size);
+    status_t parseIdx1(off64_t offset, size_t size);
+    status_t parseIndx(off64_t offset, size_t size);
 
     status_t parseHeaders();
 
diff --git a/media/libstagefright/include/FLVExtractor.h b/media/libstagefright/include/FLVExtractor.h
new file mode 100644
index 0000000..a379fa2
--- /dev/null
+++ b/media/libstagefright/include/FLVExtractor.h
@@ -0,0 +1,263 @@
+/**
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLV_EXTRACTOR_H_
+
+#define FLV_EXTRACTOR_H_
+
+#include <media/stagefright/foundation/ABase.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/stagefright/MediaSource.h>
+#include <utils/Vector.h>
+
+namespace android {
+
+#define SIZE_OF_TAG_HEAD	11
+
+#define AV_TIME_BASE		1000000
+
+#define AMF_END_OF_OBJECT       0x09
+
+#define FLV_AUDIO_CODECID_MASK		0xf0	//--bit[7:4]
+#define FLV_AUDIO_CODECID_OFFSET	4
+#define FLV_AUDIO_RATE_MASK		0x0c	//--bit[3:2]
+#define FLV_AUDIO_RATE_OFFSET		0x02
+#define FLV_AUDIO_SIZE_MASK		0x02	//--bit1
+#define FLV_AUDIO_CHANNEL_MASK		0x01	//--bit0
+
+#define FLV_VIDEO_FRAMETYPE_MASK	0xf0
+#define FLV_VIDEO_FRAMETYPE_OFFSET  	4
+
+#define FLV_MOVIE_TIMESCALE 1000000
+
+enum {
+    FLV_HEADER_FLAG_HASVIDEO = 1,
+    FLV_HEADER_FLAG_HASAUDIO = 4,
+};
+
+enum {
+    FLV_TAG_TYPE_AUDIO = 0x08,
+    FLV_TAG_TYPE_VIDEO = 0x09,
+    FLV_TAG_TYPE_META  = 0x12,
+};
+
+enum {
+    FLV_CODECID_PCM_BE              = 0,
+    FLV_CODECID_ADPCM               = 1 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_MP3                 = 2 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_PCM_LE              = 3 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_NELLYMOSER_8HZ_MONO = 5 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_NELLYMOSER          = 6 << FLV_AUDIO_CODECID_OFFSET,
+    FLV_CODECID_AAC                         = 10 << FLV_AUDIO_CODECID_OFFSET,
+};
+
+enum{
+	FLV_AUDIO_RATE_5500		= 0,
+	FLV_AUDIO_RATE_11000	= 1 << FLV_AUDIO_RATE_OFFSET,
+	FLV_AUDIO_RATE_22000	= 2 << FLV_AUDIO_RATE_OFFSET,
+	FLV_AUDIO_RATE_44000	= 3 << FLV_AUDIO_RATE_OFFSET,
+};
+
+enum {
+    FLV_CODECID_H263    = 2,
+    FLV_CODECID_SCREEN  = 3,
+    FLV_CODECID_VP6     = 4,
+    FLV_CODECID_VP6A    = 5,
+    FLV_CODECID_SCREEN2 = 6,
+    FLV_CODECID_AVC = 7
+};
+
+enum {
+    FLV_FRAME_KEY        = 1 << FLV_VIDEO_FRAMETYPE_OFFSET,
+    FLV_FRAME_INTER      = 2 << FLV_VIDEO_FRAMETYPE_OFFSET,
+    FLV_FRAME_DISP_INTER = 3 << FLV_VIDEO_FRAMETYPE_OFFSET,
+};
+
+typedef enum {
+    AMF_DATA_TYPE_NUMBER      = 0x00,
+    AMF_DATA_TYPE_BOOL        = 0x01,
+    AMF_DATA_TYPE_STRING      = 0x02,
+    AMF_DATA_TYPE_OBJECT      = 0x03,
+    AMF_DATA_TYPE_NULL        = 0x05,
+    AMF_DATA_TYPE_UNDEFINED   = 0x06,
+    AMF_DATA_TYPE_REFERENCE   = 0x07,
+    AMF_DATA_TYPE_MIXEDARRAY  = 0x08,
+    AMF_DATA_TYPE_ARRAY       = 0x0a,
+    AMF_DATA_TYPE_DATE        = 0x0b,
+    AMF_DATA_TYPE_UNSUPPORTED = 0x0d,
+} AMFDataType;
+
+typedef struct FLV_TAG_INFORMATION_TAG
+{
+    uint32_t tag_type;		//--type of cur-packet.
+    uint32_t time_stamp;	//--time stamp of cur-packet in ms.
+    uint32_t data_size;		//--size of the data.
+    uint32_t cur_pos;		//--pos of current packet in file.
+    uint32_t next_pos;		//--pos of next packet in file.
+    uint32_t pre_pos;		//--pos of previous packet in file.
+
+    union TAG_DATA_HEADER_TAG
+    {
+        unsigned char data_head;
+        unsigned char audio_format;		//audio data head.
+        unsigned char video_format;		//video data head.
+        unsigned char object_name_type;	//object data head.
+        uint32_t reserve4B;
+    }data_header;
+
+}FLV_TAG_INFO_T;
+
+// Keyframe Link List
+typedef struct TKeyFrameLinkListItem_TAG
+{
+    uint32_t pos;	//position
+    uint32_t timestamp;//double timestamp;
+    struct TKeyFrameLinkListItem_TAG* next;
+}TKeyFrameLinkListItem_T;
+
+struct TKeyFrameEntry
+{
+    uint32_t pos;   //position
+    uint32_t timestamp;//double timestamp;
+};
+
+//for broken files, cannot get tagsize
+/** SPRD: modify { */
+//#define FLV_VIDEO_TAG_MAX_SIZE (512<<10)
+#define FLV_VIDEO_TAG_MAX_SIZE (1024<<10)
+/** SPRD: modify } */
+#define FLV_AUDIO_TAG_MAX_SIZE (12 <<10)
+
+struct FLVExtractor : public MediaExtractor {
+    FLVExtractor(const sp<DataSource> &dataSource);
+
+    virtual size_t countTracks();
+
+    virtual sp<IMediaSource> getTrack(size_t index);
+
+    virtual sp<MetaData> getTrackMetaData(
+            size_t index, uint32_t flags);
+
+    virtual sp<MetaData> getMetaData();
+
+    virtual uint32_t flags() const;
+
+protected:
+    virtual ~FLVExtractor();
+
+private:
+    struct FLVSource;
+    struct AudioSource;
+
+    struct TagInfo {
+        uint32_t mOffset;
+        bool mIsKey;
+    };
+
+    struct Track {
+        sp<MetaData> mMeta;
+        Vector<TagInfo> mTags;
+        uint32_t mRate;
+        uint32_t mScale;
+
+        // If bytes per tag == 0, each chunk represents a single tag,
+        // otherwise each chunk should me a multiple of bytes-per-tag in
+        // size.
+        uint32_t mBytesPerTag;
+
+        enum Kind {
+            AUDIO,
+            VIDEO,
+            OTHER
+        } mKind;
+
+        size_t mNumSyncTags;
+        size_t mThumbnailTagSize;
+        ssize_t mThumbnailTagIndex;
+        size_t mMaxTagSize;
+
+        // if no index
+        uint32_t mCurTagPos;
+        //for replay seek 0 with can not seek
+        uint32_t mInitTagPos;
+        // If mBytesPertag > 0:
+        double mAvgTagSize;
+        size_t mFirstTagSize;
+    };
+
+    sp<DataSource> mDataSource;
+    status_t mInitCheck;
+    Vector<Track> mTracks;
+
+    off64_t mMovieOffset;
+    bool mFoundIndex;
+    bool mOffsetsAreAbsolute;
+    TKeyFrameEntry *mKeyFrameEntries;
+    uint32_t mKeyFrameNum;
+    int64_t mCurrentTimeUs;
+    bool mIsMetadataPresent;
+    int64_t mLastseekTimeUs;
+
+    void setInitTagPos(size_t trackIndex);
+    status_t parseHeaders();
+    status_t parseTagHeaders(off64_t offset, off64_t size);
+    status_t parseTag(off_t offset, off64_t size);
+    ssize_t flv_read_metabody(off_t offset);
+    ssize_t amf_get_string(uint32_t offset, uint8_t *buffer, int32_t buffsize);
+    ssize_t amf_parse_object(const char *key, uint32_t  offset, int depth);
+
+	double amf_get_doublenum(uint32_t offset);
+	status_t alloc_keyframe_entry(uint32_t array_num);
+	status_t getKeyFramePosition(size_t trackIndex,int64_t seekTimeUs,size_t maxTagSize);
+	status_t getKeyFrameEntriesIndex(int64_t seekTimeUs,int32_t *index);
+	status_t getTagInfoWithOffset(
+		size_t trackIndex,off64_t inoffset,
+		off64_t *offset, size_t *size, bool *isKey,
+		int64_t *tagTimeUs);
+
+    status_t getTagInfo(
+            size_t trackIndex, size_t tagIndex,
+            off64_t *offset, size_t *size, bool *isKey,
+            int64_t *tagTimeUs);
+
+    status_t getTagTime(
+            size_t trackIndex, size_t tagIndex, int64_t *tagTimeUs);
+
+    status_t getTagIndexAtTime(
+            size_t trackIndex,
+            int64_t timeUs, MediaSource::ReadOptions::SeekMode mode,
+            size_t *tagIndex) const;
+
+    status_t addMPEG4CodecSpecificData(size_t trackIndex);
+    status_t addH264CodecSpecificData(size_t trackIndex);
+
+    static bool IsCorrectTagType(
+        ssize_t trackIndex, Track::Kind kind, uint32_t chunkType);
+
+    DISALLOW_EVIL_CONSTRUCTORS(FLVExtractor);
+};
+
+class String8;
+struct AMessage;
+
+bool SniffFLV(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+        sp<AMessage> *);
+
+}  // namespace android
+
+#endif  // FLV_EXTRACTOR_H_
+
diff --git a/media/libstagefright/include/MP3Extractor.h b/media/libstagefright/include/MP3Extractor.h
index 2fd04f2..059109e 100644
--- a/media/libstagefright/include/MP3Extractor.h
+++ b/media/libstagefright/include/MP3Extractor.h
@@ -39,6 +39,7 @@ public:
 
     virtual sp<MetaData> getMetaData();
     virtual const char * name() { return "MP3Extractor"; }
+    bool TestVBR(const sp<DataSource> &source, int *avg_bitrate, uint32_t match_header,off64_t inout_pos);
 
 private:
     status_t mInitCheck;
@@ -48,6 +49,7 @@ private:
     sp<MetaData> mMeta;
     uint32_t mFixedHeader;
     sp<MP3Seeker> mSeeker;
+    bool mIsVbr;
 
     MP3Extractor(const MP3Extractor &);
     MP3Extractor &operator=(const MP3Extractor &);
diff --git a/media/libstagefright/include/PSXSTRExtractor.h b/media/libstagefright/include/PSXSTRExtractor.h
new file mode 100644
index 0000000..6cc5ac0
--- /dev/null
+++ b/media/libstagefright/include/PSXSTRExtractor.h
@@ -0,0 +1,45 @@
+/*
+ * Sony Playstation (PSX) STR File Demuxer
+ *
+ * PSX STR file demuxer
+ *
+ * TODO: Implement this demux in the future
+ */
+
+#ifndef PSX_EXTRACTOR_H_
+
+#define PSX_EXTRACTOR_H_
+
+//#define LOG_NDEBUG 0
+//#define LOG_TAG "PSXSTRExtractor"
+//#include <utils/Log.h>
+
+namespace android {
+
+bool SniffPSXSTR(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+        sp<AMessage> *) {
+
+    uint8_t header[12];
+    if (source->readAt(0, header, sizeof(header)) < (ssize_t)sizeof(header)) {
+        return false;
+    }
+
+    if (memcmp("\x52\x49\x46\x46", &header[0], 4) ||
+            memcmp("\x43\x44\x58\x41", &header[8], 4)) {
+        return false;
+    }
+
+   // ALOGW("This is PSX STR format which is not supported so far");
+
+
+    *confidence = 0.21f;  //Slightly larger than .mp3 extractor confidence
+
+    mimeType->setTo("video/psxstr");
+    return true;
+
+}
+
+}  //namespace android
+
+#endif
diff --git a/media/libstagefright/include/SampleIterator.h b/media/libstagefright/include/SampleIterator.h
index 2ef41ae..b478a3e 100644
--- a/media/libstagefright/include/SampleIterator.h
+++ b/media/libstagefright/include/SampleIterator.h
@@ -33,7 +33,7 @@ struct SampleIterator {
     uint32_t getDescIndex() const { return mChunkDesc; }
     off64_t getSampleOffset() const { return mCurrentSampleOffset; }
     size_t getSampleSize() const { return mCurrentSampleSize; }
-    uint32_t getSampleTime() const { return mCurrentSampleTime; }
+    uint64_t getSampleTime() const { return mCurrentSampleTime; }
     uint32_t getSampleDuration() const { return mCurrentSampleDuration; }
 
     status_t getSampleSizeDirect(
@@ -58,20 +58,20 @@ private:
 
     uint32_t mTimeToSampleIndex;
     uint32_t mTTSSampleIndex;
-    uint32_t mTTSSampleTime;
+    uint64_t mTTSSampleTime;
     uint32_t mTTSCount;
     uint32_t mTTSDuration;
 
     uint32_t mCurrentSampleIndex;
     off64_t mCurrentSampleOffset;
     size_t mCurrentSampleSize;
-    uint32_t mCurrentSampleTime;
+    uint64_t mCurrentSampleTime;
     uint32_t mCurrentSampleDuration;
 
     void reset();
     status_t findChunkRange(uint32_t sampleIndex);
     status_t getChunkOffset(uint32_t chunk, off64_t *offset);
-    status_t findSampleTimeAndDuration(uint32_t sampleIndex, uint32_t *time, uint32_t *duration);
+    status_t findSampleTimeAndDuration(uint32_t sampleIndex, uint64_t *time, uint32_t *duration);
 
     SampleIterator(const SampleIterator &);
     SampleIterator &operator=(const SampleIterator &);
diff --git a/media/libstagefright/include/SampleTable.h b/media/libstagefright/include/SampleTable.h
index 2100ca6..4df228f 100644
--- a/media/libstagefright/include/SampleTable.h
+++ b/media/libstagefright/include/SampleTable.h
@@ -65,7 +65,7 @@ public:
             uint32_t sampleIndex,
             off64_t *offset,
             size_t *size,
-            uint32_t *compositionTime,
+            uint64_t *compositionTime,
             bool *isSyncSample = NULL,
             uint32_t *sampleDuration = NULL);
 
@@ -119,7 +119,7 @@ private:
 
     struct SampleTimeEntry {
         uint32_t mSampleIndex;
-        uint32_t mCompositionTime;
+        uint64_t mCompositionTime;
     };
     SampleTimeEntry *mSampleTimeEntries;
 
diff --git a/media/libstagefright/omx/OMXMaster.cpp b/media/libstagefright/omx/OMXMaster.cpp
index 2d2d500..4e8b971 100644
--- a/media/libstagefright/omx/OMXMaster.cpp
+++ b/media/libstagefright/omx/OMXMaster.cpp
@@ -64,6 +64,7 @@ OMXMaster::~OMXMaster() {
 }
 
 void OMXMaster::addVendorPlugin() {
+    addPlugin("libstagefrighthw_cm.so");
     addPlugin("libstagefrighthw.so");
 }
 
diff --git a/media/libstagefright/omx/SoftOMXPlugin.cpp b/media/libstagefright/omx/SoftOMXPlugin.cpp
index adb7370..ab13885 100644
--- a/media/libstagefright/omx/SoftOMXPlugin.cpp
+++ b/media/libstagefright/omx/SoftOMXPlugin.cpp
@@ -78,6 +78,9 @@ static const struct {
     { "OMX.google.raw.decoder", "rawdec", "audio_decoder.raw" },
     { "OMX.google.flac.encoder", "flacenc", "audio_encoder.flac" },
     { "OMX.google.gsm.decoder", "gsmdec", "audio_decoder.gsm" },
+//sprd added
+    { "OMX.google.imaadpcm.decoder", "imaadpcmdec", "audio_decoder.imaadpcm" },
+    { "OMX.google.mjpg.decoder", "mjpgdec", "video_decoder.mjpg" },
 #ifdef QTI_FLAC_DECODER
     { "OMX.qti.audio.decoder.flac", "flacdec", "audio_decoder.flac" },
 #endif
diff --git a/media/mtp/MtpDataPacket.cpp b/media/mtp/MtpDataPacket.cpp
index 0e9bc34..a6f721f 100644
--- a/media/mtp/MtpDataPacket.cpp
+++ b/media/mtp/MtpDataPacket.cpp
@@ -440,7 +440,9 @@ void MtpDataPacket::putString(const uint16_t* string) {
 
 #ifdef MTP_DEVICE 
 int MtpDataPacket::read(int fd) {
-    int ret = ::read(fd, mBuffer, MTP_BUFFER_SIZE);
+    /* SPRD: modify code for bug 492017. @{ */
+    int ret = ::read(fd, mBuffer, 512);
+    /* @} */
     if (ret < MTP_CONTAINER_HEADER_SIZE)
         return -1;
     mPacketSize = ret;
diff --git a/media/mtp/MtpServer.cpp b/media/mtp/MtpServer.cpp
index e184d48..6584e62 100644
--- a/media/mtp/MtpServer.cpp
+++ b/media/mtp/MtpServer.cpp
@@ -442,8 +442,10 @@ bool MtpServer::handleRequest() {
             break;
     }
 
-    if (response == MTP_RESPONSE_TRANSACTION_CANCELLED)
-        return false;
+    /* SPRD: modify code for bug 491977. @{ */
+    //if (response == MTP_RESPONSE_TRANSACTION_CANCELLED)
+        //return false;
+    /* @} */
     mResponse.setResponseCode(response);
     return true;
 }
diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index facfc86..4713f50 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -488,6 +488,9 @@ String8 devicesToString(audio_devices_t devices)
         {AUDIO_DEVICE_OUT_HDMI_ARC,         "HDMI_ARC"},
         {AUDIO_DEVICE_OUT_SPDIF,            "SPDIF"},
         {AUDIO_DEVICE_OUT_FM,               "FM"},
+        {AUDIO_DEVICE_OUT_FM_HEADSET,       "FM Headset Out"},
+        {AUDIO_DEVICE_OUT_FM_SPEAKER,       "FM Speaker Out"},
+        {AUDIO_DEVICE_OUT_ALL_FM,           ""},
         {AUDIO_DEVICE_OUT_AUX_LINE,         "AUX_LINE"},
         {AUDIO_DEVICE_OUT_SPEAKER_SAFE,     "SPEAKER_SAFE"},
         {AUDIO_DEVICE_OUT_IP,               "IP"},
diff --git a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
index b731e2b..d68b46e 100644
--- a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
@@ -48,6 +48,9 @@ const DeviceConverter::Table DeviceConverter::mTable[] = {
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_HDMI_ARC),
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_SPDIF),
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_FM),
+        MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_FM_HEADSET),
+        MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_FM_SPEAKER),
+        MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_ALL_FM),
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_AUX_LINE),
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_IP),
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_BUS),
