diff --git a/Android.mk b/Android.mk
index dd3236c..ff373ea 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,11 +1,25 @@
-LOCAL_PATH:= $(call my-dir)
+LOCAL_PATH := $(call my-dir)
+
+# Save supplicant's root dir(LOCAL_PATH may be modified by other makefiles)
+WPA_SUPPL_DIR := $(LOCAL_PATH)
 
 ifneq ($(filter VER_0_8_X VER_2_1_DEVEL,$(WPA_SUPPLICANT_VERSION)),)
 # The order of the 2 Android.mks does matter!
 # TODO: Clean up the Android.mks, reset all the temporary variables at the
 # end of each Android.mk, so that one Android.mk doesn't depend on variables
 # set up in the other Android.mk.
+
 include $(LOCAL_PATH)/hostapd/Android.mk \
-        $(LOCAL_PATH)/wpa_supplicant/Android.mk \
-	$(LOCAL_PATH)/hs20/client/Android.mk
+        $(LOCAL_PATH)/wpa_supplicant/Android.mk
+
+ifeq ($(strip $(BOARD_WLAN_DEVICE)),sc2351)
+include $(WPA_SUPPL_DIR)/wpa_supplicant_8_lib_sprd/Android.mk
+endif
+
+ifeq ($(strip $(BOARD_WLAN_DEVICE)),sc2341)
+include $(WPA_SUPPL_DIR)/wpa_supplicant_8_lib_sprd/Android.mk
+endif
+
+include $(WPA_SUPPL_DIR)/wapi_lib/Android.mk
+
 endif
diff --git a/hostapd/Android.mk b/hostapd/Android.mk
index 06e45d9..308e830 100644
--- a/hostapd/Android.mk
+++ b/hostapd/Android.mk
@@ -34,6 +34,10 @@ ifeq ($(BOARD_HOSTAPD_PRIVATE_LIB),)
 L_CFLAGS += -DANDROID_LIB_STUB
 endif
 
+ifeq ($(BOARD_WLAN_DEVICE), bcmdhd)
+L_CFLAGS += -DCONFIG_BCMDHD
+endif
+
 # Use Android specific directory for control interface sockets
 L_CFLAGS += -DCONFIG_CTRL_IFACE_CLIENT_DIR=\"/data/misc/wifi/sockets\"
 L_CFLAGS += -DCONFIG_CTRL_IFACE_DIR=\"/data/system/hostapd\"
@@ -252,22 +256,6 @@ ifdef CONFIG_IEEE80211AC
 L_CFLAGS += -DCONFIG_IEEE80211AC
 endif
 
-ifdef CONFIG_FST
-L_CFLAGS += -DCONFIG_FST
-OBJS += src/fst/fst.c
-OBJS += src/fst/fst_group.c
-OBJS += src/fst/fst_iface.c
-OBJS += src/fst/fst_session.c
-OBJS += src/fst/fst_ctrl_aux.c
-ifdef CONFIG_FST_TEST
-L_CFLAGS += -DCONFIG_FST_TEST
-endif
-ifndef CONFIG_NO_CTRL_IFACE
-OBJS += src/fst/fst_ctrl_iface.c
-endif
-endif
-
-
 include $(LOCAL_PATH)/src/drivers/drivers.mk
 
 OBJS += $(DRV_AP_OBJS)
@@ -545,7 +533,6 @@ endif
 ifeq ($(CONFIG_TLS), openssl)
 ifdef TLS_FUNCS
 OBJS += src/crypto/tls_openssl.c
-OBJS += src/crypto/tls_openssl_ocsp.c
 LIBS += -lssl
 endif
 OBJS += src/crypto/crypto_openssl.c
diff --git a/hostapd/Makefile b/hostapd/Makefile
index 760aebd..d4fd36e 100644
--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -526,7 +526,6 @@ endif
 ifeq ($(CONFIG_TLS), openssl)
 ifdef TLS_FUNCS
 OBJS += ../src/crypto/tls_openssl.o
-OBJS += ../src/crypto/tls_openssl_ocsp.o
 LIBS += -lssl
 endif
 OBJS += ../src/crypto/crypto_openssl.o
@@ -899,21 +898,6 @@ LIBS += -lsqlite3
 LIBS_h += -lsqlite3
 endif
 
-ifdef CONFIG_FST
-CFLAGS += -DCONFIG_FST
-OBJS += ../src/fst/fst.o
-OBJS += ../src/fst/fst_group.o
-OBJS += ../src/fst/fst_iface.o
-OBJS += ../src/fst/fst_session.o
-OBJS += ../src/fst/fst_ctrl_aux.o
-ifdef CONFIG_FST_TEST
-CFLAGS += -DCONFIG_FST_TEST
-endif
-ifndef CONFIG_NO_CTRL_IFACE
-OBJS += ../src/fst/fst_ctrl_iface.o
-endif
-endif
-
 ALL=hostapd hostapd_cli
 
 all: verify_config $(ALL)
diff --git a/hostapd/android.config b/hostapd/android.config
index 8431c4f..938aa54 100644
--- a/hostapd/android.config
+++ b/hostapd/android.config
@@ -182,6 +182,3 @@ CONFIG_OS=unix
 
 # Enable AP
 CONFIG_AP=y
-
-# Enable Fast Session Transfer (FST)
-CONFIG_FST=y
diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 14ddad7..49f8320 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -2793,14 +2793,6 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		conf->require_ht = atoi(pos);
 	} else if (os_strcmp(buf, "obss_interval") == 0) {
 		conf->obss_interval = atoi(pos);
-	} else if (os_strcmp(buf, "ht2040_coex_disable") == 0) {
-		int val = atoi(pos);
-		if (val == 1 || val == 0) {
-			conf->ht2040_coex_disable = val;
-		} else {
-			wpa_printf(MSG_ERROR, "ht2040_coex_disable: "
-				   "invalid value: %d", val);
-		}
 #endif /* CONFIG_IEEE80211N */
 #ifdef CONFIG_IEEE80211AC
 	} else if (os_strcmp(buf, "ieee80211ac") == 0) {
@@ -3295,36 +3287,6 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 
 		wpabuf_free(bss->vendor_elements);
 		bss->vendor_elements = elems;
-	} else if (os_strcmp(buf, "assocresp_elements") == 0) {
-		struct wpabuf *elems;
-		size_t len = os_strlen(pos);
-		if (len & 0x01) {
-			wpa_printf(MSG_ERROR,
-				   "Line %d: Invalid assocresp_elements '%s'",
-				   line, pos);
-			return 1;
-		}
-		len /= 2;
-		if (len == 0) {
-			wpabuf_free(bss->assocresp_elements);
-			bss->assocresp_elements = NULL;
-			return 0;
-		}
-
-		elems = wpabuf_alloc(len);
-		if (elems == NULL)
-			return 1;
-
-		if (hexstr2bin(pos, wpabuf_put(elems, len), len)) {
-			wpabuf_free(elems);
-			wpa_printf(MSG_ERROR,
-				   "Line %d: Invalid assocresp_elements '%s'",
-				   line, pos);
-			return 1;
-		}
-
-		wpabuf_free(bss->assocresp_elements);
-		bss->assocresp_elements = elems;
 	} else if (os_strcmp(buf, "sae_anti_clogging_threshold") == 0) {
 		bss->sae_anti_clogging_threshold = atoi(pos);
 	} else if (os_strcmp(buf, "sae_groups") == 0) {
@@ -3347,64 +3309,6 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 	} else if (os_strcmp(buf, "wowlan_triggers") == 0) {
 		os_free(bss->wowlan_triggers);
 		bss->wowlan_triggers = os_strdup(pos);
-#ifdef CONFIG_FST
-	} else if (os_strcmp(buf, "fst_group_id") == 0) {
-		size_t len = os_strlen(pos);
-
-		if (!len || len >= sizeof(conf->fst_cfg.group_id)) {
-			wpa_printf(MSG_ERROR,
-				   "Line %d: Invalid fst_group_id value '%s'",
-				   line, pos);
-			return 1;
-		}
-
-		if (conf->fst_cfg.group_id[0]) {
-			wpa_printf(MSG_ERROR,
-				   "Line %d: Duplicate fst_group value '%s'",
-				   line, pos);
-			return 1;
-		}
-
-		os_strlcpy(conf->fst_cfg.group_id, pos,
-			   sizeof(conf->fst_cfg.group_id));
-	} else if (os_strcmp(buf, "fst_priority") == 0) {
-		char *endp;
-		long int val;
-
-		if (!*pos) {
-			wpa_printf(MSG_ERROR,
-				   "Line %d: fst_priority value not supplied (expected 1..%u)",
-				   line, FST_MAX_PRIO_VALUE);
-			return -1;
-		}
-
-		val = strtol(pos, &endp, 0);
-		if (*endp || val < 1 || val > FST_MAX_PRIO_VALUE) {
-			wpa_printf(MSG_ERROR,
-				   "Line %d: Invalid fst_priority %ld (%s) (expected 1..%u)",
-				   line, val, pos, FST_MAX_PRIO_VALUE);
-			return 1;
-		}
-		conf->fst_cfg.priority = (u8) val;
-	} else if (os_strcmp(buf, "fst_llt") == 0) {
-		char *endp;
-		long int val;
-
-		if (!*pos) {
-			wpa_printf(MSG_ERROR,
-				   "Line %d: fst_llt value not supplied (expected 1..%u)",
-				   line, FST_MAX_LLT_MS);
-			return -1;
-		}
-		val = strtol(pos, &endp, 0);
-		if (*endp || val < 1 || val > FST_MAX_LLT_MS) {
-			wpa_printf(MSG_ERROR,
-				   "Line %d: Invalid fst_llt %ld (%s) (expected 1..%u)",
-				   line, val, pos, FST_MAX_LLT_MS);
-			return 1;
-		}
-		conf->fst_cfg.llt = (u32) val;
-#endif /* CONFIG_FST */
 	} else {
 		wpa_printf(MSG_ERROR,
 			   "Line %d: unknown configuration item '%s'",
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index da7f0b3..9dc7de2 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -43,13 +43,10 @@
 #include "ap/beacon.h"
 #include "wps/wps_defs.h"
 #include "wps/wps.h"
-#include "fst/fst_ctrl_iface.h"
 #include "config_file.h"
 #include "ctrl_iface.h"
 
 
-#define HOSTAPD_CLI_DUP_VALUE_MAX_LEN 256
-
 struct wpa_ctrl_dst {
 	struct wpa_ctrl_dst *next;
 	struct sockaddr_un addr;
@@ -60,7 +57,6 @@ struct wpa_ctrl_dst {
 
 
 static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
-				    enum wpa_msg_type type,
 				    const char *buf, size_t len);
 
 
@@ -1059,97 +1055,6 @@ static int hostapd_ctrl_iface_bss_tm_req(struct hostapd_data *hapd,
 #endif /* CONFIG_WNM */
 
 
-static int hostapd_ctrl_iface_get_key_mgmt(struct hostapd_data *hapd,
-					   char *buf, size_t buflen)
-{
-	int ret = 0;
-	char *pos, *end;
-
-	pos = buf;
-	end = buf + buflen;
-
-	WPA_ASSERT(hapd->conf->wpa_key_mgmt);
-
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK) {
-		ret = os_snprintf(pos, end - pos, "WPA-PSK ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X) {
-		ret = os_snprintf(pos, end - pos, "WPA-EAP ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-#ifdef CONFIG_IEEE80211R
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_PSK) {
-		ret = os_snprintf(pos, end - pos, "FT-PSK ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_IEEE8021X) {
-		ret = os_snprintf(pos, end - pos, "FT-EAP ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-#ifdef CONFIG_SAE
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_SAE) {
-		ret = os_snprintf(pos, end - pos, "FT-SAE ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-#endif /* CONFIG_SAE */
-#endif /* CONFIG_IEEE80211R */
-#ifdef CONFIG_IEEE80211W
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK_SHA256) {
-		ret = os_snprintf(pos, end - pos, "WPA-PSK-SHA256 ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X_SHA256) {
-		ret = os_snprintf(pos, end - pos, "WPA-EAP-SHA256 ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-#endif /* CONFIG_IEEE80211W */
-#ifdef CONFIG_SAE
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_SAE) {
-		ret = os_snprintf(pos, end - pos, "SAE ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-#endif /* CONFIG_SAE */
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X_SUITE_B) {
-		ret = os_snprintf(pos, end - pos, "WPA-EAP-SUITE-B ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-	if (hapd->conf->wpa_key_mgmt &
-	    WPA_KEY_MGMT_IEEE8021X_SUITE_B_192) {
-		ret = os_snprintf(pos, end - pos,
-				  "WPA-EAP-SUITE-B-192 ");
-		if (os_snprintf_error(end - pos, ret))
-			return pos - buf;
-		pos += ret;
-	}
-
-	if (pos > buf && *(pos - 1) == ' ') {
-		*(pos - 1) = '\0';
-		pos--;
-	}
-
-	return pos - buf;
-}
-
-
 static int hostapd_ctrl_iface_get_config(struct hostapd_data *hapd,
 					 char *buf, size_t buflen)
 {
@@ -1205,7 +1110,76 @@ static int hostapd_ctrl_iface_get_config(struct hostapd_data *hapd,
 			return pos - buf;
 		pos += ret;
 
-		pos += hostapd_ctrl_iface_get_key_mgmt(hapd, pos, end - pos);
+		if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK) {
+			ret = os_snprintf(pos, end - pos, "WPA-PSK ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+		if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X) {
+			ret = os_snprintf(pos, end - pos, "WPA-EAP ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+#ifdef CONFIG_IEEE80211R
+		if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_PSK) {
+			ret = os_snprintf(pos, end - pos, "FT-PSK ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+		if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_IEEE8021X) {
+			ret = os_snprintf(pos, end - pos, "FT-EAP ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+#ifdef CONFIG_SAE
+		if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_SAE) {
+			ret = os_snprintf(pos, end - pos, "FT-SAE ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+#endif /* CONFIG_SAE */
+#endif /* CONFIG_IEEE80211R */
+#ifdef CONFIG_IEEE80211W
+		if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK_SHA256) {
+			ret = os_snprintf(pos, end - pos, "WPA-PSK-SHA256 ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+		if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X_SHA256) {
+			ret = os_snprintf(pos, end - pos, "WPA-EAP-SHA256 ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+#endif /* CONFIG_IEEE80211W */
+#ifdef CONFIG_SAE
+		if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_SAE) {
+			ret = os_snprintf(pos, end - pos, "SAE ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+#endif /* CONFIG_SAE */
+		if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X_SUITE_B) {
+			ret = os_snprintf(pos, end - pos, "WPA-EAP-SUITE-B ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+		if (hapd->conf->wpa_key_mgmt &
+		    WPA_KEY_MGMT_IEEE8021X_SUITE_B_192) {
+			ret = os_snprintf(pos, end - pos,
+					  "WPA-EAP-SUITE-B-192 ");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
 
 		ret = os_snprintf(pos, end - pos, "\n");
 		if (os_snprintf_error(end - pos, ret))
@@ -1872,60 +1846,75 @@ static int hostapd_ctrl_iface_vendor(struct hostapd_data *hapd, char *cmd,
 	return ret;
 }
 
-static int hostapd_ctrl_iface_log_level(struct hostapd_data *hapd, char *cmd,
-					char *buf, size_t buflen)
+
+static void hostapd_ctrl_iface_receive(int sock, void *eloop_ctx,
+				       void *sock_ctx)
 {
-	char *pos, *end, *stamp;
-	int ret;
+	struct hostapd_data *hapd = eloop_ctx;
 
-	/* cmd: "LOG_LEVEL [<level>]" */
-	if (*cmd == '\0') {
-		pos = buf;
-		end = buf + buflen;
-		ret = os_snprintf(pos, end - pos, "Current level: %s\n"
-				  "Timestamp: %d\n",
-				  debug_level_str(wpa_debug_level),
-				  wpa_debug_timestamp);
-		if (os_snprintf_error(end - pos, ret))
-			ret = 0;
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+	char *buf;
+	char buffer[4096];
+#else
+	char buf[4096];
+#endif
 
-		return ret;
+	int res;
+	struct sockaddr_un from;
+	socklen_t fromlen = sizeof(from);
+	char *reply;
+	const int reply_size = 4096;
+	int reply_len;
+	int level = MSG_DEBUG;
+
+// android5.1 the command may contain the IFNAME
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+	res = recvfrom(sock, buffer, sizeof(buffer) - 1, 0,
+		(struct sockaddr *) &from, &fromlen);
+	if (res < 0) {
+		wpa_printf(MSG_ERROR, "recvfrom(ctrl_iface): %s",
+			   strerror(errno));
+		return;
 	}
+	buffer[res] = '\0';
 
-	while (*cmd == ' ')
-		cmd++;
+	buf = buffer;
 
-	stamp = os_strchr(cmd, ' ');
-	if (stamp) {
-		*stamp++ = '\0';
-		while (*stamp == ' ') {
-			stamp++;
+	wpa_printf(level, "Recv command: %s ", buffer);
+	if (os_strncmp(buffer, "IFNAME=", 7) == 0) {
+		buf = os_strchr(buffer + 7, ' ');
+		if (buf) {
+			*buf++ = '\0';
 		}
 	}
 
-	if (os_strlen(cmd)) {
-		int level = str_to_debug_level(cmd);
-		if (level < 0)
-			return -1;
-		wpa_debug_level = level;
+	wpa_printf(level, "222Recv command: %s ", buf);
+	if (os_strcmp(buf, "PING") == 0)
+		level = MSG_EXCESSIVE;
+	wpa_hexdump_ascii(level, "RX ctrl_iface", (u8 *) buf, res);
+#else
+	res = recvfrom(sock, buf, sizeof(buf) - 1, 0,
+		       (struct sockaddr *) &from, &fromlen);
+	if (res < 0) {
+		wpa_printf(MSG_ERROR, "recvfrom(ctrl_iface): %s",
+			   strerror(errno));
+		return;
 	}
+	buf[res] = '\0';
+	if (os_strcmp(buf, "PING") == 0)
+		level = MSG_EXCESSIVE;
+	wpa_hexdump_ascii(level, "RX ctrl_iface", (u8 *) buf, res);
+#endif
 
-	if (stamp && os_strlen(stamp))
-		wpa_debug_timestamp = atoi(stamp);
-
-	os_memcpy(buf, "OK\n", 3);
-	return 3;
-}
-
-
-
-static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
-					      char *buf, char *reply,
-					      int reply_size,
-					      struct sockaddr_un *from,
-					      socklen_t fromlen)
-{
-	int reply_len, res;
+	reply = os_malloc(reply_size);
+	if (reply == NULL) {
+		if (sendto(sock, "FAIL\n", 5, 0, (struct sockaddr *) &from,
+			   fromlen) < 0) {
+			wpa_printf(MSG_DEBUG, "CTRL: sendto failed: %s",
+				   strerror(errno));
+		}
+		return;
+	}
 
 	os_memcpy(reply, "OK\n", 3);
 	reply_len = 3;
@@ -1983,13 +1972,13 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
 							reply_size);
 	} else if (os_strcmp(buf, "ATTACH") == 0) {
-		if (hostapd_ctrl_iface_attach(hapd, from, fromlen))
+		if (hostapd_ctrl_iface_attach(hapd, &from, fromlen))
 			reply_len = -1;
 	} else if (os_strcmp(buf, "DETACH") == 0) {
-		if (hostapd_ctrl_iface_detach(hapd, from, fromlen))
+		if (hostapd_ctrl_iface_detach(hapd, &from, fromlen))
 			reply_len = -1;
 	} else if (os_strncmp(buf, "LEVEL ", 6) == 0) {
-		if (hostapd_ctrl_iface_level(hapd, from, fromlen,
+		if (hostapd_ctrl_iface_level(hapd, &from, fromlen,
 						    buf + 6))
 			reply_len = -1;
 	} else if (os_strncmp(buf, "NEW_STA ", 8) == 0) {
@@ -2131,14 +2120,18 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strncmp(buf, "VENDOR ", 7) == 0) {
 		reply_len = hostapd_ctrl_iface_vendor(hapd, buf + 7, reply,
 						      reply_size);
-	} else if (os_strncmp(buf, "LOG_LEVEL", 9) == 0) {
-		reply_len = hostapd_ctrl_iface_log_level(
-			hapd, buf + 9, reply, reply_size);
 	} else if (os_strcmp(buf, "ERP_FLUSH") == 0) {
 		ieee802_1x_erp_flush(hapd);
 #ifdef RADIUS_SERVER
 		radius_server_erp_flush(hapd->radius_srv);
 #endif /* RADIUS_SERVER */
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+	} else if (os_strncmp(buf, "DRIVER ", 7) == 0) {
+		if (!hapd->driver->ap_priv_cmd)
+			reply_len = -1;
+		else
+			reply_len = hapd->driver->ap_priv_cmd(hapd->drv_priv, buf + 7, reply, reply_size);
+#endif
 	} else {
 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
@@ -2148,50 +2141,6 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 		os_memcpy(reply, "FAIL\n", 5);
 		reply_len = 5;
 	}
-
-	return reply_len;
-}
-
-
-static void hostapd_ctrl_iface_receive(int sock, void *eloop_ctx,
-				       void *sock_ctx)
-{
-	struct hostapd_data *hapd = eloop_ctx;
-	char buf[4096];
-	int res;
-	struct sockaddr_un from;
-	socklen_t fromlen = sizeof(from);
-	char *reply;
-	const int reply_size = 4096;
-	int reply_len;
-	int level = MSG_DEBUG;
-
-	res = recvfrom(sock, buf, sizeof(buf) - 1, 0,
-		       (struct sockaddr *) &from, &fromlen);
-	if (res < 0) {
-		wpa_printf(MSG_ERROR, "recvfrom(ctrl_iface): %s",
-			   strerror(errno));
-		return;
-	}
-	buf[res] = '\0';
-	if (os_strcmp(buf, "PING") == 0)
-		level = MSG_EXCESSIVE;
-	wpa_hexdump_ascii(level, "RX ctrl_iface", (u8 *) buf, res);
-
-	reply = os_malloc(reply_size);
-	if (reply == NULL) {
-		if (sendto(sock, "FAIL\n", 5, 0, (struct sockaddr *) &from,
-			   fromlen) < 0) {
-			wpa_printf(MSG_DEBUG, "CTRL: sendto failed: %s",
-				   strerror(errno));
-		}
-		return;
-	}
-
-	reply_len = hostapd_ctrl_iface_receive_process(hapd, buf,
-						       reply, reply_size,
-						       &from, fromlen);
-
 	if (sendto(sock, reply, reply_len, 0, (struct sockaddr *) &from,
 		   fromlen) < 0) {
 		wpa_printf(MSG_DEBUG, "CTRL: sendto failed: %s",
@@ -2229,7 +2178,7 @@ static void hostapd_ctrl_iface_msg_cb(void *ctx, int level,
 	struct hostapd_data *hapd = ctx;
 	if (hapd == NULL)
 		return;
-	hostapd_ctrl_iface_send(hapd, level, type, txt, len);
+	hostapd_ctrl_iface_send(hapd, level, txt, len);
 }
 
 
@@ -2452,58 +2401,6 @@ static int hostapd_ctrl_iface_remove(struct hapd_interfaces *interfaces,
 }
 
 
-static int hostapd_global_ctrl_iface_attach(struct hapd_interfaces *interfaces,
-					    struct sockaddr_un *from,
-					    socklen_t fromlen)
-{
-	struct wpa_ctrl_dst *dst;
-
-	dst = os_zalloc(sizeof(*dst));
-	if (dst == NULL)
-		return -1;
-	os_memcpy(&dst->addr, from, sizeof(struct sockaddr_un));
-	dst->addrlen = fromlen;
-	dst->debug_level = MSG_INFO;
-	dst->next = interfaces->global_ctrl_dst;
-	interfaces->global_ctrl_dst = dst;
-	wpa_hexdump(MSG_DEBUG, "CTRL_IFACE monitor attached (global)",
-		    from->sun_path,
-		    fromlen - offsetof(struct sockaddr_un, sun_path));
-	return 0;
-}
-
-
-static int hostapd_global_ctrl_iface_detach(struct hapd_interfaces *interfaces,
-					    struct sockaddr_un *from,
-					    socklen_t fromlen)
-{
-	struct wpa_ctrl_dst *dst, *prev = NULL;
-
-	dst = interfaces->global_ctrl_dst;
-	while (dst) {
-		if (fromlen == dst->addrlen &&
-		    os_memcmp(from->sun_path, dst->addr.sun_path,
-			      fromlen - offsetof(struct sockaddr_un, sun_path))
-		    == 0) {
-			wpa_hexdump(MSG_DEBUG,
-				    "CTRL_IFACE monitor detached (global)",
-				    from->sun_path,
-				    fromlen -
-				    offsetof(struct sockaddr_un, sun_path));
-			if (prev == NULL)
-				interfaces->global_ctrl_dst = dst->next;
-			else
-				prev->next = dst->next;
-			os_free(dst);
-			return 0;
-		}
-		prev = dst;
-		dst = dst->next;
-	}
-	return -1;
-}
-
-
 static void hostapd_ctrl_iface_flush(struct hapd_interfaces *interfaces)
 {
 #ifdef CONFIG_WPS_TESTING
@@ -2514,214 +2411,6 @@ static void hostapd_ctrl_iface_flush(struct hapd_interfaces *interfaces)
 }
 
 
-#ifdef CONFIG_FST
-
-static int
-hostapd_global_ctrl_iface_fst_attach(struct hapd_interfaces *interfaces,
-				     const char *cmd)
-{
-	char ifname[IFNAMSIZ + 1];
-	struct fst_iface_cfg cfg;
-	struct hostapd_data *hapd;
-	struct fst_wpa_obj iface_obj;
-
-	if (!fst_parse_attach_command(cmd, ifname, sizeof(ifname), &cfg)) {
-		hapd = hostapd_get_iface(interfaces, ifname);
-		if (hapd) {
-			if (hapd->iface->fst) {
-				wpa_printf(MSG_INFO, "FST: Already attached");
-				return -1;
-			}
-			fst_hostapd_fill_iface_obj(hapd, &iface_obj);
-			hapd->iface->fst = fst_attach(ifname, hapd->own_addr,
-						      &iface_obj, &cfg);
-			if (hapd->iface->fst)
-				return 0;
-		}
-	}
-
-	return -EINVAL;
-}
-
-
-static int
-hostapd_global_ctrl_iface_fst_detach(struct hapd_interfaces *interfaces,
-				     const char *cmd)
-{
-	char ifname[IFNAMSIZ + 1];
-	struct hostapd_data * hapd;
-
-	if (!fst_parse_detach_command(cmd, ifname, sizeof(ifname))) {
-		hapd = hostapd_get_iface(interfaces, ifname);
-		if (hapd) {
-			if (!fst_iface_detach(ifname)) {
-				hapd->iface->fst = NULL;
-				hapd->iface->fst_ies = NULL;
-				return 0;
-			}
-		}
-	}
-
-	return -EINVAL;
-}
-
-#endif /* CONFIG_FST */
-
-
-static struct hostapd_data *
-hostapd_interfaces_get_hapd(struct hapd_interfaces *interfaces,
-			    const char *ifname)
-{
-	size_t i, j;
-
-	for (i = 0; i < interfaces->count; i++) {
-		struct hostapd_iface *iface = interfaces->iface[i];
-
-		for (j = 0; j < iface->num_bss; j++) {
-			struct hostapd_data *hapd;
-
-			hapd = iface->bss[j];
-			if (os_strcmp(ifname, hapd->conf->iface) == 0)
-				return hapd;
-		}
-	}
-
-	return NULL;
-}
-
-
-static int hostapd_ctrl_iface_dup_param(struct hostapd_data *src_hapd,
-					struct hostapd_data *dst_hapd,
-					char *param)
-{
-	int res;
-	char *value;
-
-	value = os_zalloc(HOSTAPD_CLI_DUP_VALUE_MAX_LEN);
-	if (!value) {
-		wpa_printf(MSG_ERROR,
-			   "DUP: cannot allocate buffer to stringify %s",
-			   param);
-		goto error_return;
-	}
-
-	if (os_strcmp(param, "wpa") == 0) {
-		os_snprintf(value, HOSTAPD_CLI_DUP_VALUE_MAX_LEN, "%d",
-			    src_hapd->conf->wpa);
-	} else if (os_strcmp(param, "wpa_key_mgmt") == 0 &&
-		   src_hapd->conf->wpa_key_mgmt) {
-		res = hostapd_ctrl_iface_get_key_mgmt(
-			src_hapd, value, HOSTAPD_CLI_DUP_VALUE_MAX_LEN);
-		if (os_snprintf_error(HOSTAPD_CLI_DUP_VALUE_MAX_LEN, res))
-			goto error_stringify;
-	} else if (os_strcmp(param, "wpa_pairwise") == 0 &&
-		   src_hapd->conf->wpa_pairwise) {
-		res = wpa_write_ciphers(value,
-					value + HOSTAPD_CLI_DUP_VALUE_MAX_LEN,
-					src_hapd->conf->wpa_pairwise, " ");
-		if (res < 0)
-			goto error_stringify;
-	} else if (os_strcmp(param, "rsn_pairwise") == 0 &&
-		   src_hapd->conf->rsn_pairwise) {
-		res = wpa_write_ciphers(value,
-					value + HOSTAPD_CLI_DUP_VALUE_MAX_LEN,
-					src_hapd->conf->rsn_pairwise, " ");
-		if (res < 0)
-			goto error_stringify;
-	} else if (os_strcmp(param, "wpa_passphrase") == 0 &&
-		   src_hapd->conf->ssid.wpa_passphrase) {
-		os_snprintf(value, HOSTAPD_CLI_DUP_VALUE_MAX_LEN, "%s",
-			    src_hapd->conf->ssid.wpa_passphrase);
-	} else if (os_strcmp(param, "wpa_psk") == 0 &&
-		   src_hapd->conf->ssid.wpa_psk_set) {
-		wpa_snprintf_hex(value, HOSTAPD_CLI_DUP_VALUE_MAX_LEN,
-			src_hapd->conf->ssid.wpa_psk->psk, PMK_LEN);
-	} else {
-		wpa_printf(MSG_WARNING, "DUP: %s cannot be duplicated", param);
-		goto error_return;
-	}
-
-	res = hostapd_set_iface(dst_hapd->iconf, dst_hapd->conf, param, value);
-	os_free(value);
-	return res;
-
-error_stringify:
-	wpa_printf(MSG_ERROR, "DUP: cannot stringify %s", param);
-error_return:
-	os_free(value);
-	return -1;
-}
-
-
-static int
-hostapd_global_ctrl_iface_dup_network(struct hapd_interfaces *interfaces,
-				      char *cmd)
-{
-	char *p_start = cmd, *p_end;
-	struct hostapd_data *src_hapd, *dst_hapd;
-
-	/* cmd: "<src ifname> <dst ifname> <variable name> */
-
-	p_end = os_strchr(p_start, ' ');
-	if (!p_end) {
-		wpa_printf(MSG_ERROR, "DUP: no src ifname found in cmd: '%s'",
-			   cmd);
-		return -1;
-	}
-
-	*p_end = '\0';
-	src_hapd = hostapd_interfaces_get_hapd(interfaces, p_start);
-	if (!src_hapd) {
-		wpa_printf(MSG_ERROR, "DUP: no src ifname found: '%s'",
-			   p_start);
-		return -1;
-	}
-
-	p_start = p_end + 1;
-	p_end = os_strchr(p_start, ' ');
-	if (!p_end) {
-		wpa_printf(MSG_ERROR, "DUP: no dst ifname found in cmd: '%s'",
-			   cmd);
-		return -1;
-	}
-
-	*p_end = '\0';
-	dst_hapd = hostapd_interfaces_get_hapd(interfaces, p_start);
-	if (!dst_hapd) {
-		wpa_printf(MSG_ERROR, "DUP: no dst ifname found: '%s'",
-			   p_start);
-		return -1;
-	}
-
-	p_start = p_end + 1;
-	return hostapd_ctrl_iface_dup_param(src_hapd, dst_hapd, p_start);
-}
-
-
-static int hostapd_global_ctrl_iface_ifname(struct hapd_interfaces *interfaces,
-					    const char *ifname,
-					    char *buf, char *reply,
-					    int reply_size,
-					    struct sockaddr_un *from,
-					    socklen_t fromlen)
-{
-	struct hostapd_data *hapd;
-
-	hapd = hostapd_interfaces_get_hapd(interfaces, ifname);
-	if (hapd == NULL) {
-		int res;
-
-		res = os_snprintf(reply, reply_size, "FAIL-NO-IFNAME-MATCH\n");
-		if (os_snprintf_error(reply_size, res))
-			return -1;
-		return res;
-	}
-
-	return hostapd_ctrl_iface_receive_process(hapd, buf, reply,reply_size,
-						  from, fromlen);
-}
-
-
 static void hostapd_global_ctrl_iface_receive(int sock, void *eloop_ctx,
 					      void *sock_ctx)
 {
@@ -2730,9 +2419,8 @@ static void hostapd_global_ctrl_iface_receive(int sock, void *eloop_ctx,
 	int res;
 	struct sockaddr_un from;
 	socklen_t fromlen = sizeof(from);
-	char *reply;
+	char reply[24];
 	int reply_len;
-	const int reply_size = 4096;
 
 	res = recvfrom(sock, buf, sizeof(buf) - 1, 0,
 		       (struct sockaddr *) &from, &fromlen);
@@ -2744,31 +2432,9 @@ static void hostapd_global_ctrl_iface_receive(int sock, void *eloop_ctx,
 	buf[res] = '\0';
 	wpa_printf(MSG_DEBUG, "Global ctrl_iface command: %s", buf);
 
-	reply = os_malloc(reply_size);
-	if (reply == NULL) {
-		if (sendto(sock, "FAIL\n", 5, 0, (struct sockaddr *) &from,
-			   fromlen) < 0) {
-			wpa_printf(MSG_DEBUG, "CTRL: sendto failed: %s",
-				   strerror(errno));
-		}
-		return;
-	}
-
 	os_memcpy(reply, "OK\n", 3);
 	reply_len = 3;
 
-	if (os_strncmp(buf, "IFNAME=", 7) == 0) {
-		char *pos = os_strchr(buf + 7, ' ');
-
-		if (pos) {
-			*pos++ = '\0';
-			reply_len = hostapd_global_ctrl_iface_ifname(
-				interfaces, buf + 7, pos, reply, reply_size,
-				&from, fromlen);
-			goto send_reply;
-		}
-	}
-
 	if (os_strcmp(buf, "PING") == 0) {
 		os_memcpy(reply, "PONG\n", 5);
 		reply_len = 5;
@@ -2783,47 +2449,18 @@ static void hostapd_global_ctrl_iface_receive(int sock, void *eloop_ctx,
 	} else if (os_strncmp(buf, "REMOVE ", 7) == 0) {
 		if (hostapd_ctrl_iface_remove(interfaces, buf + 7) < 0)
 			reply_len = -1;
-	} else if (os_strcmp(buf, "ATTACH") == 0) {
-		if (hostapd_global_ctrl_iface_attach(interfaces, &from,
-						     fromlen))
-			reply_len = -1;
-	} else if (os_strcmp(buf, "DETACH") == 0) {
-		if (hostapd_global_ctrl_iface_detach(interfaces, &from,
-			fromlen))
-			reply_len = -1;
 #ifdef CONFIG_MODULE_TESTS
 	} else if (os_strcmp(buf, "MODULE_TESTS") == 0) {
 		int hapd_module_tests(void);
 		if (hapd_module_tests() < 0)
 			reply_len = -1;
 #endif /* CONFIG_MODULE_TESTS */
-#ifdef CONFIG_FST
-	} else if (os_strncmp(buf, "FST-ATTACH ", 11) == 0) {
-		if (!hostapd_global_ctrl_iface_fst_attach(interfaces, buf + 11))
-			reply_len = os_snprintf(reply, reply_size, "OK\n");
-		else
-			reply_len = -1;
-	} else if (os_strncmp(buf, "FST-DETACH ", 11) == 0) {
-		if (!hostapd_global_ctrl_iface_fst_detach(interfaces, buf + 11))
-			reply_len = os_snprintf(reply, reply_size, "OK\n");
-		else
-			reply_len = -1;
-	} else if (os_strncmp(buf, "FST-MANAGER ", 12) == 0) {
-		reply_len = fst_ctrl_iface_receive(buf + 12, reply, reply_size);
-#endif /* CONFIG_FST */
-	} else if (os_strncmp(buf, "DUP_NETWORK ", 12) == 0) {
-		if (!hostapd_global_ctrl_iface_dup_network(interfaces,
-							   buf + 12))
-			reply_len = os_snprintf(reply, reply_size, "OK\n");
-		else
-			reply_len = -1;
 	} else {
 		wpa_printf(MSG_DEBUG, "Unrecognized global ctrl_iface command "
 			   "ignored");
 		reply_len = -1;
 	}
 
-send_reply:
 	if (reply_len < 0) {
 		os_memcpy(reply, "FAIL\n", 5);
 		reply_len = 5;
@@ -2834,7 +2471,6 @@ send_reply:
 		wpa_printf(MSG_DEBUG, "CTRL: sendto failed: %s",
 			   strerror(errno));
 	}
-	os_free(reply);
 }
 
 
@@ -2972,7 +2608,6 @@ fail:
 void hostapd_global_ctrl_iface_deinit(struct hapd_interfaces *interfaces)
 {
 	char *fname = NULL;
-	struct wpa_ctrl_dst *dst, *prev;
 
 	if (interfaces->global_ctrl_sock > -1) {
 		eloop_unregister_read_sock(interfaces->global_ctrl_sock);
@@ -2997,23 +2632,13 @@ void hostapd_global_ctrl_iface_deinit(struct hapd_interfaces *interfaces)
 					   strerror(errno));
 			}
 		}
-	}
-
-	os_free(interfaces->global_iface_path);
-	interfaces->global_iface_path = NULL;
-
-	dst = interfaces->global_ctrl_dst;
-	interfaces->global_ctrl_dst = NULL;
-	while (dst) {
-		prev = dst;
-		dst = dst->next;
-		os_free(prev);
+		os_free(interfaces->global_iface_path);
+		interfaces->global_iface_path = NULL;
 	}
 }
 
 
 static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
-				    enum wpa_msg_type type,
 				    const char *buf, size_t len)
 {
 	struct wpa_ctrl_dst *dst, *next;
@@ -3021,17 +2646,9 @@ static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
 	int idx;
 	struct iovec io[2];
 	char levelstr[10];
-	int s;
 
-	if (type != WPA_MSG_ONLY_GLOBAL) {
-		s = hapd->ctrl_sock;
-		dst = hapd->ctrl_dst;
-	} else {
-		s = hapd->iface->interfaces->global_ctrl_sock;
-		dst = hapd->iface->interfaces->global_ctrl_dst;
-	}
-
-	if (s < 0 || dst == NULL)
+	dst = hapd->ctrl_dst;
+	if (hapd->ctrl_sock < 0 || dst == NULL)
 		return;
 
 	os_snprintf(levelstr, sizeof(levelstr), "<%d>", level);
@@ -3052,22 +2669,16 @@ static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
 				    offsetof(struct sockaddr_un, sun_path));
 			msg.msg_name = &dst->addr;
 			msg.msg_namelen = dst->addrlen;
-			if (sendmsg(s, &msg, 0) < 0) {
+			if (sendmsg(hapd->ctrl_sock, &msg, 0) < 0) {
 				int _errno = errno;
 				wpa_printf(MSG_INFO, "CTRL_IFACE monitor[%d]: "
 					   "%d - %s",
 					   idx, errno, strerror(errno));
 				dst->errors++;
 				if (dst->errors > 10 || _errno == ENOENT) {
-					if (type != WPA_MSG_ONLY_GLOBAL)
-						hostapd_ctrl_iface_detach(
-							hapd, &dst->addr,
-							dst->addrlen);
-					else
-						hostapd_global_ctrl_iface_detach(
-							hapd->iface->interfaces,
-							&dst->addr,
-							dst->addrlen);
+					hostapd_ctrl_iface_detach(
+						hapd, &dst->addr,
+						dst->addrlen);
 				}
 			} else
 				dst->errors = 0;
diff --git a/hostapd/defconfig b/hostapd/defconfig
index 62a0ede..4cde2b5 100644
--- a/hostapd/defconfig
+++ b/hostapd/defconfig
@@ -283,12 +283,6 @@ CONFIG_IPV6=y
 # Enable SQLite database support in hlr_auc_gw, EAP-SIM DB, and eap_user_file
 #CONFIG_SQLITE=y
 
-# Enable Fast Session Transfer (FST)
-#CONFIG_FST=y
-
-# Enable CLI commands for FST testing
-#CONFIG_FST_TEST=y
-
 # Testing options
 # This can be used to enable some testing options (see also the example
 # configuration file) that are really useful only for testing clients that
diff --git a/hostapd/hostapd.conf b/hostapd/hostapd.conf
index 9aa49f5..00fc142 100644
--- a/hostapd/hostapd.conf
+++ b/hostapd/hostapd.conf
@@ -274,13 +274,6 @@ ignore_broadcast_ssid=0
 # one or more elements)
 #vendor_elements=dd0411223301
 
-# Additional vendor specific elements for (Re)Association Response frames
-# This parameter can be used to add additional vendor specific element(s) into
-# the end of the (Re)Association Response frames. The format for these
-# element(s) is a hexdump of the raw information elements (id+len+payload for
-# one or more elements)
-#assocresp_elements=dd0411223301
-
 # TX queue parameters (EDCF / bursting)
 # tx_queue_<queue name>_<param>
 # queues: data0, data1, data2, data3, after_beacon, beacon
@@ -524,14 +517,6 @@ wmm_ac_vo_acm=0
 # no co-existence issues with neighboring devices are found.
 #obss_interval=0
 
-# ht2040_coex_disable: Whether to disable HT20/40 CoEx or not. If this
-# entry is removed, it is same as the value set to 0, i.e., HT20/40
-# CoEx is enabled.
-# 0 = enable (default)
-# 1 = disable
-# Note: HT20/40 CoEx is mandatory for any device supporting HT in the standard.
-#ht2040_coex_disable=0
-
 ##### IEEE 802.11ac related configuration #####################################
 
 # ieee80211ac: Whether IEEE 802.11ac (VHT) is enabled
@@ -1762,32 +1747,6 @@ own_ip_addr=127.0.0.1
 #
 #osu_server_uri=...
 
-##### Fast Session Transfer (FST) support #####################################
-#
-# The options in this section are only available when the build configuration
-# option CONFIG_FST is set while compiling hostapd. They allow this interface
-# to be a part of FST setup.
-#
-# FST is the transfer of a session from a channel to another channel, in the
-# same or different frequency bands.
-#
-# For detals, see IEEE Std 802.11ad-2012.
-
-# Identifier of an FST Group the interface belongs to.
-#fst_group_id=bond0
-
-# Interface priority within the FST Group.
-# Announcing a higher priority for an interface means declaring it more
-# preferable for FST switch.
-# fst_priority is in 1..255 range with 1 being the lowest priority.
-#fst_priority=100
-
-# Default LLT value for this interface in milliseconds. The value used in case
-# no value provided during session setup. Default is 50 ms.
-# fst_llt is in 1..4294967 range (due to spec limitation, see 10.32.2.2
-# Transitioning between states).
-#fst_llt=100
-
 ##### TESTING OPTIONS #########################################################
 #
 # The options in this section are only available when the build configuration
diff --git a/hostapd/hostapd_cli.c b/hostapd/hostapd_cli.c
index 392fcb3..e299183 100644
--- a/hostapd/hostapd_cli.c
+++ b/hostapd/hostapd_cli.c
@@ -97,7 +97,6 @@ static int hostapd_cli_attached = 0;
 #define CONFIG_CTRL_IFACE_DIR "/var/run/hostapd"
 #endif /* CONFIG_CTRL_IFACE_DIR */
 static const char *ctrl_iface_dir = CONFIG_CTRL_IFACE_DIR;
-static const char *client_socket_dir = NULL;
 
 static char *ctrl_ifname = NULL;
 static const char *pid_file = NULL;
@@ -120,8 +119,6 @@ static void usage(void)
 		"   -v           shown version information\n"
 		"   -p<path>     path to find control sockets (default: "
 		"/var/run/hostapd)\n"
-		"   -s<dir_path> dir path to open client sockets (default: "
-		CONFIG_CTRL_IFACE_DIR ")\n"
 		"   -a<file>     run in daemon mode executing the action file "
 		"based on events\n"
 		"                from hostapd\n"
@@ -148,14 +145,7 @@ static struct wpa_ctrl * hostapd_cli_open_connection(const char *ifname)
 		return NULL;
 	snprintf(cfile, flen, "%s/%s", ctrl_iface_dir, ifname);
 
-	if (client_socket_dir && client_socket_dir[0] &&
-	    access(client_socket_dir, F_OK) < 0) {
-		perror(client_socket_dir);
-		free(cfile);
-		return NULL;
-	}
-
-	ctrl_conn = wpa_ctrl_open2(cfile, client_socket_dir);
+	ctrl_conn = wpa_ctrl_open(cfile);
 	free(cfile);
 	return ctrl_conn;
 }
@@ -932,35 +922,6 @@ static int hostapd_cli_cmd_get(struct wpa_ctrl *ctrl, int argc, char *argv[])
 }
 
 
-#ifdef CONFIG_FST
-static int hostapd_cli_cmd_fst(struct wpa_ctrl *ctrl, int argc, char *argv[])
-{
-	char cmd[256];
-	int res;
-	int i;
-	int total;
-
-	if (argc <= 0) {
-		printf("FST command: parameters are required.\n");
-		return -1;
-	}
-
-	total = os_snprintf(cmd, sizeof(cmd), "FST-MANAGER");
-
-	for (i = 0; i < argc; i++) {
-		res = os_snprintf(cmd + total, sizeof(cmd) - total, " %s",
-				  argv[i]);
-		if (os_snprintf_error(sizeof(cmd) - total, res)) {
-			printf("Too long fst command.\n");
-			return -1;
-		}
-		total += res;
-	}
-	return wpa_ctrl_command(ctrl, cmd);
-}
-#endif /* CONFIG_FST */
-
-
 static int hostapd_cli_cmd_chan_switch(struct wpa_ctrl *ctrl,
 				       int argc, char *argv[])
 {
@@ -1041,23 +1002,6 @@ static int hostapd_cli_cmd_vendor(struct wpa_ctrl *ctrl, int argc, char *argv[])
 	return wpa_ctrl_command(ctrl, cmd);
 }
 
-static int hostapd_cli_cmd_log_level(struct wpa_ctrl *ctrl, int argc,
-				     char *argv[])
-{
-	char cmd[256];
-	int res;
-
-	res = os_snprintf(cmd, sizeof(cmd), "LOG_LEVEL%s%s%s%s",
-			  argc >= 1 ? " " : "",
-			  argc >= 1 ? argv[0] : "",
-			  argc == 2 ? " " : "",
-			  argc == 2 ? argv[1] : "");
-	if (os_snprintf_error(sizeof(cmd), res)) {
-		printf("Too long option\n");
-		return -1;
-	}
-	return wpa_ctrl_command(ctrl, cmd);
-}
 
 static int hostapd_cli_cmd_erp_flush(struct wpa_ctrl *ctrl, int argc,
 				     char *argv[])
@@ -1105,9 +1049,6 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	{ "get_config", hostapd_cli_cmd_get_config },
 	{ "help", hostapd_cli_cmd_help },
 	{ "interface", hostapd_cli_cmd_interface },
-#ifdef CONFIG_FST
-	{ "fst", hostapd_cli_cmd_fst },
-#endif /* CONFIG_FST */
 	{ "level", hostapd_cli_cmd_level },
 	{ "license", hostapd_cli_cmd_license },
 	{ "quit", hostapd_cli_cmd_quit },
@@ -1123,7 +1064,6 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	{ "reload", hostapd_cli_cmd_reload },
 	{ "disable", hostapd_cli_cmd_disable },
 	{ "erp_flush", hostapd_cli_cmd_erp_flush },
-	{ "log_level", hostapd_cli_cmd_log_level },
 	{ NULL, NULL }
 };
 
@@ -1345,7 +1285,7 @@ int main(int argc, char *argv[])
 		return -1;
 
 	for (;;) {
-		c = getopt(argc, argv, "a:BhG:i:p:P:s:v");
+		c = getopt(argc, argv, "a:BhG:i:p:v");
 		if (c < 0)
 			break;
 		switch (c) {
@@ -1371,12 +1311,6 @@ int main(int argc, char *argv[])
 		case 'p':
 			ctrl_iface_dir = optarg;
 			break;
-		case 'P':
-			pid_file = optarg;
-			break;
-		case 's':
-			client_socket_dir = optarg;
-			break;
 		default:
 			usage();
 			return -1;
diff --git a/hostapd/main.c b/hostapd/main.c
index 534f182..e36c948 100644
--- a/hostapd/main.c
+++ b/hostapd/main.c
@@ -24,7 +24,6 @@
 #include "ap/hostapd.h"
 #include "ap/ap_config.h"
 #include "ap/ap_drv_ops.h"
-#include "fst/fst.h"
 #include "config_file.h"
 #include "eap_register.h"
 #include "ctrl_iface.h"
@@ -562,7 +561,6 @@ int main(int argc, char *argv[])
 	interfaces.global_iface_path = NULL;
 	interfaces.global_iface_name = NULL;
 	interfaces.global_ctrl_sock = -1;
-	interfaces.global_ctrl_dst = NULL;
 
 	for (;;) {
 		c = getopt(argc, argv, "b:Bde:f:hKP:Ttu:vg:G:");
@@ -667,17 +665,6 @@ int main(int argc, char *argv[])
 		return -1;
 	}
 
-	if (fst_global_init()) {
-		wpa_printf(MSG_ERROR,
-			   "Failed to initialize global FST context");
-		goto out;
-	}
-
-#if defined(CONFIG_FST) && defined(CONFIG_CTRL_IFACE)
-	if (!fst_global_add_ctrl(fst_ctrl_cli))
-		wpa_printf(MSG_WARNING, "Failed to add CLI FST ctrl");
-#endif /* CONFIG_FST && CONFIG_CTRL_IFACE */
-
 	/* Allocate and parse configuration for full interface files */
 	for (i = 0; i < interfaces.count; i++) {
 		interfaces.iface[i] = hostapd_interface_init(&interfaces,
@@ -771,8 +758,6 @@ int main(int argc, char *argv[])
 
 	os_free(bss_config);
 
-	fst_global_deinit();
-
 	os_program_deinit();
 
 	return ret;
diff --git a/hs20/client/Android.mk b/hs20/client/Android.mk
index e4db322..a71e86d 100644
--- a/hs20/client/Android.mk
+++ b/hs20/client/Android.mk
@@ -54,7 +54,6 @@ OBJS += ../../src/crypto/crypto_internal.c
 OBJS += ../../src/crypto/md5-internal.c
 OBJS += ../../src/crypto/sha1-internal.c
 OBJS += ../../src/crypto/sha256-internal.c
-OBJS += ../../src/crypto/tls_openssl_ocsp.c
 
 L_CFLAGS += -DEAP_TLS_OPENSSL
 
diff --git a/hs20/client/Makefile b/hs20/client/Makefile
index fc9b619..94cd5f1 100644
--- a/hs20/client/Makefile
+++ b/hs20/client/Makefile
@@ -76,7 +76,6 @@ LIBS += -lcurl
 endif
 
 CFLAGS += -DEAP_TLS_OPENSSL
-OBJS += ../../src/crypto/tls_openssl_ocsp.o
 LIBS += -lssl -lcrypto
 
 hs20-osu-client: $(OBJS)
diff --git a/hs20/client/est.c b/hs20/client/est.c
index 9f1519b..ec05bc4 100644
--- a/hs20/client/est.c
+++ b/hs20/client/est.c
@@ -16,9 +16,6 @@
 #include <openssl/asn1t.h>
 #include <openssl/x509.h>
 #include <openssl/x509v3.h>
-#ifdef OPENSSL_IS_BORINGSSL
-#include <openssl/buf.h>
-#endif /* OPENSSL_IS_BORINGSSL */
 
 #include "common.h"
 #include "utils/base64.h"
@@ -30,28 +27,12 @@
 static int pkcs7_to_cert(struct hs20_osu_client *ctx, const u8 *pkcs7,
 			 size_t len, char *pem_file, char *der_file)
 {
-#ifdef OPENSSL_IS_BORINGSSL
-	CBS pkcs7_cbs;
-#else /* OPENSSL_IS_BORINGSSL */
 	PKCS7 *p7 = NULL;
 	const unsigned char *p = pkcs7;
-#endif /* OPENSSL_IS_BORINGSSL */
 	STACK_OF(X509) *certs;
 	int i, num, ret = -1;
 	BIO *out = NULL;
 
-#ifdef OPENSSL_IS_BORINGSSL
-	certs = sk_X509_new_null();
-	if (!certs)
-		goto fail;
-	CBS_init(&pkcs7_cbs, pkcs7, len);
-	if (!PKCS7_get_certificates(certs, &pkcs7_cbs)) {
-		wpa_printf(MSG_INFO, "Could not parse PKCS#7 object: %s",
-			   ERR_error_string(ERR_get_error(), NULL));
-		write_result(ctx, "Could not parse PKCS#7 object from EST");
-		goto fail;
-	}
-#else /* OPENSSL_IS_BORINGSSL */
 	p7 = d2i_PKCS7(NULL, &p, len);
 	if (p7 == NULL) {
 		wpa_printf(MSG_INFO, "Could not parse PKCS#7 object: %s",
@@ -71,7 +52,6 @@ static int pkcs7_to_cert(struct hs20_osu_client *ctx, const u8 *pkcs7,
 		certs = NULL;
 		break;
 	}
-#endif /* OPENSSL_IS_BORINGSSL */
 
 	if (!certs || ((num = sk_X509_num(certs)) == 0)) {
 		wpa_printf(MSG_INFO, "No certificates found in PKCS#7 object");
@@ -104,12 +84,7 @@ static int pkcs7_to_cert(struct hs20_osu_client *ctx, const u8 *pkcs7,
 	ret = 0;
 
 fail:
-#ifdef OPENSSL_IS_BORINGSSL
-	if (certs)
-		sk_X509_pop_free(certs, X509_free);
-#else /* OPENSSL_IS_BORINGSSL */
 	PKCS7_free(p7);
-#endif /* OPENSSL_IS_BORINGSSL */
 	if (out)
 		BIO_free_all(out);
 
@@ -335,23 +310,6 @@ static void add_csrattrs(struct hs20_osu_client *ctx, CsrAttrs *csrattrs,
 	if (!csrattrs || ! csrattrs->attrs)
 		return;
 
-#ifdef OPENSSL_IS_BORINGSSL
-	num = sk_num(CHECKED_CAST(_STACK *, STACK_OF(AttrOrOID) *,
-				  csrattrs->attrs));
-	for (i = 0; i < num; i++) {
-		AttrOrOID *ao = sk_value(
-			CHECKED_CAST(_STACK *, const STACK_OF(AttrOrOID) *,
-				     csrattrs->attrs), i);
-		switch (ao->type) {
-		case 0:
-			add_csrattrs_oid(ctx, ao->d.oid, exts);
-			break;
-		case 1:
-			add_csrattrs_attr(ctx, ao->d.attribute, exts);
-			break;
-		}
-	}
-#else /* OPENSSL_IS_BORINGSSL */
 	num = SKM_sk_num(AttrOrOID, csrattrs->attrs);
 	for (i = 0; i < num; i++) {
 		AttrOrOID *ao = SKM_sk_value(AttrOrOID, csrattrs->attrs, i);
@@ -364,7 +322,6 @@ static void add_csrattrs(struct hs20_osu_client *ctx, CsrAttrs *csrattrs,
 			break;
 		}
 	}
-#endif /* OPENSSL_IS_BORINGSSL */
 }
 
 
@@ -383,7 +340,6 @@ static int generate_csr(struct hs20_osu_client *ctx, char *key_pem,
 	STACK_OF(X509_EXTENSION) *exts = NULL;
 	X509_EXTENSION *ex;
 	BIO *out;
-	CONF *ctmp = NULL;
 
 	wpa_printf(MSG_INFO, "Generate RSA private key");
 	write_summary(ctx, "Generate RSA private key");
@@ -465,20 +421,20 @@ static int generate_csr(struct hs20_osu_client *ctx, char *key_pem,
 	if (!exts)
 		goto fail;
 
-	ex = X509V3_EXT_nconf_nid(ctmp, NULL, NID_basic_constraints,
-				  "CA:FALSE");
+	ex = X509V3_EXT_conf_nid(NULL, NULL, NID_basic_constraints,
+				 "CA:FALSE");
 	if (ex == NULL ||
 	    !sk_X509_EXTENSION_push(exts, ex))
 		goto fail;
 
-	ex = X509V3_EXT_nconf_nid(ctmp, NULL, NID_key_usage,
-				  "nonRepudiation,digitalSignature,keyEncipherment");
+	ex = X509V3_EXT_conf_nid(NULL, NULL, NID_key_usage,
+				 "nonRepudiation,digitalSignature,keyEncipherment");
 	if (ex == NULL ||
 	    !sk_X509_EXTENSION_push(exts, ex))
 		goto fail;
 
-	ex = X509V3_EXT_nconf_nid(ctmp, NULL, NID_ext_key_usage,
-				  "1.3.6.1.4.1.40808.1.1.2");
+	ex = X509V3_EXT_conf_nid(NULL, NULL, NID_ext_key_usage,
+				 "1.3.6.1.4.1.40808.1.1.2");
 	if (ex == NULL ||
 	    !sk_X509_EXTENSION_push(exts, ex))
 		goto fail;
@@ -498,9 +454,7 @@ static int generate_csr(struct hs20_osu_client *ctx, char *key_pem,
 		char *txt;
 		size_t rlen;
 
-#if !defined(ANDROID) || !defined(OPENSSL_IS_BORINGSSL)
 		X509_REQ_print(out, req);
-#endif
 		rlen = BIO_ctrl_pending(out);
 		txt = os_malloc(rlen + 1);
 		if (txt) {
@@ -519,9 +473,7 @@ static int generate_csr(struct hs20_osu_client *ctx, char *key_pem,
 		FILE *f = fopen(csr_pem, "w");
 		if (f == NULL)
 			goto fail;
-#if !defined(ANDROID) || !defined(OPENSSL_IS_BORINGSSL)
 		X509_REQ_print_fp(f, req);
-#endif
 		if (!PEM_write_X509_REQ(f, req)) {
 			fclose(f);
 			goto fail;
diff --git a/hs20/client/osu_client.c b/hs20/client/osu_client.c
index a43bd91..0315f7b 100644
--- a/hs20/client/osu_client.c
+++ b/hs20/client/osu_client.c
@@ -2229,7 +2229,8 @@ static int cmd_osu_select(struct hs20_osu_client *ctx, const char *dir,
 		fprintf(f, "</table></a><br><small>BSSID: %s<br>\n"
 			"SSID: %s<br>\n",
 			last->bssid, last->osu_ssid);
-		fprintf(f, "NAI: %s<br>\n", last->osu_nai);
+		if (last->osu_nai)
+			fprintf(f, "NAI: %s<br>\n", last->osu_nai);
 		fprintf(f, "URL: %s<br>\n"
 			"methods:%s%s<br>\n"
 			"</small></p>\n",
@@ -2338,23 +2339,12 @@ static int cmd_signup(struct hs20_osu_client *ctx, int no_prod_assoc,
 		return -1;
 
 	snprintf(fname, sizeof(fname), "%s/osu-info", dir);
-	if (mkdir(fname, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) < 0 &&
-	    errno != EEXIST) {
+	if (mkdir(fname, S_IRWXU | S_IRWXG) < 0 && errno != EEXIST) {
 		wpa_printf(MSG_INFO, "mkdir(%s) failed: %s",
 			   fname, strerror(errno));
 		return -1;
 	}
 
-#ifdef ANDROID
-	/* Allow processes running with Group ID as AID_WIFI
-	 * to read/write files from osu-info directory
-	 */
-	if (chown(fname, -1, AID_WIFI)) {
-		wpa_printf(MSG_INFO, "Could not chown osu-info directory: %s",
-			   strerror(errno));
-	}
-#endif /* ANDROID */
-
 	snprintf(buf, sizeof(buf), "SET osu_dir %s", fname);
 	if (wpa_command(ifname, buf) < 0) {
 		wpa_printf(MSG_INFO, "Failed to configure osu_dir to wpa_supplicant");
diff --git a/src/Makefile b/src/Makefile
index c9e84c1..10e0171 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,5 +1,4 @@
 SUBDIRS=ap common crypto drivers eapol_auth eapol_supp eap_common eap_peer eap_server l2_packet p2p pae radius rsn_supp tls utils wps
-SUBDIRS += fst
 
 all:
 	for d in $(SUBDIRS); do [ -d $$d ] && $(MAKE) -C $$d; done
diff --git a/src/ap/ap_config.c b/src/ap/ap_config.c
index 3e39694..455013a 100644
--- a/src/ap/ap_config.c
+++ b/src/ap/ap_config.c
@@ -554,7 +554,6 @@ void hostapd_config_free_bss(struct hostapd_bss_config *conf)
 #endif /* CONFIG_HS20 */
 
 	wpabuf_free(conf->vendor_elements);
-	wpabuf_free(conf->assocresp_elements);
 
 	os_free(conf->sae_groups);
 
diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
index 254f4bc..c14eeda 100644
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -15,7 +15,6 @@
 #include "common/ieee802_11_defs.h"
 #include "common/ieee802_11_common.h"
 #include "wps/wps.h"
-#include "fst/fst.h"
 
 /**
  * mesh_conf - local MBSS state and settings
@@ -535,7 +534,6 @@ struct hostapd_bss_config {
 #endif /* CONFIG_RADIUS_TEST */
 
 	struct wpabuf *vendor_elements;
-	struct wpabuf *assocresp_elements;
 
 	unsigned int sae_anti_clogging_threshold;
 	int *sae_groups;
@@ -553,7 +551,6 @@ struct hostapd_bss_config {
 	int radio_measurements;
 
 	int vendor_vht;
-	int pbss;
 };
 
 
@@ -624,7 +621,6 @@ struct hostapd_config {
 	int secondary_channel;
 	int require_ht;
 	int obss_interval;
-	int ht2040_coex_disable;
 	u32 vht_capab;
 	int ieee80211ac;
 	int require_vht;
@@ -632,10 +628,6 @@ struct hostapd_config {
 	u8 vht_oper_centr_freq_seg0_idx;
 	u8 vht_oper_centr_freq_seg1_idx;
 
-#ifdef CONFIG_FST
-	struct fst_iface_cfg fst_cfg;
-#endif /* CONFIG_FST */
-
 #ifdef CONFIG_P2P
 	u8 p2p_go_ctwindow;
 #endif /* CONFIG_P2P */
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index b9029bb..f3f7edd 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -81,22 +81,6 @@ int hostapd_build_ap_extra_ies(struct hostapd_data *hapd,
 		wpabuf_put_data(proberesp, buf, pos - buf);
 	}
 
-#ifdef CONFIG_FST
-	if (hapd->iface->fst_ies) {
-		size_t add = wpabuf_len(hapd->iface->fst_ies);
-
-		if (wpabuf_resize(&beacon, add) < 0)
-			goto fail;
-		wpabuf_put_buf(beacon, hapd->iface->fst_ies);
-		if (wpabuf_resize(&proberesp, add) < 0)
-			goto fail;
-		wpabuf_put_buf(proberesp, hapd->iface->fst_ies);
-		if (wpabuf_resize(&assocresp, add) < 0)
-			goto fail;
-		wpabuf_put_buf(assocresp, hapd->iface->fst_ies);
-	}
-#endif /* CONFIG_FST */
-
 	if (hapd->wps_beacon_ie) {
 		if (wpabuf_resize(&beacon, wpabuf_len(hapd->wps_beacon_ie)) <
 		    0)
@@ -207,11 +191,6 @@ int hostapd_build_ap_extra_ies(struct hostapd_data *hapd,
 		if (wpabuf_resize(&proberesp, add) == 0)
 			wpabuf_put_buf(proberesp, hapd->conf->vendor_elements);
 	}
-	if (hapd->conf->assocresp_elements) {
-		size_t add = wpabuf_len(hapd->conf->assocresp_elements);
-		if (wpabuf_resize(&assocresp, add) == 0)
-			wpabuf_put_buf(assocresp, hapd->conf->assocresp_elements);
-	}
 
 	*beacon_ret = beacon;
 	*proberesp_ret = proberesp;
@@ -748,25 +727,6 @@ int hostapd_drv_set_qos_map(struct hostapd_data *hapd,
 }
 
 
-static void hostapd_get_hw_mode_any_channels(struct hostapd_data *hapd,
-					     struct hostapd_hw_modes *mode,
-					     int acs_ch_list_all,
-					     int **freq_list)
-{
-	int i;
-
-	for (i = 0; i < mode->num_channels; i++) {
-		struct hostapd_channel_data *chan = &mode->channels[i];
-
-		if ((acs_ch_list_all ||
-		     freq_range_list_includes(&hapd->iface->conf->acs_ch_list,
-					      chan->chan)) &&
-		    !(chan->flag & HOSTAPD_CHAN_DISABLED))
-			int_array_add_unique(freq_list, chan->freq);
-	}
-}
-
-
 int hostapd_drv_do_acs(struct hostapd_data *hapd)
 {
 	struct drv_acs_params params;
@@ -774,7 +734,6 @@ int hostapd_drv_do_acs(struct hostapd_data *hapd)
 	u8 *channels = NULL;
 	unsigned int num_channels = 0;
 	struct hostapd_hw_modes *mode;
-	int *freq_list = NULL;
 
 	if (hapd->driver == NULL || hapd->driver->do_acs == NULL)
 		return 0;
@@ -790,35 +749,24 @@ int hostapd_drv_do_acs(struct hostapd_data *hapd)
 		acs_ch_list_all = 1;
 
 	mode = hapd->iface->current_mode;
-	if (mode) {
-		channels = os_malloc(mode->num_channels);
-		if (channels == NULL)
-			return -1;
-
-		for (i = 0; i < mode->num_channels; i++) {
-			struct hostapd_channel_data *chan = &mode->channels[i];
-			if (!acs_ch_list_all &&
-			    !freq_range_list_includes(
-				    &hapd->iface->conf->acs_ch_list,
-				    chan->chan))
-				continue;
-			if (!(chan->flag & HOSTAPD_CHAN_DISABLED)) {
-				channels[num_channels++] = chan->chan;
-				int_array_add_unique(&freq_list, chan->freq);
-			}
-		}
-	} else {
-		for (i = 0; i < hapd->iface->num_hw_features; i++) {
-			mode = &hapd->iface->hw_features[i];
-			hostapd_get_hw_mode_any_channels(hapd, mode,
-							 acs_ch_list_all,
-							 &freq_list);
-		}
+	if (mode == NULL)
+		return -1;
+	channels = os_malloc(mode->num_channels);
+	if (channels == NULL)
+		return -1;
+
+	for (i = 0; i < mode->num_channels; i++) {
+		struct hostapd_channel_data *chan = &mode->channels[i];
+		if (!acs_ch_list_all &&
+		    !freq_range_list_includes(&hapd->iface->conf->acs_ch_list,
+					      chan->chan))
+			continue;
+		if (!(chan->flag & HOSTAPD_CHAN_DISABLED))
+			channels[num_channels++] = chan->chan;
 	}
 
 	params.ch_list = channels;
 	params.ch_list_len = num_channels;
-	params.freq_list = freq_list;
 
 	params.ht_enabled = !!(hapd->iface->conf->ieee80211n);
 	params.ht40_enabled = !!(hapd->iface->conf->ht_capab &
diff --git a/src/ap/beacon.c b/src/ap/beacon.c
index c319372..51d0c15 100644
--- a/src/ap/beacon.c
+++ b/src/ap/beacon.c
@@ -377,10 +377,6 @@ static u8 * hostapd_gen_probe_resp(struct hostapd_data *hapd,
 	if (hapd->p2p_probe_resp_ie)
 		buflen += wpabuf_len(hapd->p2p_probe_resp_ie);
 #endif /* CONFIG_P2P */
-#ifdef CONFIG_FST
-	if (hapd->iface->fst_ies)
-		buflen += wpabuf_len(hapd->iface->fst_ies);
-#endif /* CONFIG_FST */
 	if (hapd->conf->vendor_elements)
 		buflen += wpabuf_len(hapd->conf->vendor_elements);
 	if (hapd->conf->vendor_vht) {
@@ -453,20 +449,10 @@ static u8 * hostapd_gen_probe_resp(struct hostapd_data *hapd,
 
 	pos = hostapd_add_csa_elems(hapd, pos, (u8 *)resp,
 				    &hapd->cs_c_off_proberesp);
-
-#ifdef CONFIG_FST
-	if (hapd->iface->fst_ies) {
-		os_memcpy(pos, wpabuf_head(hapd->iface->fst_ies),
-			  wpabuf_len(hapd->iface->fst_ies));
-		pos += wpabuf_len(hapd->iface->fst_ies);
-	}
-#endif /* CONFIG_FST */
-
 #ifdef CONFIG_IEEE80211AC
 	if (hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac) {
 		pos = hostapd_eid_vht_capabilities(hapd, pos);
 		pos = hostapd_eid_vht_operation(hapd, pos);
-		pos = hostapd_eid_txpower_envelope(hapd, pos);
 	}
 	if (hapd->conf->vendor_vht)
 		pos = hostapd_eid_vendor_vht(hapd, pos);
@@ -811,10 +797,6 @@ int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 	if (hapd->p2p_beacon_ie)
 		tail_len += wpabuf_len(hapd->p2p_beacon_ie);
 #endif /* CONFIG_P2P */
-#ifdef CONFIG_FST
-	if (hapd->iface->fst_ies)
-		tail_len += wpabuf_len(hapd->iface->fst_ies);
-#endif /* CONFIG_FST */
 	if (hapd->conf->vendor_elements)
 		tail_len += wpabuf_len(hapd->conf->vendor_elements);
 
@@ -913,20 +895,10 @@ int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 	tailpos = hostapd_eid_roaming_consortium(hapd, tailpos);
 	tailpos = hostapd_add_csa_elems(hapd, tailpos, tail,
 					&hapd->cs_c_off_beacon);
-
-#ifdef CONFIG_FST
-	if (hapd->iface->fst_ies) {
-		os_memcpy(tailpos, wpabuf_head(hapd->iface->fst_ies),
-			  wpabuf_len(hapd->iface->fst_ies));
-		tailpos += wpabuf_len(hapd->iface->fst_ies);
-	}
-#endif /* CONFIG_FST */
-
 #ifdef CONFIG_IEEE80211AC
 	if (hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac) {
 		tailpos = hostapd_eid_vht_capabilities(hapd, tailpos);
 		tailpos = hostapd_eid_vht_operation(hapd, tailpos);
-		tailpos = hostapd_eid_txpower_envelope(hapd, tailpos);
 	}
 	if (hapd->conf->vendor_vht)
 		tailpos = hostapd_eid_vendor_vht(hapd, tailpos);
@@ -1045,7 +1017,6 @@ int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 		params->osen = 1;
 	}
 #endif /* CONFIG_HS20 */
-	params->pbss = hapd->conf->pbss;
 	return 0;
 }
 
diff --git a/src/ap/ctrl_iface_ap.c b/src/ap/ctrl_iface_ap.c
index c98978f..60afcb0 100644
--- a/src/ap/ctrl_iface_ap.c
+++ b/src/ap/ctrl_iface_ap.c
@@ -12,7 +12,6 @@
 #include "common/ieee802_11_defs.h"
 #include "common/sae.h"
 #include "eapol_auth/eapol_auth_sm.h"
-#include "fst/fst_ctrl_iface.h"
 #include "hostapd.h"
 #include "ieee802_1x.h"
 #include "wpa_auth.h"
@@ -207,10 +206,7 @@ int hostapd_ctrl_iface_sta(struct hostapd_data *hapd, const char *txtaddr,
 		return -1;
 	}
 
-	ret = hostapd_ctrl_iface_sta_mib(hapd, sta, buf, buflen);
-	ret += fst_ctrl_iface_mb_info(addr, buf + ret, buflen - ret);
-
-	return ret;
+	return hostapd_ctrl_iface_sta_mib(hapd, sta, buf, buflen);
 }
 
 
diff --git a/src/ap/drv_callbacks.c b/src/ap/drv_callbacks.c
index cc664d7..6ecd094 100644
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -18,11 +18,9 @@
 #include "crypto/random.h"
 #include "p2p/p2p.h"
 #include "wps/wps.h"
-#include "fst/fst.h"
 #include "wnm_ap.h"
 #include "hostapd.h"
 #include "ieee802_11.h"
-#include "ieee802_11_auth.h"
 #include "sta_info.h"
 #include "accounting.h"
 #include "tkip_countermeasures.h"
@@ -115,21 +113,6 @@ int hostapd_notif_assoc(struct hostapd_data *hapd, const u8 *addr,
 	}
 	sta->flags &= ~(WLAN_STA_WPS | WLAN_STA_MAYBE_WPS | WLAN_STA_WPS2);
 
-	/*
-	 * ACL configurations to the drivers (implementing AP SME and ACL
-	 * offload) without hostapd's knowledge, can result in a disconnection
-	 * though the driver accepts the connection. Skip the hostapd check for
-	 * ACL if the driver supports ACL offload to avoid potentially
-	 * conflicting ACL rules.
-	 */
-	if (hapd->iface->drv_max_acl_mac_addrs == 0 &&
-	    hostapd_check_acl(hapd, addr, NULL) != HOSTAPD_ACL_ACCEPT) {
-		wpa_printf(MSG_INFO, "STA " MACSTR " not allowed to connect",
-			   MAC2STR(addr));
-		reason = WLAN_REASON_UNSPECIFIED;
-		goto fail;
-	}
-
 #ifdef CONFIG_P2P
 	if (elems.p2p) {
 		wpabuf_free(sta->p2p_ie);
@@ -172,14 +155,6 @@ int hostapd_notif_assoc(struct hostapd_data *hapd, const u8 *addr,
 		sta->hs20_ie = NULL;
 #endif /* CONFIG_HS20 */
 
-#ifdef CONFIG_FST
-	wpabuf_free(sta->mb_ies);
-	if (hapd->iface->fst)
-		sta->mb_ies = mb_ies_by_info(&elems.mb_ies);
-	else
-		sta->mb_ies = NULL;
-#endif /* CONFIG_FST */
-
 	if (hapd->conf->wpa) {
 		if (ie == NULL || ielen == 0) {
 #ifdef CONFIG_WPS
@@ -776,13 +751,6 @@ static void hostapd_action_rx(struct hostapd_data *hapd,
 		ieee802_11_rx_wnm_action_ap(hapd, mgmt, drv_mgmt->frame_len);
 	}
 #endif /* CONFIG_WNM */
-#ifdef CONFIG_FST
-	if (mgmt->u.action.category == WLAN_ACTION_FST && hapd->iface->fst) {
-		fst_rx_action(hapd->iface->fst, mgmt, drv_mgmt->frame_len);
-		return;
-	}
-#endif /* CONFIG_FST */
-
 }
 
 
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index e0f87d7..5b91cc7 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -17,7 +17,6 @@
 #include "eap_server/tncs.h"
 #include "eapol_auth/eapol_auth_sm.h"
 #include "eapol_auth/eapol_auth_sm_i.h"
-#include "fst/fst.h"
 #include "hostapd.h"
 #include "authsrv.h"
 #include "sta_info.h"
@@ -1158,7 +1157,32 @@ static void hostapd_set_acl(struct hostapd_data *hapd)
 	struct hostapd_config *conf = hapd->iconf;
 	int err;
 	u8 accept_acl;
-
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+	int i = 0;
+	char buf[25];
+	char reply[10];
+	os_memset(buf, 0, 25);
+	os_strncpy(buf, "WHITE_ADD_ONCE ", 15);
+	while(i < conf->bss[0]->num_accept_mac){
+		wpa_printf(MSG_INFO, "accept mac:" MACSTR, MAC2STR(conf->bss[0]->accept_mac[i].addr));
+		os_memcpy(buf+15, conf->bss[0]->accept_mac[i].addr, ETH_ALEN);
+		i++;
+		err = hapd->driver->ap_priv_cmd(hapd->drv_priv, buf, reply, 10);
+		if(err < 0){
+			wpa_printf(MSG_ERROR, "WHITE_ADD_ONCE failed.");
+			return;
+		}
+	}
+	if (conf->bss[0]->macaddr_acl == DENY_UNLESS_ACCEPTED) {
+		os_memset(buf, 0, 25);
+		os_strncpy(buf, "WHITE_EN_ONCE ", 14);
+		err = hapd->driver->ap_priv_cmd(hapd->drv_priv, buf, reply, 10);
+		if (err < 0){
+			wpa_printf(MSG_ERROR, "WHITE_EN_ONCE failed.");
+			return;
+		}
+	}
+#else
 	if (hapd->iface->drv_max_acl_mac_addrs == 0)
 		return;
 
@@ -1181,6 +1205,7 @@ static void hostapd_set_acl(struct hostapd_data *hapd)
 			return;
 		}
 	}
+#endif
 }
 
 
@@ -1365,132 +1390,6 @@ fail:
 }
 
 
-#ifdef CONFIG_FST
-
-static const u8 * fst_hostapd_get_bssid_cb(void *ctx)
-{
-	struct hostapd_data *hapd = ctx;
-
-	return hapd->own_addr;
-}
-
-
-static void fst_hostapd_get_channel_info_cb(void *ctx,
-					    enum hostapd_hw_mode *hw_mode,
-					    u8 *channel)
-{
-	struct hostapd_data *hapd = ctx;
-
-	*hw_mode = ieee80211_freq_to_chan(hapd->iface->freq, channel);
-}
-
-
-static void fst_hostapd_set_ies_cb(void *ctx, const struct wpabuf *fst_ies)
-{
-	struct hostapd_data *hapd = ctx;
-
-	if (hapd->iface->fst_ies != fst_ies) {
-		hapd->iface->fst_ies = fst_ies;
-		if (ieee802_11_set_beacon(hapd))
-			wpa_printf(MSG_WARNING, "FST: Cannot set beacon");
-	}
-}
-
-
-static int fst_hostapd_send_action_cb(void *ctx, const u8 *da,
-				      struct wpabuf *buf)
-{
-	struct hostapd_data *hapd = ctx;
-
-	return hostapd_drv_send_action(hapd, hapd->iface->freq, 0, da,
-				       wpabuf_head(buf), wpabuf_len(buf));
-}
-
-
-static const struct wpabuf * fst_hostapd_get_mb_ie_cb(void *ctx, const u8 *addr)
-{
-	struct hostapd_data *hapd = ctx;
-	struct sta_info *sta = ap_get_sta(hapd, addr);
-
-	return sta ? sta->mb_ies : NULL;
-}
-
-
-static void fst_hostapd_update_mb_ie_cb(void *ctx, const u8 *addr,
-					const u8 *buf, size_t size)
-{
-	struct hostapd_data *hapd = ctx;
-	struct sta_info *sta = ap_get_sta(hapd, addr);
-
-	if (sta) {
-		struct mb_ies_info info;
-
-		if (!mb_ies_info_by_ies(&info, buf, size)) {
-			wpabuf_free(sta->mb_ies);
-			sta->mb_ies = mb_ies_by_info(&info);
-		}
-	}
-}
-
-
-static const u8 * fst_hostapd_get_sta(struct fst_get_peer_ctx **get_ctx,
-				      Boolean mb_only)
-{
-	struct sta_info *s = (struct sta_info *) *get_ctx;
-
-	if (mb_only) {
-		for (; s && !s->mb_ies; s = s->next)
-			;
-	}
-
-	if (s) {
-		*get_ctx = (struct fst_get_peer_ctx *) s->next;
-
-		return s->addr;
-	}
-
-	*get_ctx = NULL;
-	return NULL;
-}
-
-
-static const u8 * fst_hostapd_get_peer_first(void *ctx,
-					     struct fst_get_peer_ctx **get_ctx,
-					     Boolean mb_only)
-{
-	struct hostapd_data *hapd = ctx;
-
-	*get_ctx = (struct fst_get_peer_ctx *) hapd->sta_list;
-
-	return fst_hostapd_get_sta(get_ctx, mb_only);
-}
-
-
-static const u8 * fst_hostapd_get_peer_next(void *ctx,
-					    struct fst_get_peer_ctx **get_ctx,
-					    Boolean mb_only)
-{
-	return fst_hostapd_get_sta(get_ctx, mb_only);
-}
-
-
-void fst_hostapd_fill_iface_obj(struct hostapd_data *hapd,
-				struct fst_wpa_obj *iface_obj)
-{
-	iface_obj->ctx = hapd;
-	iface_obj->get_bssid = fst_hostapd_get_bssid_cb;
-	iface_obj->get_channel_info = fst_hostapd_get_channel_info_cb;
-	iface_obj->set_ies = fst_hostapd_set_ies_cb;
-	iface_obj->send_action = fst_hostapd_send_action_cb;
-	iface_obj->get_mb_ie = fst_hostapd_get_mb_ie_cb;
-	iface_obj->update_mb_ie = fst_hostapd_update_mb_ie_cb;
-	iface_obj->get_peer_first = fst_hostapd_get_peer_first;
-	iface_obj->get_peer_next = fst_hostapd_get_peer_next;
-}
-
-#endif /* CONFIG_FST */
-
-
 /**
  * hostapd_setup_interface_complete - Complete interface setup
  *
@@ -1656,22 +1555,6 @@ int hostapd_setup_interface_complete(struct hostapd_iface *iface, int err)
 #ifdef NEED_AP_MLME
 dfs_offload:
 #endif /* NEED_AP_MLME */
-
-#ifdef CONFIG_FST
-	if (hapd->iconf->fst_cfg.group_id[0]) {
-		struct fst_wpa_obj iface_obj;
-
-		fst_hostapd_fill_iface_obj(hapd, &iface_obj);
-		iface->fst = fst_attach(hapd->conf->iface, hapd->own_addr,
-					&iface_obj, &hapd->iconf->fst_cfg);
-		if (!iface->fst) {
-			wpa_printf(MSG_ERROR, "Could not attach to FST %s",
-				   hapd->iconf->fst_cfg.group_id);
-			goto fail;
-		}
-	}
-#endif /* CONFIG_FST */
-
 	hostapd_set_state(iface, HAPD_IFACE_ENABLED);
 	wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO, AP_EVENT_ENABLED);
 	if (hapd->setup_complete_cb)
@@ -1688,12 +1571,6 @@ fail:
 	wpa_printf(MSG_ERROR, "Interface initialization failed");
 	hostapd_set_state(iface, HAPD_IFACE_DISABLED);
 	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_EVENT_DISABLED);
-#ifdef CONFIG_FST
-	if (iface->fst) {
-		fst_detach(iface->fst);
-		iface->fst = NULL;
-	}
-#endif /* CONFIG_FST */
 	if (iface->interfaces && iface->interfaces->terminate_on_error)
 		eloop_terminate();
 	return -1;
@@ -1768,6 +1645,9 @@ static void hostapd_bss_deinit(struct hostapd_data *hapd)
 {
 	wpa_printf(MSG_DEBUG, "%s: deinit bss %s", __func__,
 		   hapd->conf->iface);
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+	wpa_msg(hapd->msg_ctx, MSG_INFO, "AP-TERMINATING");
+ #endif
 	hostapd_bss_deinit_no_free(hapd);
 	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_EVENT_DISABLED);
 	hostapd_cleanup(hapd);
@@ -1793,13 +1673,6 @@ void hostapd_interface_deinit(struct hostapd_iface *iface)
 	eloop_cancel_timeout(channel_list_update_timeout, iface, NULL);
 	iface->wait_channel_update = 0;
 
-#ifdef CONFIG_FST
-	if (iface->fst) {
-		fst_detach(iface->fst);
-		iface->fst = NULL;
-	}
-#endif /* CONFIG_FST */
-
 	for (j = iface->num_bss - 1; j >= 0; j--)
 		hostapd_bss_deinit(iface->bss[j]);
 }
@@ -2879,24 +2752,4 @@ hostapd_switch_channel_fallback(struct hostapd_iface *iface,
 	hostapd_enable_iface(iface);
 }
 
-
-struct hostapd_data * hostapd_get_iface(struct hapd_interfaces *interfaces,
-					const char *ifname)
-{
-	size_t i, j;
-
-	for (i = 0; i < interfaces->count; i++) {
-		struct hostapd_iface *iface = interfaces->iface[i];
-
-		for (j = 0; j < iface->num_bss; j++) {
-			struct hostapd_data *hapd = iface->bss[j];
-
-			if (os_strcmp(ifname, hapd->conf->iface) == 0)
-				return hapd;
-		}
-	}
-
-	return NULL;
-}
-
 #endif /* NEED_AP_MLME */
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index b1a7980..be5c7a8 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -41,7 +41,6 @@ struct hapd_interfaces {
 
 	size_t count;
 	int global_ctrl_sock;
-	struct wpa_ctrl_dst *global_ctrl_dst;
 	char *global_iface_path;
 	char *global_iface_name;
 #ifndef CONFIG_NATIVE_WINDOWS
@@ -309,10 +308,6 @@ struct hostapd_iface {
 
 	unsigned int wait_channel_update:1;
 	unsigned int cac_started:1;
-#ifdef CONFIG_FST
-	struct fst_iface *fst;
-	const struct wpabuf *fst_ies;
-#endif /* CONFIG_FST */
 
 	/*
 	 * When set, indicates that the driver will handle the AP
@@ -472,12 +467,4 @@ const struct hostapd_eap_user *
 hostapd_get_eap_user(struct hostapd_data *hapd, const u8 *identity,
 		     size_t identity_len, int phase2);
 
-struct hostapd_data * hostapd_get_iface(struct hapd_interfaces *interfaces,
-					const char *ifname);
-
-#ifdef CONFIG_FST
-void fst_hostapd_fill_iface_obj(struct hostapd_data *hapd,
-				struct fst_wpa_obj *iface_obj);
-#endif /* CONFIG_FST */
-
 #endif /* HOSTAPD_H */
diff --git a/src/ap/hw_features.c b/src/ap/hw_features.c
index fcda6ab..28324a8 100644
--- a/src/ap/hw_features.c
+++ b/src/ap/hw_features.c
@@ -466,9 +466,6 @@ static int ieee80211n_check_40mhz(struct hostapd_iface *iface)
 	struct wpa_driver_scan_params params;
 	int ret;
 
-	if (iface->conf->ht2040_coex_disable == 1)
-		return 0;
-
 	if (!iface->conf->secondary_channel)
 		return 0; /* HT40 not used */
 
diff --git a/src/ap/ieee802_11.c b/src/ap/ieee802_11.c
index 0176c44..db20c86 100644
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -23,7 +23,6 @@
 #include "radius/radius_client.h"
 #include "p2p/p2p.h"
 #include "wps/wps.h"
-#include "fst/fst.h"
 #include "hostapd.h"
 #include "beacon.h"
 #include "ieee802_11_auth.h"
@@ -1536,14 +1535,6 @@ static u16 check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 		sta->hs20_ie = NULL;
 #endif /* CONFIG_HS20 */
 
-#ifdef CONFIG_FST
-	wpabuf_free(sta->mb_ies);
-	if (hapd->iface->fst)
-		sta->mb_ies = mb_ies_by_info(&elems.mb_ies);
-	else
-		sta->mb_ies = NULL;
-#endif /* CONFIG_FST */
-
 	return WLAN_STATUS_SUCCESS;
 }
 
@@ -1632,14 +1623,6 @@ static void send_assoc_resp(struct hostapd_data *hapd, struct sta_info *sta,
 	if (sta->qos_map_enabled)
 		p = hostapd_eid_qos_map_set(hapd, p);
 
-#ifdef CONFIG_FST
-	if (hapd->iface->fst_ies) {
-		os_memcpy(p, wpabuf_head(hapd->iface->fst_ies),
-			  wpabuf_len(hapd->iface->fst_ies));
-		p += wpabuf_len(hapd->iface->fst_ies);
-	}
-#endif /* CONFIG_FST */
-
 #ifdef CONFIG_IEEE80211AC
 	if (hapd->conf->vendor_vht && (sta->flags & WLAN_STA_VENDOR_VHT))
 		p = hostapd_eid_vendor_vht(hapd, p);
@@ -1690,14 +1673,6 @@ static void send_assoc_resp(struct hostapd_data *hapd, struct sta_info *sta,
 		p = hostapd_eid_p2p_manage(hapd, p);
 #endif /* CONFIG_P2P_MANAGER */
 
-	if (hapd->conf->assocresp_elements &&
-	    (size_t) (buf + sizeof(buf) - p) >=
-	    wpabuf_len(hapd->conf->assocresp_elements)) {
-		os_memcpy(p, wpabuf_head(hapd->conf->assocresp_elements),
-			  wpabuf_len(hapd->conf->assocresp_elements));
-		p += wpabuf_len(hapd->conf->assocresp_elements);
-	}
-
 	send_len += p - reply->u.assoc_resp.variable;
 
 	if (hostapd_drv_send_mlme(hapd, reply, send_len, 0) < 0)
@@ -2126,15 +2101,6 @@ static int handle_action(struct hostapd_data *hapd,
 		ieee802_11_rx_wnm_action_ap(hapd, mgmt, len);
 		return 1;
 #endif /* CONFIG_WNM */
-#ifdef CONFIG_FST
-	case WLAN_ACTION_FST:
-		if (hapd->iface->fst)
-			fst_rx_action(hapd->iface->fst, mgmt, len);
-		else
-			wpa_printf(MSG_DEBUG,
-				   "FST: Ignore FST Action frame - no FST attached");
-		return 1;
-#endif /* CONFIG_FST */
 	case WLAN_ACTION_PUBLIC:
 	case WLAN_ACTION_PROTECTED_DUAL:
 #ifdef CONFIG_IEEE80211N
@@ -2602,7 +2568,7 @@ void ieee802_11_mgmt_cb(struct hostapd_data *hapd, const u8 *buf, size_t len,
 		handle_assoc_cb(hapd, mgmt, len, 1, ok);
 		break;
 	case WLAN_FC_STYPE_PROBE_RESP:
-		wpa_printf(MSG_EXCESSIVE, "mgmt::proberesp cb ok=%d", ok);
+		wpa_printf(MSG_EXCESSIVE, "mgmt::proberesp cb");
 		break;
 	case WLAN_FC_STYPE_DEAUTH:
 		wpa_printf(MSG_DEBUG, "mgmt::deauth cb");
@@ -2613,7 +2579,7 @@ void ieee802_11_mgmt_cb(struct hostapd_data *hapd, const u8 *buf, size_t len,
 		handle_disassoc_cb(hapd, mgmt, len, ok);
 		break;
 	case WLAN_FC_STYPE_ACTION:
-		wpa_printf(MSG_DEBUG, "mgmt::action cb ok=%d", ok);
+		wpa_printf(MSG_DEBUG, "mgmt::action cb");
 		break;
 	default:
 		wpa_printf(MSG_INFO, "unknown mgmt cb frame subtype %d", stype);
diff --git a/src/ap/ieee802_11.h b/src/ap/ieee802_11.h
index 6f50540..44c1bff 100644
--- a/src/ap/ieee802_11.h
+++ b/src/ap/ieee802_11.h
@@ -52,8 +52,6 @@ u8 * hostapd_eid_ht_operation(struct hostapd_data *hapd, u8 *eid);
 u8 * hostapd_eid_vht_capabilities(struct hostapd_data *hapd, u8 *eid);
 u8 * hostapd_eid_vht_operation(struct hostapd_data *hapd, u8 *eid);
 u8 * hostapd_eid_vendor_vht(struct hostapd_data *hapd, u8 *eid);
-u8 * hostapd_eid_txpower_envelope(struct hostapd_data *hapd, u8 *eid);
-
 int hostapd_ht_operation_update(struct hostapd_iface *iface);
 void ieee802_11_send_sa_query_req(struct hostapd_data *hapd,
 				  const u8 *addr, const u8 *trans_id);
diff --git a/src/ap/ieee802_11_auth.c b/src/ap/ieee802_11_auth.c
index 10d744d..0238257 100644
--- a/src/ap/ieee802_11_auth.c
+++ b/src/ap/ieee802_11_auth.c
@@ -213,32 +213,6 @@ static int hostapd_radius_acl_query(struct hostapd_data *hapd, const u8 *addr,
 
 
 /**
- * hostapd_check_acl - Check a specified STA against accept/deny ACLs
- * @hapd: hostapd BSS data
- * @addr: MAC address of the STA
- * @vlan_id: Buffer for returning VLAN ID
- * Returns: HOSTAPD_ACL_ACCEPT, HOSTAPD_ACL_REJECT, or HOSTAPD_ACL_PENDING
- */
- int hostapd_check_acl(struct hostapd_data *hapd, const u8 *addr, int *vlan_id)
-{
-	if (hostapd_maclist_found(hapd->conf->accept_mac,
-				  hapd->conf->num_accept_mac, addr, vlan_id))
-		return HOSTAPD_ACL_ACCEPT;
-
-	if (hostapd_maclist_found(hapd->conf->deny_mac,
-				  hapd->conf->num_deny_mac, addr, vlan_id))
-		return HOSTAPD_ACL_REJECT;
-
-	if (hapd->conf->macaddr_acl == ACCEPT_UNLESS_DENIED)
-		return HOSTAPD_ACL_ACCEPT;
-	if (hapd->conf->macaddr_acl == DENY_UNLESS_ACCEPTED)
-		return HOSTAPD_ACL_REJECT;
-
-	return HOSTAPD_ACL_PENDING;
-}
-
-
-/**
  * hostapd_allowed_address - Check whether a specified STA can be authenticated
  * @hapd: hostapd BSS data
  * @addr: MAC address of the STA
@@ -261,8 +235,6 @@ int hostapd_allowed_address(struct hostapd_data *hapd, const u8 *addr,
 			    struct hostapd_sta_wpa_psk_short **psk,
 			    char **identity, char **radius_cui)
 {
-	int res;
-
 	if (session_timeout)
 		*session_timeout = 0;
 	if (acct_interim_interval)
@@ -276,9 +248,18 @@ int hostapd_allowed_address(struct hostapd_data *hapd, const u8 *addr,
 	if (radius_cui)
 		*radius_cui = NULL;
 
-	res = hostapd_check_acl(hapd, addr, vlan_id);
-	if (res != HOSTAPD_ACL_PENDING)
-		return res;
+	if (hostapd_maclist_found(hapd->conf->accept_mac,
+				  hapd->conf->num_accept_mac, addr, vlan_id))
+		return HOSTAPD_ACL_ACCEPT;
+
+	if (hostapd_maclist_found(hapd->conf->deny_mac,
+				  hapd->conf->num_deny_mac, addr, vlan_id))
+		return HOSTAPD_ACL_REJECT;
+
+	if (hapd->conf->macaddr_acl == ACCEPT_UNLESS_DENIED)
+		return HOSTAPD_ACL_ACCEPT;
+	if (hapd->conf->macaddr_acl == DENY_UNLESS_ACCEPTED)
+		return HOSTAPD_ACL_REJECT;
 
 	if (hapd->conf->macaddr_acl == USE_EXTERNAL_RADIUS_AUTH) {
 #ifdef CONFIG_NO_RADIUS
@@ -287,9 +268,10 @@ int hostapd_allowed_address(struct hostapd_data *hapd, const u8 *addr,
 		struct hostapd_acl_query_data *query;
 
 		/* Check whether ACL cache has an entry for this station */
-		res = hostapd_acl_cache_get(hapd, addr, session_timeout,
-					    acct_interim_interval, vlan_id, psk,
-					    identity, radius_cui);
+		int res = hostapd_acl_cache_get(hapd, addr, session_timeout,
+						acct_interim_interval,
+						vlan_id, psk,
+						identity, radius_cui);
 		if (res == HOSTAPD_ACL_ACCEPT ||
 		    res == HOSTAPD_ACL_ACCEPT_TIMEOUT)
 			return res;
diff --git a/src/ap/ieee802_11_auth.h b/src/ap/ieee802_11_auth.h
index 3032710..2bc1065 100644
--- a/src/ap/ieee802_11_auth.h
+++ b/src/ap/ieee802_11_auth.h
@@ -16,7 +16,6 @@ enum {
 	HOSTAPD_ACL_ACCEPT_TIMEOUT = 3
 };
 
-int hostapd_check_acl(struct hostapd_data *hapd, const u8 *addr, int *vlan_id);
 int hostapd_allowed_address(struct hostapd_data *hapd, const u8 *addr,
 			    const u8 *msg, size_t len, u32 *session_timeout,
 			    u32 *acct_interim_interval, int *vlan_id,
diff --git a/src/ap/ieee802_11_ht.c b/src/ap/ieee802_11_ht.c
index 764e77b..11fde2a 100644
--- a/src/ap/ieee802_11_ht.c
+++ b/src/ap/ieee802_11_ht.c
@@ -218,9 +218,6 @@ void hostapd_2040_coex_action(struct hostapd_data *hapd,
 		       HOSTAPD_LEVEL_DEBUG, "hostapd_public_action - action=%d",
 		       mgmt->u.action.u.public_action.action);
 
-	if (iface->conf->ht2040_coex_disable == 1)
-		return;
-
 	if (!(iface->conf->ht_capab & HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET))
 		return;
 
diff --git a/src/ap/ieee802_11_vht.c b/src/ap/ieee802_11_vht.c
index d31ab73..5bf1b5d 100644
--- a/src/ap/ieee802_11_vht.c
+++ b/src/ap/ieee802_11_vht.c
@@ -17,7 +17,6 @@
 #include "sta_info.h"
 #include "beacon.h"
 #include "ieee802_11.h"
-#include "dfs.h"
 
 
 u8 * hostapd_eid_vht_capabilities(struct hostapd_data *hapd, u8 *eid)
@@ -132,118 +131,6 @@ static int check_valid_vht_mcs(struct hostapd_hw_modes *mode,
 }
 
 
-u8 * hostapd_eid_txpower_envelope(struct hostapd_data *hapd, u8 *eid)
-{
-	struct hostapd_iface *iface = hapd->iface;
-	struct hostapd_config *iconf = iface->conf;
-	struct hostapd_hw_modes *mode = iface->current_mode;
-	struct hostapd_channel_data *chan;
-	int dfs, i;
-	u8 channel, tx_pwr_count, local_pwr_constraint;
-	int max_tx_power;
-	u8 tx_pwr;
-
-	if (!mode)
-		return eid;
-
-	if (ieee80211_freq_to_chan(iface->freq, &channel) == NUM_HOSTAPD_MODES)
-		return eid;
-
-	for (i = 0; i < mode->num_channels; i++) {
-		if (mode->channels[i].freq == iface->freq)
-			break;
-	}
-	if (i == mode->num_channels)
-		return eid;
-
-	switch (iface->conf->vht_oper_chwidth) {
-	case VHT_CHANWIDTH_USE_HT:
-		if (iconf->secondary_channel == 0) {
-			/* Max Transmit Power count = 0 (20 MHz) */
-			tx_pwr_count = 0;
-		} else {
-			/* Max Transmit Power count = 1 (20, 40 MHz) */
-			tx_pwr_count = 1;
-		}
-		break;
-	case VHT_CHANWIDTH_80MHZ:
-		/* Max Transmit Power count = 2 (20, 40, and 80 MHz) */
-		tx_pwr_count = 2;
-		break;
-	case VHT_CHANWIDTH_80P80MHZ:
-	case VHT_CHANWIDTH_160MHZ:
-		/* Max Transmit Power count = 3 (20, 40, 80, 160/80+80 MHz) */
-		tx_pwr_count = 3;
-		break;
-	default:
-		return eid;
-	}
-
-	/*
-	 * Below local_pwr_constraint logic is referred from
-	 * hostapd_eid_pwr_constraint.
-	 *
-	 * Check if DFS is required by regulatory.
-	 */
-	dfs = hostapd_is_dfs_required(hapd->iface);
-	if (dfs < 0)
-		dfs = 0;
-
-	/*
-	 * In order to meet regulations when TPC is not implemented using
-	 * a transmit power that is below the legal maximum (including any
-	 * mitigation factor) should help. In this case, indicate 3 dB below
-	 * maximum allowed transmit power.
-	 */
-	if (hapd->iconf->local_pwr_constraint == -1)
-		local_pwr_constraint = (dfs == 0) ? 0 : 3;
-	else
-		local_pwr_constraint = hapd->iconf->local_pwr_constraint;
-
-	/*
-	 * A STA that is not an AP shall use a transmit power less than or
-	 * equal to the local maximum transmit power level for the channel.
-	 * The local maximum transmit power can be calculated from the formula:
-	 * local max TX pwr = max TX pwr - local pwr constraint
-	 * Where max TX pwr is maximum transmit power level specified for
-	 * channel in Country element and local pwr constraint is specified
-	 * for channel in this Power Constraint element.
-	 */
-	chan = &mode->channels[i];
-	max_tx_power = chan->max_tx_power - local_pwr_constraint;
-
-	/*
-	 * Local Maximum Transmit power is encoded as two's complement
-	 * with a 0.5 dB step.
-	 */
-	max_tx_power *= 2; /* in 0.5 dB steps */
-	if (max_tx_power > 127) {
-		/* 63.5 has special meaning of 63.5 dBm or higher */
-		max_tx_power = 127;
-	}
-	if (max_tx_power < -128)
-		max_tx_power = -128;
-	if (max_tx_power < 0)
-		tx_pwr = 0x80 + max_tx_power + 128;
-	else
-		tx_pwr = max_tx_power;
-
-	*eid++ = WLAN_EID_VHT_TRANSMIT_POWER_ENVELOPE;
-	*eid++ = 2 + tx_pwr_count;
-
-	/*
-	 * Max Transmit Power count and
-	 * Max Transmit Power units = 0 (EIRP)
-	 */
-	*eid++ = tx_pwr_count;
-
-	for (i = 0; i <= tx_pwr_count; i++)
-		*eid++ = tx_pwr;
-
-	return eid;
-}
-
-
 u16 copy_sta_vht_capab(struct hostapd_data *hapd, struct sta_info *sta,
 		       const u8 *vht_capab)
 {
diff --git a/src/ap/sta_info.c b/src/ap/sta_info.c
index d4418b2..20847d5 100644
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -16,7 +16,6 @@
 #include "radius/radius.h"
 #include "radius/radius_client.h"
 #include "p2p/p2p.h"
-#include "fst/fst.h"
 #include "hostapd.h"
 #include "accounting.h"
 #include "ieee802_1x.h"
@@ -297,9 +296,6 @@ void ap_free_sta(struct hostapd_data *hapd, struct sta_info *sta)
 	wpabuf_free(sta->wps_ie);
 	wpabuf_free(sta->p2p_ie);
 	wpabuf_free(sta->hs20_ie);
-#ifdef CONFIG_FST
-	wpabuf_free(sta->mb_ies);
-#endif /* CONFIG_FST */
 
 	os_free(sta->ht_capabilities);
 	os_free(sta->vht_capabilities);
@@ -1064,20 +1060,6 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 			wpa_msg_no_global(hapd->msg_ctx_parent, MSG_INFO,
 					  AP_STA_DISCONNECTED "%s", buf);
 	}
-
-#ifdef CONFIG_FST
-	if (hapd->iface->fst) {
-		if (authorized)
-			fst_notify_peer_connected(hapd->iface->fst, sta->addr);
-		else
-			fst_notify_peer_disconnected(hapd->iface->fst,
-						     sta->addr);
-	}
-#endif /* CONFIG_FST */
-
-	if (hapd->sta_authorized_cb)
-		hapd->sta_authorized_cb(hapd->sta_authorized_cb_ctx,
-					sta->addr, authorized, dev_addr);
 }
 
 
diff --git a/src/ap/sta_info.h b/src/ap/sta_info.h
index 420d64e..52a9997 100644
--- a/src/ap/sta_info.h
+++ b/src/ap/sta_info.h
@@ -153,9 +153,6 @@ struct sta_info {
 	struct wpabuf *hs20_deauth_req;
 	char *hs20_session_info_url;
 	int hs20_disassoc_timer;
-#ifdef CONFIG_FST
-	struct wpabuf *mb_ies; /* MB IEs from (Re)Association Request */
-#endif /* CONFIG_FST */
 
 	struct os_reltime connected_time;
 
diff --git a/src/ap/utils.c b/src/ap/utils.c
index fcb371b..d60555a 100644
--- a/src/ap/utils.c
+++ b/src/ap/utils.c
@@ -10,7 +10,6 @@
 
 #include "common.h"
 #include "common/ieee802_11_defs.h"
-#include "fst/fst.h"
 #include "sta_info.h"
 #include "hostapd.h"
 
@@ -56,14 +55,6 @@ static int prune_associations(struct hostapd_iface *iface, void *ctx)
 		ohapd = iface->bss[j];
 		if (ohapd == data->hapd)
 			continue;
-#ifdef CONFIG_FST
-		/* Don't prune STAs belong to same FST */
-		if (ohapd->iface->fst &&
-		    data->hapd->iface->fst &&
-		    fst_are_ifaces_aggregated(ohapd->iface->fst,
-					      data->hapd->iface->fst))
-			continue;
-#endif /* CONFIG_FST */
 		osta = ap_get_sta(ohapd, data->addr);
 		if (!osta)
 			continue;
diff --git a/src/common/defs.h b/src/common/defs.h
index 2e31379..5b2d7c4 100644
--- a/src/common/defs.h
+++ b/src/common/defs.h
@@ -328,16 +328,4 @@ enum mesh_plink_state {
 	PLINK_BLOCKED,
 };
 
-enum set_band {
-	WPA_SETBAND_AUTO,
-	WPA_SETBAND_5G,
-	WPA_SETBAND_2G
-};
-
-enum wpa_radio_work_band {
-	BAND_2_4_GHZ = BIT(0),
-	BAND_5_GHZ = BIT(1),
-	BAND_60_GHZ = BIT(2),
-};
-
 #endif /* DEFS_H */
diff --git a/src/common/ieee802_11_common.c b/src/common/ieee802_11_common.c
index 063de6a..5385faf 100644
--- a/src/common/ieee802_11_common.c
+++ b/src/common/ieee802_11_common.c
@@ -11,7 +11,6 @@
 #include "common.h"
 #include "defs.h"
 #include "wpa_common.h"
-#include "qca-vendor.h"
 #include "ieee802_11_defs.h"
 #include "ieee802_11_common.h"
 
@@ -148,20 +147,6 @@ static int ieee802_11_parse_vendor_specific(const u8 *pos, size_t elen,
 		}
 		break;
 
-	case OUI_QCA:
-		switch (pos[3]) {
-		case QCA_VENDOR_ELEM_P2P_PREF_CHAN_LIST:
-			elems->pref_freq_list = pos;
-			elems->pref_freq_list_len = elen;
-			break;
-		default:
-			wpa_printf(MSG_EXCESSIVE,
-				   "Unknown QCA information element ignored (type=%d len=%lu)",
-				   pos[3], (unsigned long) elen);
-			return -1;
-		}
-		break;
-
 	default:
 		wpa_printf(MSG_EXCESSIVE, "unknown vendor specific "
 			   "information element ignored (vendor OUI "
@@ -354,18 +339,6 @@ ParseRes ieee802_11_parse_elems(const u8 *start, size_t len,
 			/* after mic everything is encrypted, so stop. */
 			left = elen;
 			break;
-		case WLAN_EID_MULTI_BAND:
-			if (elems->mb_ies.nof_ies >= MAX_NOF_MB_IES_SUPPORTED) {
-				wpa_printf(MSG_MSGDUMP,
-					   "IEEE 802.11 element parse ignored MB IE (id=%d elen=%d)",
-					   id, elen);
-				break;
-			}
-
-			elems->mb_ies.ies[elems->mb_ies.nof_ies].ie = pos;
-			elems->mb_ies.ies[elems->mb_ies.nof_ies].ie_len = elen;
-			elems->mb_ies.nof_ies++;
-			break;
 		default:
 			unknown++;
 			if (!show_errors)
@@ -973,62 +946,3 @@ const char * fc2str(u16 fc)
 	return "WLAN_FC_TYPE_UNKNOWN";
 #undef C2S
 }
-
-
-int mb_ies_info_by_ies(struct mb_ies_info *info, const u8 *ies_buf,
-		       size_t ies_len)
-{
-	os_memset(info, 0, sizeof(*info));
-
-	while (ies_buf && ies_len >= 2 &&
-	       info->nof_ies < MAX_NOF_MB_IES_SUPPORTED) {
-		size_t len = 2 + ies_buf[1];
-
-		if (len > ies_len) {
-			wpa_hexdump(MSG_DEBUG, "Truncated IEs",
-				    ies_buf, ies_len);
-			return -1;
-		}
-
-		if (ies_buf[0] == WLAN_EID_MULTI_BAND) {
-			wpa_printf(MSG_DEBUG, "MB IE of %zu bytes found", len);
-			info->ies[info->nof_ies].ie = ies_buf + 2;
-			info->ies[info->nof_ies].ie_len = ies_buf[1];
-			info->nof_ies++;
-		}
-
-		ies_len -= len;
-		ies_buf += len;
-	}
-
-	return 0;
-}
-
-
-struct wpabuf * mb_ies_by_info(struct mb_ies_info *info)
-{
-	struct wpabuf *mb_ies = NULL;
-
-	WPA_ASSERT(info != NULL);
-
-	if (info->nof_ies) {
-		u8 i;
-		size_t mb_ies_size = 0;
-
-		for (i = 0; i < info->nof_ies; i++)
-			mb_ies_size += 2 + info->ies[i].ie_len;
-
-		mb_ies = wpabuf_alloc(mb_ies_size);
-		if (mb_ies) {
-			for (i = 0; i < info->nof_ies; i++) {
-				wpabuf_put_u8(mb_ies, WLAN_EID_MULTI_BAND);
-				wpabuf_put_u8(mb_ies, info->ies[i].ie_len);
-				wpabuf_put_data(mb_ies,
-						info->ies[i].ie,
-						info->ies[i].ie_len);
-			}
-		}
-	}
-
-	return mb_ies;
-}
diff --git a/src/common/ieee802_11_common.h b/src/common/ieee802_11_common.h
index 45cf121..c84d8a7 100644
--- a/src/common/ieee802_11_common.h
+++ b/src/common/ieee802_11_common.h
@@ -9,16 +9,6 @@
 #ifndef IEEE802_11_COMMON_H
 #define IEEE802_11_COMMON_H
 
-#define MAX_NOF_MB_IES_SUPPORTED 5
-
-struct mb_ies_info {
-	struct {
-		const u8 *ie;
-		u8 ie_len;
-	} ies[MAX_NOF_MB_IES_SUPPORTED];
-	u8 nof_ies;
-};
-
 /* Parsed Information Elements */
 struct ieee802_11_elems {
 	const u8 *ssid;
@@ -58,7 +48,6 @@ struct ieee802_11_elems {
 	const u8 *osen;
 	const u8 *ampe;
 	const u8 *mic;
-	const u8 *pref_freq_list;
 
 	u8 ssid_len;
 	u8 supp_rates_len;
@@ -87,8 +76,6 @@ struct ieee802_11_elems {
 	u8 osen_len;
 	u8 ampe_len;
 	u8 mic_len;
-	u8 pref_freq_list_len;
-	struct mb_ies_info mb_ies;
 };
 
 typedef enum { ParseOK = 0, ParseUnknown = 1, ParseFailed = -1 } ParseRes;
@@ -117,9 +104,6 @@ int ieee80211_chan_to_freq(const char *country, u8 op_class, u8 chan);
 int ieee80211_is_dfs(int freq);
 
 int supp_rates_11b_only(struct ieee802_11_elems *elems);
-int mb_ies_info_by_ies(struct mb_ies_info *info, const u8 *ies_buf,
-		       size_t ies_len);
-struct wpabuf * mb_ies_by_info(struct mb_ies_info *info);
 
 const char * fc2str(u16 fc);
 #endif /* IEEE802_11_COMMON_H */
diff --git a/src/common/ieee802_11_defs.h b/src/common/ieee802_11_defs.h
index f33f914..bf621fc 100644
--- a/src/common/ieee802_11_defs.h
+++ b/src/common/ieee802_11_defs.h
@@ -165,9 +165,7 @@
 #define WLAN_STATUS_ANTI_CLOGGING_TOKEN_REQ 76
 #define WLAN_STATUS_FINITE_CYCLIC_GROUP_NOT_SUPPORTED 77
 #define WLAN_STATUS_TRANSMISSION_FAILURE 79
-#define WLAN_STATUS_PENDING_ADMITTING_FST_SESSION 86
 #define WLAN_STATUS_QUERY_RESP_OUTSTANDING 95
-#define WLAN_STATUS_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL 99
 #define WLAN_STATUS_ASSOC_DENIED_NO_VHT 104
 
 /* Reason codes (IEEE 802.11-2007, 7.3.1.7, Table 7-22) */
@@ -273,8 +271,6 @@
 #define WLAN_EID_AMPE 139
 #define WLAN_EID_MIC 140
 #define WLAN_EID_CCKM 156
-#define WLAN_EID_MULTI_BAND 158
-#define WLAN_EID_SESSION_TRANSITION 164
 #define WLAN_EID_VHT_CAP 191
 #define WLAN_EID_VHT_OPERATION 192
 #define WLAN_EID_VHT_EXTENDED_BSS_LOAD 193
@@ -303,7 +299,6 @@
 #define WLAN_ACTION_TDLS 12
 #define WLAN_ACTION_SELF_PROTECTED 15
 #define WLAN_ACTION_WMM 17 /* WMM Specification 1.1 */
-#define WLAN_ACTION_FST 18
 #define WLAN_ACTION_VENDOR_SPECIFIC 127
 
 /* Public action codes */
@@ -620,10 +615,6 @@ struct ieee80211_mgmt {
 					u8 action; /* 15 */
 					u8 variable[];
 				} STRUCT_PACKED slf_prot_action;
-				struct {
-					u8 action;
-					u8 variable[];
-				} STRUCT_PACKED fst_action;
 			} u;
 		} STRUCT_PACKED action;
 	} u;
@@ -1216,6 +1207,10 @@ enum plink_action_field {
 #define WLAN_AKM_SUITE_8021X_SUITE_B_192	0x000FAC12
 #define WLAN_AKM_SUITE_CCKM		0x00409600
 #define WLAN_AKM_SUITE_OSEN		0x506f9a01
+#ifdef CONFIG_WAPI
+#define WLAN_AKM_SUITE_WAPI_PSK	0x000FAC04
+#define WLAN_AKM_SUITE_WAPI_CERT	0x000FAC12
+#endif
 
 
 /* IEEE 802.11v - WNM Action field values */
@@ -1367,60 +1362,4 @@ struct rrm_link_measurement_report {
 
 #define SSID_MAX_LEN 32
 
-/* IEEE Std 802.11ad-2012 - Multi-band element */
-struct multi_band_ie {
-	u8 eid; /* WLAN_EID_MULTI_BAND */
-	u8 len;
-	u8 mb_ctrl;
-	u8 band_id;
-	u8 op_class;
-	u8 chan;
-	u8 bssid[ETH_ALEN];
-	le16 beacon_int;
-	u8 tsf_offs[8];
-	u8 mb_connection_capability;
-	u8 fst_session_tmout;
-	/* Optional:
-	 *   STA MAC Address
-	 *   Pairwise Cipher Suite Count
-	 *   Pairwise Cipher Suite List
-	 */
-	u8 variable[0];
-} STRUCT_PACKED;
-
-enum mb_ctrl_sta_role {
-	MB_STA_ROLE_AP = 0,
-	MB_STA_ROLE_TDLS_STA = 1,
-	MB_STA_ROLE_IBSS_STA = 2,
-	MB_STA_ROLE_PCP = 3,
-	MB_STA_ROLE_NON_PCP_NON_AP = 4
-};
-
-#define MB_CTRL_ROLE_MASK (BIT(0) | BIT(1) | BIT(2))
-#define MB_CTRL_ROLE(ctrl) ((u8) ((ctrl) & MB_CTRL_ROLE_MASK))
-#define MB_CTRL_STA_MAC_PRESENT ((u8) (BIT(3)))
-#define MB_CTRL_PAIRWISE_CIPHER_SUITE_PRESENT ((u8) (BIT(4)))
-
-enum mb_band_id {
-	MB_BAND_ID_WIFI_2_4GHZ = 2, /* 2.4 GHz */
-	MB_BAND_ID_WIFI_5GHZ = 4, /* 4.9 and 5 GHz */
-	MB_BAND_ID_WIFI_60GHZ = 5, /* 60 GHz */
-};
-
-#define MB_CONNECTION_CAPABILITY_AP ((u8) (BIT(0)))
-#define MB_CONNECTION_CAPABILITY_PCP ((u8) (BIT(1)))
-#define MB_CONNECTION_CAPABILITY_DLS ((u8) (BIT(2)))
-#define MB_CONNECTION_CAPABILITY_TDLS ((u8) (BIT(3)))
-#define MB_CONNECTION_CAPABILITY_IBSS ((u8) (BIT(4)))
-
-/* IEEE Std 802.11ad-2014 - FST Action field */
-enum fst_action {
-	FST_ACTION_SETUP_REQUEST = 0,
-	FST_ACTION_SETUP_RESPONSE = 1,
-	FST_ACTION_TEAR_DOWN = 2,
-	FST_ACTION_ACK_REQUEST = 3,
-	FST_ACTION_ACK_RESPONSE = 4,
-	FST_ACTION_ON_CHANNEL_TUNNEL = 5,
-};
-
 #endif /* IEEE802_11_DEFS_H */
diff --git a/src/common/qca-vendor.h b/src/common/qca-vendor.h
index 985143f..3c35e79 100644
--- a/src/common/qca-vendor.h
+++ b/src/common/qca-vendor.h
@@ -152,12 +152,6 @@ enum qca_nl80211_vendor_subcmds {
 	QCA_NL80211_VENDOR_SUBCMD_DCC_UPDATE_NDL = 99,
 	QCA_NL80211_VENDOR_SUBCMD_DCC_STATS_EVENT = 100,
 	QCA_NL80211_VENDOR_SUBCMD_LINK_PROPERTIES = 101,
-	QCA_NL80211_VENDOR_SUBCMD_GW_PARAM_CONFIG = 102,
-	QCA_NL80211_VENDOR_SUBCMD_GET_PREFERRED_FREQ_LIST = 103,
-	QCA_NL80211_VENDOR_SUBCMD_SET_PROBABLE_OPER_CHANNEL = 104,
-	QCA_NL80211_VENDOR_SUBCMD_SETBAND = 105,
-	QCA_NL80211_VENDOR_SUBCMD_TRIGGER_SCAN = 106,
-	QCA_NL80211_VENDOR_SUBCMD_SCAN_DONE = 107,
 };
 
 
@@ -178,15 +172,6 @@ enum qca_wlan_vendor_attr {
 	/* used by QCA_NL80211_VENDOR_SUBCMD_GET_FEATURES */
 	QCA_WLAN_VENDOR_ATTR_FEATURE_FLAGS = 7,
 	QCA_WLAN_VENDOR_ATTR_TEST = 8,
-	/* used by QCA_NL80211_VENDOR_SUBCMD_GET_FEATURES */
-	/* Unsigned 32-bit value. */
-	QCA_WLAN_VENDOR_ATTR_CONCURRENCY_CAPA = 9,
-	/* Unsigned 32-bit value */
-	QCA_WLAN_VENDOR_ATTR_MAX_CONCURRENT_CHANNELS_2_4_BAND = 10,
-	/* Unsigned 32-bit value */
-	QCA_WLAN_VENDOR_ATTR_MAX_CONCURRENT_CHANNELS_5_0_BAND = 11,
-	/* Unsigned 32-bit value from enum qca_set_band. */
-	QCA_WLAN_VENDOR_ATTR_SETBAND_VALUE = 12,
 	/* keep last */
 	QCA_WLAN_VENDOR_ATTR_AFTER_LAST,
 	QCA_WLAN_VENDOR_ATTR_MAX	= QCA_WLAN_VENDOR_ATTR_AFTER_LAST - 1,
@@ -207,7 +192,6 @@ enum qca_wlan_vendor_attr_roam_auth {
 	QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_KEY_REPLAY_CTR,
 	QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_PTK_KCK,
 	QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_PTK_KEK,
-	QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_SUBNET_STATUS,
 	/* keep last */
 	QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_AFTER_LAST,
 	QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_MAX =
@@ -226,7 +210,6 @@ enum qca_wlan_vendor_attr_acs_offload {
 	QCA_WLAN_VENDOR_ATTR_ACS_CH_LIST,
 	QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG0_CENTER_CHANNEL,
 	QCA_WLAN_VENDOR_ATTR_ACS_VHT_SEG1_CENTER_CHANNEL,
-	QCA_WLAN_VENDOR_ATTR_ACS_FREQ_LIST,
 	/* keep last */
 	QCA_WLAN_VENDOR_ATTR_ACS_AFTER_LAST,
 	QCA_WLAN_VENDOR_ATTR_ACS_MAX =
@@ -250,14 +233,11 @@ enum qca_wlan_vendor_acs_hw_mode {
  *	after roaming, rather than having the user space wpa_supplicant do it.
  * @QCA_WLAN_VENDOR_FEATURE_SUPPORT_HW_MODE_ANY: Device supports automatic
  *	band selection based on channel selection results.
- * @QCA_WLAN_VENDOR_FEATURE_OFFCHANNEL_SIMULTANEOUS: Device supports
- * 	simultaneous off-channel operations.
  * @NUM_QCA_WLAN_VENDOR_FEATURES: Number of assigned feature bits
  */
 enum qca_wlan_vendor_features {
 	QCA_WLAN_VENDOR_FEATURE_KEY_MGMT_OFFLOAD	= 0,
 	QCA_WLAN_VENDOR_FEATURE_SUPPORT_HW_MODE_ANY     = 1,
-	QCA_WLAN_VENDOR_FEATURE_OFFCHANNEL_SIMULTANEOUS = 2,
 	NUM_QCA_WLAN_VENDOR_FEATURES /* keep last */
 };
 
@@ -282,134 +262,4 @@ enum qca_wlan_vendor_attr_data_offload_ind {
 	QCA_WLAN_VENDOR_ATTR_DATA_OFFLOAD_IND_MAX =
 	QCA_WLAN_VENDOR_ATTR_DATA_OFFLOAD_IND_AFTER_LAST - 1
 };
-
-enum qca_vendor_attr_get_preferred_freq_list {
-	QCA_WLAN_VENDOR_ATTR_GET_PREFERRED_FREQ_LIST_INVALID,
-	/* A 32-unsigned value; the interface type/mode for which the preferred
-	 * frequency list is requested (see enum qca_iface_type for possible
-	 * values); used in GET_PREFERRED_FREQ_LIST command from user-space to
-	 * kernel and in the kernel response back to user-space.
-	 */
-	QCA_WLAN_VENDOR_ATTR_GET_PREFERRED_FREQ_LIST_IFACE_TYPE,
-	/* An array of 32-unsigned values; values are frequency (MHz); sent
-	 * from kernel space to user space.
-	 */
-	QCA_WLAN_VENDOR_ATTR_GET_PREFERRED_FREQ_LIST,
-	/* keep last */
-	QCA_WLAN_VENDOR_ATTR_GET_PREFERRED_FREQ_LIST_AFTER_LAST,
-	QCA_WLAN_VENDOR_ATTR_GET_PREFERRED_FREQ_LIST_MAX =
-	QCA_WLAN_VENDOR_ATTR_GET_PREFERRED_FREQ_LIST_AFTER_LAST - 1
-};
-
-enum qca_vendor_attr_probable_oper_channel {
-	QCA_WLAN_VENDOR_ATTR_PROBABLE_OPER_CHANNEL_INVALID,
-	/* 32-bit unsigned value; indicates the connection/iface type likely to
-	 * come on this channel (see enum qca_iface_type).
-	 */
-	QCA_WLAN_VENDOR_ATTR_PROBABLE_OPER_CHANNEL_IFACE_TYPE,
-	/* 32-bit unsigned value; the frequency (MHz) of the probable channel */
-	QCA_WLAN_VENDOR_ATTR_PROBABLE_OPER_CHANNEL_FREQ,
-	/* keep last */
-	QCA_WLAN_VENDOR_ATTR_PROBABLE_OPER_CHANNEL_AFTER_LAST,
-	QCA_WLAN_VENDOR_ATTR_PROBABLE_OPER_CHANNEL_MAX =
-	QCA_WLAN_VENDOR_ATTR_PROBABLE_OPER_CHANNEL_AFTER_LAST - 1
-};
-
-enum qca_iface_type {
-	QCA_IFACE_TYPE_STA,
-	QCA_IFACE_TYPE_AP,
-	QCA_IFACE_TYPE_P2P_CLIENT,
-	QCA_IFACE_TYPE_P2P_GO,
-	QCA_IFACE_TYPE_IBSS,
-	QCA_IFACE_TYPE_TDLS,
-};
-
-enum qca_set_band {
-	QCA_SETBAND_AUTO,
-	QCA_SETBAND_5G,
-	QCA_SETBAND_2G,
-};
-
-/* IEEE 802.11 Vendor Specific elements */
-
-/**
- * enum qca_vendor_element_id - QCA Vendor Specific element types
- *
- * These values are used to identify QCA Vendor Specific elements. The
- * payload of the element starts with the three octet OUI (OUI_QCA) and
- * is followed by a single octet type which is defined by this enum.
- *
- * @QCA_VENDOR_ELEM_P2P_PREF_CHAN_LIST: P2P preferred channel list.
- *	This element can be used to specify preference order for supported
- *	channels. The channels in this list are in preference order (the first
- *	one has the highest preference) and are described as a pair of
- *	(global) Operating Class and Channel Number (each one octet) fields.
- *
- *	This extends the standard P2P functionality by providing option to have
- *	more than one preferred operating channel. When this element is present,
- *	it replaces the preference indicated in the Operating Channel attribute.
- *	For supporting other implementations, the Operating Channel attribute is
- *	expected to be used with the highest preference channel. Similarly, all
- *	the channels included in this Preferred channel list element are
- *	expected to be included in the Channel List attribute.
- *
- *	This vendor element may be included in GO Negotiation Request, P2P
- *	Invitation Request, and Provision Discovery Request frames.
- */
-enum qca_vendor_element_id {
-	QCA_VENDOR_ELEM_P2P_PREF_CHAN_LIST = 0,
-};
-
-/**
- * enum qca_wlan_vendor_attr_scan - Specifies vendor scan attributes
- *
- * @QCA_WLAN_VENDOR_ATTR_SCAN_IE: IEs that should be included as part of scan
- * @QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES: Nested unsigned 32-bit attributes
- *	with frequencies to be scanned (in MHz)
- * @QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS: Nested attribute with SSIDs to be scanned
- * @QCA_WLAN_VENDOR_ATTR_SCAN_SUPP_RATES: Nested array attribute of supported
- *	rates to be included
- * @QCA_WLAN_VENDOR_ATTR_SCAN_TX_NO_CCK_RATE: flag used to send probe requests
- * 	at non CCK rate in 2GHz band
- * @QCA_WLAN_VENDOR_ATTR_SCAN_FLAGS: Unsigned 32-bit scan flags
- * @QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE: Unsigned 64-bit cookie provided by the
- * 	driver for the specific scan request
- * @QCA_WLAN_VENDOR_ATTR_SCAN_STATUS: Unsigned 8-bit status of the scan
- * 	request decoded as in enum scan_status
- * @QCA_WLAN_VENDOR_ATTR_SCAN_MAC: 6-byte MAC address to use when randomisation
- * 	scan flag is set
- * @QCA_WLAN_VENDOR_ATTR_SCAN_MAC_MASK: 6-byte MAC address mask to be used with
- * 	randomisation
- */
-enum qca_wlan_vendor_attr_scan {
-	QCA_WLAN_VENDOR_ATTR_SCAN_INVALID_PARAM = 0,
-	QCA_WLAN_VENDOR_ATTR_SCAN_IE,
-	QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES,
-	QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS,
-	QCA_WLAN_VENDOR_ATTR_SCAN_SUPP_RATES,
-	QCA_WLAN_VENDOR_ATTR_SCAN_TX_NO_CCK_RATE,
-	QCA_WLAN_VENDOR_ATTR_SCAN_FLAGS,
-	QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE,
-	QCA_WLAN_VENDOR_ATTR_SCAN_STATUS,
-	QCA_WLAN_VENDOR_ATTR_SCAN_MAC,
-	QCA_WLAN_VENDOR_ATTR_SCAN_MAC_MASK,
-	QCA_WLAN_VENDOR_ATTR_SCAN_AFTER_LAST,
-	QCA_WLAN_VENDOR_ATTR_SCAN_MAX =
-	QCA_WLAN_VENDOR_ATTR_SCAN_AFTER_LAST - 1
-};
-
-/**
- * enum scan_status - Specifies the valid values the vendor scan attribute
- * 	QCA_WLAN_VENDOR_ATTR_SCAN_STATUS can take
- *
- * @VENDOR_SCAN_STATUS_NEW_RESULTS: implies the vendor scan is successful with
- * 	new scan results
- * @VENDOR_SCAN_STATUS_ABORTED: implies the vendor scan was aborted in-between
- */
-enum scan_status {
-	VENDOR_SCAN_STATUS_NEW_RESULTS,
-	VENDOR_SCAN_STATUS_ABORTED,
-	VENDOR_SCAN_STATUS_MAX,
-};
-
 #endif /* QCA_VENDOR_H */
diff --git a/src/common/wpa_ctrl.c b/src/common/wpa_ctrl.c
index 5733aa6..82d4655 100644
--- a/src/common/wpa_ctrl.c
+++ b/src/common/wpa_ctrl.c
@@ -85,13 +85,6 @@ struct wpa_ctrl {
 
 struct wpa_ctrl * wpa_ctrl_open(const char *ctrl_path)
 {
-	return wpa_ctrl_open2(ctrl_path, NULL);
-}
-
-
-struct wpa_ctrl * wpa_ctrl_open2(const char *ctrl_path,
-				 const char *cli_path)
-{
 	struct wpa_ctrl *ctrl;
 	static int counter = 0;
 	int ret;
@@ -115,18 +108,10 @@ struct wpa_ctrl * wpa_ctrl_open2(const char *ctrl_path,
 	ctrl->local.sun_family = AF_UNIX;
 	counter++;
 try_again:
-	if (cli_path && cli_path[0] == '/') {
-		ret = os_snprintf(ctrl->local.sun_path,
-				  sizeof(ctrl->local.sun_path),
-				  "%s/" CONFIG_CTRL_IFACE_CLIENT_PREFIX "%d-%d",
-				  cli_path, (int) getpid(), counter);
-	} else {
-		ret = os_snprintf(ctrl->local.sun_path,
-				  sizeof(ctrl->local.sun_path),
-				  CONFIG_CTRL_IFACE_CLIENT_DIR "/"
-				  CONFIG_CTRL_IFACE_CLIENT_PREFIX "%d-%d",
-				  (int) getpid(), counter);
-	}
+	ret = os_snprintf(ctrl->local.sun_path, sizeof(ctrl->local.sun_path),
+			  CONFIG_CTRL_IFACE_CLIENT_DIR "/"
+			  CONFIG_CTRL_IFACE_CLIENT_PREFIX "%d-%d",
+			  (int) getpid(), counter);
 	if (os_snprintf_error(sizeof(ctrl->local.sun_path), ret)) {
 		close(ctrl->s);
 		os_free(ctrl);
@@ -152,8 +137,6 @@ try_again:
 
 #ifdef ANDROID
 	chmod(ctrl->local.sun_path, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
-	/* Set group even if we do not have privileges to change owner */
-	chown(ctrl->local.sun_path, -1, AID_WIFI);
 	chown(ctrl->local.sun_path, AID_SYSTEM, AID_WIFI);
 
 	if (os_strncmp(ctrl_path, "@android:", 9) == 0) {
diff --git a/src/common/wpa_ctrl.h b/src/common/wpa_ctrl.h
index a36ba21..e700523 100644
--- a/src/common/wpa_ctrl.h
+++ b/src/common/wpa_ctrl.h
@@ -75,19 +75,6 @@ extern "C" {
 /** Regulatory domain channel */
 #define WPA_EVENT_REGDOM_CHANGE "CTRL-EVENT-REGDOM-CHANGE "
 
-/** IP subnet status change notification
- *
- * When using an offloaded roaming mechanism where driver/firmware takes care
- * of roaming and IP subnet validation checks post-roaming, this event can
- * indicate whether IP subnet has changed.
- *
- * The event has a status=<0/1/2> parameter where
- * 0 = unknown
- * 1 = IP subnet unchanged (can continue to use the old IP address)
- * 2 = IP subnet changed (need to get a new IP address)
- */
-#define WPA_EVENT_SUBNET_STATUS_UPDATE "CTRL-EVENT-SUBNET-STATUS-UPDATE "
-
 /** RSN IBSS 4-way handshakes completed with specified peer */
 #define IBSS_RSN_COMPLETED "IBSS-RSN-COMPLETED "
 
@@ -185,7 +172,6 @@ extern "C" {
 #define P2P_EVENT_SERV_ASP_RESP "P2P-SERV-ASP-RESP "
 #define P2P_EVENT_INVITATION_RECEIVED "P2P-INVITATION-RECEIVED "
 #define P2P_EVENT_INVITATION_RESULT "P2P-INVITATION-RESULT "
-#define P2P_EVENT_INVITATION_ACCEPTED "P2P-INVITATION-ACCEPTED "
 #define P2P_EVENT_FIND_STOPPED "P2P-FIND-STOPPED "
 #define P2P_EVENT_PERSISTENT_PSK_FAIL "P2P-PERSISTENT-PSK-FAIL id="
 #define P2P_EVENT_PRESENCE_RESPONSE "P2P-PRESENCE-RESPONSE "
@@ -293,7 +279,6 @@ extern "C" {
 #define WPA_BSS_MASK_MESH_SCAN		BIT(18)
 #define WPA_BSS_MASK_SNR		BIT(19)
 #define WPA_BSS_MASK_EST_THROUGHPUT	BIT(20)
-#define WPA_BSS_MASK_FST		BIT(21)
 
 
 /* VENDOR_ELEM_* frame id values */
@@ -330,20 +315,6 @@ enum wpa_vendor_elem_frame {
  */
 struct wpa_ctrl * wpa_ctrl_open(const char *ctrl_path);
 
-/**
- * wpa_ctrl_open2 - Open a control interface to wpa_supplicant/hostapd
- * @ctrl_path: Path for UNIX domain sockets; ignored if UDP sockets are used.
- * @cli_path: Path for client UNIX domain sockets; ignored if UDP socket
- *            is used.
- * Returns: Pointer to abstract control interface data or %NULL on failure
- *
- * This function is used to open a control interface to wpa_supplicant/hostapd
- * when the socket path for client need to be specified explicitly. Default
- * ctrl_path is usually /var/run/wpa_supplicant or /var/run/hostapd and client
- * socket path is /tmp.
- */
-struct wpa_ctrl * wpa_ctrl_open2(const char *ctrl_path, const char *cli_path);
-
 
 /**
  * wpa_ctrl_close - Close a control interface to wpa_supplicant/hostapd
diff --git a/src/crypto/tls_openssl.c b/src/crypto/tls_openssl.c
index ac2164b..db2d73e 100644
--- a/src/crypto/tls_openssl.c
+++ b/src/crypto/tls_openssl.c
@@ -28,7 +28,6 @@
 #include "crypto.h"
 #include "sha1.h"
 #include "tls.h"
-#include "tls_openssl.h"
 
 #if OPENSSL_VERSION_NUMBER < 0x10000000L
 /* ERR_remove_thread_state replaces ERR_remove_state and the latter is
@@ -905,8 +904,7 @@ static int tls_engine_init(struct tls_connection *conn, const char *engine_id,
 #if !defined(OPENSSL_NO_ENGINE)
 #error "This code depends on OPENSSL_NO_ENGINE being defined by BoringSSL."
 #endif
-	if (!key_id)
-		return TLS_SET_PARAMS_ENGINE_PRV_INIT_FAILED;
+
 	conn->engine = NULL;
 	conn->private_key = EVP_PKEY_from_keystore(key_id);
 	if (!conn->private_key) {
@@ -1641,32 +1639,6 @@ static int tls_verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)
 				       TLS_FAIL_SERVER_CHAIN_PROBE);
 	}
 
-#ifdef OPENSSL_IS_BORINGSSL
-	if (depth == 0 && (conn->flags & TLS_CONN_REQUEST_OCSP) &&
-	    preverify_ok) {
-		enum ocsp_result res;
-
-		res = check_ocsp_resp(conn->ssl_ctx, conn->ssl, err_cert,
-				      conn->peer_issuer,
-				      conn->peer_issuer_issuer);
-		if (res == OCSP_REVOKED) {
-			preverify_ok = 0;
-			openssl_tls_fail_event(conn, err_cert, err, depth, buf,
-					       "certificate revoked",
-					       TLS_FAIL_REVOKED);
-			if (err == X509_V_OK)
-				X509_STORE_CTX_set_error(
-					x509_ctx, X509_V_ERR_CERT_REVOKED);
-		} else if (res != OCSP_GOOD &&
-			   (conn->flags & TLS_CONN_REQUIRE_OCSP)) {
-			preverify_ok = 0;
-			openssl_tls_fail_event(conn, err_cert, err, depth, buf,
-					       "bad certificate status response",
-					       TLS_FAIL_UNSPECIFIED);
-		}
-	}
-#endif /* OPENSSL_IS_BORINGSSL */
-
 	if (preverify_ok && context->event_cb != NULL)
 		context->event_cb(context->cb_ctx,
 				  TLS_CERT_CHAIN_SUCCESS, NULL);
@@ -2111,8 +2083,6 @@ static int tls_parse_pkcs12(SSL_CTX *ssl_ctx, SSL *ssl, PKCS12 *p12,
 	pkey = NULL;
 	cert = NULL;
 	certs = NULL;
-	if (!passwd)
-		passwd = "";
 	if (!PKCS12_parse(p12, passwd, &pkey, &cert, &certs)) {
 		tls_show_errors(MSG_DEBUG, __func__,
 				"Failed to parse PKCS12 file");
@@ -3610,11 +3580,6 @@ int tls_connection_set_params(void *tls_ctx, struct tls_connection *conn,
 		SSL_clear_options(conn->ssl, SSL_OP_NO_TLSv1_2);
 #endif /* SSL_OP_NO_TLSv1_2 */
 
-#ifdef OPENSSL_IS_BORINGSSL
-	if (params->flags & TLS_CONN_REQUEST_OCSP) {
-		SSL_enable_ocsp_stapling(conn->ssl);
-	}
-#else /* OPENSSL_IS_BORINGSSL */
 #ifdef HAVE_OCSP
 	if (params->flags & TLS_CONN_REQUEST_OCSP) {
 		SSL_CTX *ssl_ctx = tls_ctx;
@@ -3622,18 +3587,7 @@ int tls_connection_set_params(void *tls_ctx, struct tls_connection *conn,
 		SSL_CTX_set_tlsext_status_cb(ssl_ctx, ocsp_resp_cb);
 		SSL_CTX_set_tlsext_status_arg(ssl_ctx, conn);
 	}
-#else /* HAVE_OCSP */
-	if (params->flags & TLS_CONN_REQUIRE_OCSP) {
-		wpa_printf(MSG_INFO,
-			   "OpenSSL: No OCSP support included - reject configuration");
-		return -1;
-	}
-	if (params->flags & TLS_CONN_REQUEST_OCSP) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: No OCSP support included - allow optional OCSP case to continue");
-	}
 #endif /* HAVE_OCSP */
-#endif /* OPENSSL_IS_BORINGSSL */
 
 	conn->flags = params->flags;
 
diff --git a/src/crypto/tls_openssl.h b/src/crypto/tls_openssl.h
deleted file mode 100644
index 2a62d5c..0000000
--- a/src/crypto/tls_openssl.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * SSL/TLS interface functions for OpenSSL
- * Copyright (c) 2004-2015, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef TLS_OPENSSL_H
-#define TLS_OPENSSL_H
-
-enum ocsp_result {
-	OCSP_GOOD, OCSP_REVOKED, OCSP_NO_RESPONSE, OCSP_INVALID
-};
-
-enum ocsp_result check_ocsp_resp(SSL_CTX *ssl_ctx, SSL *ssl, X509 *cert,
-				 X509 *issuer, X509 *issuer_issuer);
-
-#endif /* TLS_OPENSSL_H */
diff --git a/src/crypto/tls_openssl_ocsp.c b/src/crypto/tls_openssl_ocsp.c
deleted file mode 100644
index 37c87f4..0000000
--- a/src/crypto/tls_openssl_ocsp.c
+++ /dev/null
@@ -1,843 +0,0 @@
-/*
- * SSL/TLS interface functions for OpenSSL - BoringSSL OCSP
- * Copyright (c) 2004-2015, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "includes.h"
-
-#include <openssl/ssl.h>
-#include <openssl/err.h>
-#include <openssl/x509v3.h>
-#ifdef OPENSSL_IS_BORINGSSL
-#include <openssl/asn1.h>
-#include <openssl/asn1t.h>
-#endif /* OPENSSL_IS_BORINGSSL */
-
-#include "common.h"
-#include "tls_openssl.h"
-
-
-#ifdef OPENSSL_IS_BORINGSSL
-
-static void tls_show_errors(int level, const char *func, const char *txt)
-{
-	unsigned long err;
-
-	wpa_printf(level, "OpenSSL: %s - %s %s",
-		   func, txt, ERR_error_string(ERR_get_error(), NULL));
-
-	while ((err = ERR_get_error())) {
-		wpa_printf(MSG_INFO, "OpenSSL: pending error: %s",
-			   ERR_error_string(err, NULL));
-	}
-}
-
-
-/*
- * CertID ::= SEQUENCE {
- *     hashAlgorithm      AlgorithmIdentifier,
- *     issuerNameHash     OCTET STRING, -- Hash of Issuer's DN
- *     issuerKeyHash      OCTET STRING, -- Hash of Issuer's public key
- *     serialNumber       CertificateSerialNumber }
- */
-typedef struct {
-	X509_ALGOR *hashAlgorithm;
-	ASN1_OCTET_STRING *issuerNameHash;
-	ASN1_OCTET_STRING *issuerKeyHash;
-	ASN1_INTEGER *serialNumber;
-} CertID;
-
-/*
- * ResponseBytes ::=       SEQUENCE {
- *     responseType   OBJECT IDENTIFIER,
- *     response       OCTET STRING }
- */
-typedef struct {
-	ASN1_OBJECT *responseType;
-	ASN1_OCTET_STRING *response;
-} ResponseBytes;
-
-/*
- * OCSPResponse ::= SEQUENCE {
- *    responseStatus         OCSPResponseStatus,
- *    responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
- */
-typedef struct {
-	ASN1_ENUMERATED *responseStatus;
-	ResponseBytes *responseBytes;
-} OCSPResponse;
-
-ASN1_SEQUENCE(ResponseBytes) = {
-	ASN1_SIMPLE(ResponseBytes, responseType, ASN1_OBJECT),
-	ASN1_SIMPLE(ResponseBytes, response, ASN1_OCTET_STRING)
-} ASN1_SEQUENCE_END(ResponseBytes);
-
-ASN1_SEQUENCE(OCSPResponse) = {
-	ASN1_SIMPLE(OCSPResponse, responseStatus, ASN1_ENUMERATED),
-	ASN1_EXP_OPT(OCSPResponse, responseBytes, ResponseBytes, 0)
-} ASN1_SEQUENCE_END(OCSPResponse);
-
-IMPLEMENT_ASN1_FUNCTIONS(OCSPResponse);
-
-/*
- * ResponderID ::= CHOICE {
- *    byName               [1] Name,
- *    byKey                [2] KeyHash }
- */
-typedef struct {
-	int type;
-	union {
-		X509_NAME *byName;
-		ASN1_OCTET_STRING *byKey;
-	} value;
-} ResponderID;
-
-/*
- * RevokedInfo ::= SEQUENCE {
- *     revocationTime              GeneralizedTime,
- *     revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
- */
-typedef struct {
-	ASN1_GENERALIZEDTIME *revocationTime;
-	ASN1_ENUMERATED *revocationReason;
-} RevokedInfo;
-
-/*
- * CertStatus ::= CHOICE {
- *     good        [0]     IMPLICIT NULL,
- *     revoked     [1]     IMPLICIT RevokedInfo,
- *     unknown     [2]     IMPLICIT UnknownInfo }
- */
-typedef struct {
-	int type;
-	union {
-		ASN1_NULL *good;
-		RevokedInfo *revoked;
-		ASN1_NULL *unknown;
-	} value;
-} CertStatus;
-
-/*
- * SingleResponse ::= SEQUENCE {
- *    certID                       CertID,
- *    certStatus                   CertStatus,
- *    thisUpdate                   GeneralizedTime,
- *    nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
- *    singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
- */
-typedef struct {
-	CertID *certID;
-	CertStatus *certStatus;
-	ASN1_GENERALIZEDTIME *thisUpdate;
-	ASN1_GENERALIZEDTIME *nextUpdate;
-	STACK_OF(X509_EXTENSION) *singleExtensions;
-} SingleResponse;
-
-/*
- * ResponseData ::= SEQUENCE {
- *   version              [0] EXPLICIT Version DEFAULT v1,
- *   responderID              ResponderID,
- *   producedAt               GeneralizedTime,
- *   responses                SEQUENCE OF SingleResponse,
- *   responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
- */
-typedef struct {
-	ASN1_INTEGER *version;
-	ResponderID *responderID;
-	ASN1_GENERALIZEDTIME *producedAt;
-	STACK_OF(SingleResponse) *responses;
-	STACK_OF(X509_EXTENSION) *responseExtensions;
-} ResponseData;
-
-/*
- * BasicOCSPResponse       ::= SEQUENCE {
- *   tbsResponseData      ResponseData,
- *   signatureAlgorithm   AlgorithmIdentifier,
- *   signature            BIT STRING,
- *   certs                [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }
- */
-typedef struct {
-	ResponseData *tbsResponseData;
-	X509_ALGOR *signatureAlgorithm;
-	ASN1_BIT_STRING *signature;
-	STACK_OF(X509) *certs;
-} BasicOCSPResponse;
-
-ASN1_SEQUENCE(CertID) = {
-	ASN1_SIMPLE(CertID, hashAlgorithm, X509_ALGOR),
-	ASN1_SIMPLE(CertID, issuerNameHash, ASN1_OCTET_STRING),
-	ASN1_SIMPLE(CertID, issuerKeyHash, ASN1_OCTET_STRING),
-	ASN1_SIMPLE(CertID, serialNumber, ASN1_INTEGER)
-} ASN1_SEQUENCE_END(CertID);
-
-ASN1_CHOICE(ResponderID) = {
-	ASN1_EXP(ResponderID, value.byName, X509_NAME, 1),
-	ASN1_EXP(ResponderID, value.byKey, ASN1_OCTET_STRING, 2)
-} ASN1_CHOICE_END(ResponderID);
-
-ASN1_SEQUENCE(RevokedInfo) = {
-	ASN1_SIMPLE(RevokedInfo, revocationTime, ASN1_GENERALIZEDTIME),
-	ASN1_EXP_OPT(RevokedInfo, revocationReason, ASN1_ENUMERATED, 0)
-} ASN1_SEQUENCE_END(RevokedInfo);
-
-ASN1_CHOICE(CertStatus) = {
-	ASN1_IMP(CertStatus, value.good, ASN1_NULL, 0),
-	ASN1_IMP(CertStatus, value.revoked, RevokedInfo, 1),
-	ASN1_IMP(CertStatus, value.unknown, ASN1_NULL, 2)
-} ASN1_CHOICE_END(CertStatus);
-
-ASN1_SEQUENCE(SingleResponse) = {
-	ASN1_SIMPLE(SingleResponse, certID, CertID),
-	ASN1_SIMPLE(SingleResponse, certStatus, CertStatus),
-	ASN1_SIMPLE(SingleResponse, thisUpdate, ASN1_GENERALIZEDTIME),
-	ASN1_EXP_OPT(SingleResponse, nextUpdate, ASN1_GENERALIZEDTIME, 0),
-	ASN1_EXP_SEQUENCE_OF_OPT(SingleResponse, singleExtensions,
-				 X509_EXTENSION, 1)
-} ASN1_SEQUENCE_END(SingleResponse);
-
-ASN1_SEQUENCE(ResponseData) = {
-	ASN1_EXP_OPT(ResponseData, version, ASN1_INTEGER, 0),
-	ASN1_SIMPLE(ResponseData, responderID, ResponderID),
-	ASN1_SIMPLE(ResponseData, producedAt, ASN1_GENERALIZEDTIME),
-	ASN1_SEQUENCE_OF(ResponseData, responses, SingleResponse),
-	ASN1_EXP_SEQUENCE_OF_OPT(ResponseData, responseExtensions,
-				 X509_EXTENSION, 1)
-} ASN1_SEQUENCE_END(ResponseData);
-
-ASN1_SEQUENCE(BasicOCSPResponse) = {
-	ASN1_SIMPLE(BasicOCSPResponse, tbsResponseData, ResponseData),
-	ASN1_SIMPLE(BasicOCSPResponse, signatureAlgorithm, X509_ALGOR),
-	ASN1_SIMPLE(BasicOCSPResponse, signature, ASN1_BIT_STRING),
-	ASN1_EXP_SEQUENCE_OF_OPT(BasicOCSPResponse, certs, X509, 0)
-} ASN1_SEQUENCE_END(BasicOCSPResponse);
-
-IMPLEMENT_ASN1_FUNCTIONS(BasicOCSPResponse);
-
-#define sk_SingleResponse_num(sk) \
-sk_num(CHECKED_CAST(_STACK *, STACK_OF(SingleResponse) *, sk))
-
-#define sk_SingleResponse_value(sk, i) \
-	((SingleResponse *)						\
-	 sk_value(CHECKED_CAST(_STACK *, STACK_OF(SingleResponse) *, sk), (i)))
-
-
-static char * mem_bio_to_str(BIO *out)
-{
-	char *txt;
-	size_t rlen;
-	int res;
-
-	rlen = BIO_ctrl_pending(out);
-	txt = os_malloc(rlen + 1);
-	if (!txt) {
-		BIO_free(out);
-		return NULL;
-	}
-
-	res = BIO_read(out, txt, rlen);
-	BIO_free(out);
-	if (res < 0) {
-		os_free(txt);
-		return NULL;
-	}
-
-	txt[res] = '\0';
-	return txt;
-}
-
-
-static char * generalizedtime_str(ASN1_GENERALIZEDTIME *t)
-{
-	BIO *out;
-
-	out = BIO_new(BIO_s_mem());
-	if (!out)
-		return NULL;
-
-	if (!ASN1_GENERALIZEDTIME_print(out, t)) {
-		BIO_free(out);
-		return NULL;
-	}
-
-	return mem_bio_to_str(out);
-}
-
-
-static char * responderid_str(ResponderID *rid)
-{
-	BIO *out;
-
-	out = BIO_new(BIO_s_mem());
-	if (!out)
-		return NULL;
-
-	switch (rid->type) {
-	case 0:
-		X509_NAME_print_ex(out, rid->value.byName, 0, XN_FLAG_ONELINE);
-		break;
-	case 1:
-		i2a_ASN1_STRING(out, rid->value.byKey, V_ASN1_OCTET_STRING);
-		break;
-	default:
-		BIO_free(out);
-		return NULL;
-	}
-
-	return mem_bio_to_str(out);
-}
-
-
-static char * octet_string_str(ASN1_OCTET_STRING *o)
-{
-	BIO *out;
-
-	out = BIO_new(BIO_s_mem());
-	if (!out)
-		return NULL;
-
-	i2a_ASN1_STRING(out, o, V_ASN1_OCTET_STRING);
-	return mem_bio_to_str(out);
-}
-
-
-static char * integer_str(ASN1_INTEGER *i)
-{
-	BIO *out;
-
-	out = BIO_new(BIO_s_mem());
-	if (!out)
-		return NULL;
-
-	i2a_ASN1_INTEGER(out, i);
-	return mem_bio_to_str(out);
-}
-
-
-static char * algor_str(X509_ALGOR *alg)
-{
-	BIO *out;
-
-	out = BIO_new(BIO_s_mem());
-	if (!out)
-		return NULL;
-
-	i2a_ASN1_OBJECT(out, alg->algorithm);
-	return mem_bio_to_str(out);
-}
-
-
-static char * extensions_str(const char *title, STACK_OF(X509_EXTENSION) *ext)
-{
-	BIO *out;
-
-	if (!ext)
-		return NULL;
-
-	out = BIO_new(BIO_s_mem());
-	if (!out)
-		return NULL;
-
-	if (!X509V3_extensions_print(out, title, ext, 0, 0)) {
-		BIO_free(out);
-		return NULL;
-	}
-	return mem_bio_to_str(out);
-}
-
-
-static int ocsp_resp_valid(ASN1_GENERALIZEDTIME *thisupd,
-			   ASN1_GENERALIZEDTIME *nextupd)
-{
-	time_t now, tmp;
-
-	if (!ASN1_GENERALIZEDTIME_check(thisupd)) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: Invalid OCSP response thisUpdate");
-		return 0;
-	}
-
-	time(&now);
-	tmp = now + 5 * 60; /* allow five minute clock difference */
-	if (X509_cmp_time(thisupd, &tmp) > 0) {
-		wpa_printf(MSG_DEBUG, "OpenSSL: OCSP response not yet valid");
-		return 0;
-	}
-
-	if (!nextupd)
-		return 1; /* OK - no limit on response age */
-
-	if (!ASN1_GENERALIZEDTIME_check(nextupd)) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: Invalid OCSP response nextUpdate");
-		return 0;
-	}
-
-	tmp = now - 5 * 60; /* allow five minute clock difference */
-	if (X509_cmp_time(nextupd, &tmp) < 0) {
-		wpa_printf(MSG_DEBUG, "OpenSSL: OCSP response expired");
-		return 0;
-	}
-
-	if (ASN1_STRING_cmp(nextupd, thisupd) < 0) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: OCSP response nextUpdate before thisUpdate");
-		return 0;
-	}
-
-	/* Both thisUpdate and nextUpdate are valid */
-	return -1;
-}
-
-
-static int issuer_match(X509 *cert, X509 *issuer, CertID *certid)
-{
-	X509_NAME *iname;
-	ASN1_BIT_STRING *ikey;
-	const EVP_MD *dgst;
-	unsigned int len;
-	unsigned char md[EVP_MAX_MD_SIZE];
-	ASN1_OCTET_STRING *hash;
-	char *txt;
-
-	dgst = EVP_get_digestbyobj(certid->hashAlgorithm->algorithm);
-	if (!dgst) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: Could not find matching hash algorithm for OCSP");
-		return -1;
-	}
-
-	iname = X509_get_issuer_name(cert);
-	if (!X509_NAME_digest(iname, dgst, md, &len))
-		return -1;
-	hash = ASN1_OCTET_STRING_new();
-	if (!hash)
-		return -1;
-	if (!ASN1_OCTET_STRING_set(hash, md, len)) {
-		ASN1_OCTET_STRING_free(hash);
-		return -1;
-	}
-
-	txt = octet_string_str(hash);
-	if (txt) {
-		wpa_printf(MSG_DEBUG, "OpenSSL: calculated issuerNameHash: %s",
-			   txt);
-		os_free(txt);
-	}
-
-	if (ASN1_OCTET_STRING_cmp(certid->issuerNameHash, hash)) {
-		ASN1_OCTET_STRING_free(hash);
-		return -1;
-	}
-
-	ikey = X509_get0_pubkey_bitstr(issuer);
-	if (!EVP_Digest(ikey->data, ikey->length, md, &len, dgst, NULL) ||
-	    !ASN1_OCTET_STRING_set(hash, md, len)) {
-		ASN1_OCTET_STRING_free(hash);
-		return -1;
-	}
-
-	txt = octet_string_str(hash);
-	if (txt) {
-		wpa_printf(MSG_DEBUG, "OpenSSL: calculated issuerKeyHash: %s",
-			   txt);
-		os_free(txt);
-	}
-
-	if (ASN1_OCTET_STRING_cmp(certid->issuerKeyHash, hash)) {
-		ASN1_OCTET_STRING_free(hash);
-		return -1;
-	}
-
-	ASN1_OCTET_STRING_free(hash);
-	return 0;
-}
-
-
-static X509 * ocsp_find_signer(STACK_OF(X509) *certs, ResponderID *rid)
-{
-	unsigned int i;
-	unsigned char hash[SHA_DIGEST_LENGTH];
-
-	if (rid->type == 0) {
-		/* byName */
-		return X509_find_by_subject(certs, rid->value.byName);
-	}
-
-	/* byKey */
-	if (rid->value.byKey->length != SHA_DIGEST_LENGTH)
-		return NULL;
-	for (i = 0; i < sk_X509_num(certs); i++) {
-		X509 *x = sk_X509_value(certs, i);
-
-		X509_pubkey_digest(x, EVP_sha1(), hash, NULL);
-		if (os_memcmp(rid->value.byKey->data, hash,
-			      SHA_DIGEST_LENGTH) == 0)
-			return x;
-	}
-
-	return NULL;
-}
-
-
-enum ocsp_result check_ocsp_resp(SSL_CTX *ssl_ctx, SSL *ssl, X509 *cert,
-				 X509 *issuer, X509 *issuer_issuer)
-{
-	const uint8_t *resp_data;
-	size_t resp_len;
-	OCSPResponse *resp;
-	int status;
-	ResponseBytes *bytes;
-	const u8 *basic_data;
-	size_t basic_len;
-	BasicOCSPResponse *basic;
-	ResponseData *rd;
-	char *txt;
-	int i, num;
-	unsigned int j, num_resp;
-	SingleResponse *matching_resp = NULL, *cmp_sresp;
-	enum ocsp_result result = OCSP_INVALID;
-	X509_STORE *store;
-	STACK_OF(X509) *untrusted = NULL, *certs = NULL, *chain = NULL;
-	X509_STORE_CTX ctx;
-	X509 *signer, *tmp_cert;
-	int signer_trusted = 0;
-	EVP_PKEY *skey;
-	int ret;
-	char buf[256];
-
-	txt = integer_str(X509_get_serialNumber(cert));
-	if (txt) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: Searching OCSP response for peer certificate serialNumber: %s", txt);
-		os_free(txt);
-	}
-
-	SSL_get0_ocsp_response(ssl, &resp_data, &resp_len);
-	if (resp_data == NULL || resp_len == 0) {
-		wpa_printf(MSG_DEBUG, "OpenSSL: No OCSP response received");
-		return OCSP_NO_RESPONSE;
-	}
-
-	wpa_hexdump(MSG_DEBUG, "OpenSSL: OCSP response", resp_data, resp_len);
-
-	resp = d2i_OCSPResponse(NULL, &resp_data, resp_len);
-	if (!resp) {
-		wpa_printf(MSG_INFO, "OpenSSL: Failed to parse OCSPResponse");
-		return OCSP_INVALID;
-	}
-
-	status = ASN1_ENUMERATED_get(resp->responseStatus);
-	if (status != 0) {
-		wpa_printf(MSG_INFO, "OpenSSL: OCSP responder error %d",
-			   status);
-		return OCSP_INVALID;
-	}
-
-	bytes = resp->responseBytes;
-
-	if (!bytes ||
-	    OBJ_obj2nid(bytes->responseType) != NID_id_pkix_OCSP_basic) {
-		wpa_printf(MSG_INFO,
-			   "OpenSSL: Could not find BasicOCSPResponse");
-		return OCSP_INVALID;
-	}
-
-	basic_data = ASN1_STRING_data(bytes->response);
-	basic_len = ASN1_STRING_length(bytes->response);
-	wpa_hexdump(MSG_DEBUG, "OpenSSL: BasicOCSPResponse",
-		    basic_data, basic_len);
-
-	basic = d2i_BasicOCSPResponse(NULL, &basic_data, basic_len);
-	if (!basic) {
-		wpa_printf(MSG_INFO,
-			   "OpenSSL: Could not parse BasicOCSPResponse");
-		OCSPResponse_free(resp);
-		return OCSP_INVALID;
-	}
-
-	rd = basic->tbsResponseData;
-
-	if (basic->certs) {
-		untrusted = sk_X509_dup(basic->certs);
-
-		num = sk_X509_num(basic->certs);
-		for (i = 0; i < num; i++) {
-			X509 *extra_cert;
-
-			extra_cert = sk_X509_value(basic->certs, i);
-			X509_NAME_oneline(X509_get_subject_name(extra_cert),
-					  buf, sizeof(buf));
-			wpa_printf(MSG_DEBUG,
-				   "OpenSSL: BasicOCSPResponse cert %s", buf);
-
-			if (!sk_X509_push(untrusted, extra_cert)) {
-				wpa_printf(MSG_DEBUG,
-					   "OpenSSL: Could not add certificate to the untrusted stack");
-			}
-		}
-	}
-
-	store = SSL_CTX_get_cert_store(ssl_ctx);
-	if (issuer) {
-		if (X509_STORE_add_cert(store, issuer) != 1) {
-			tls_show_errors(MSG_INFO, __func__,
-					"OpenSSL: Could not add issuer to certificate store");
-		}
-		certs = sk_X509_new_null();
-		if (certs) {
-			tmp_cert = X509_dup(issuer);
-			if (tmp_cert && !sk_X509_push(certs, tmp_cert)) {
-				tls_show_errors(
-					MSG_INFO, __func__,
-					"OpenSSL: Could not add issuer to OCSP responder trust store");
-				X509_free(tmp_cert);
-				sk_X509_free(certs);
-				certs = NULL;
-			}
-			if (certs && issuer_issuer) {
-				tmp_cert = X509_dup(issuer_issuer);
-				if (tmp_cert &&
-				    !sk_X509_push(certs, tmp_cert)) {
-					tls_show_errors(
-						MSG_INFO, __func__,
-						"OpenSSL: Could not add issuer's issuer to OCSP responder trust store");
-					X509_free(tmp_cert);
-				}
-			}
-		}
-	}
-
-	signer = ocsp_find_signer(certs, rd->responderID);
-	if (!signer)
-		signer = ocsp_find_signer(untrusted, rd->responderID);
-	else
-		signer_trusted = 1;
-	if (!signer) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: Could not find OCSP signer certificate");
-		goto fail;
-	}
-
-	skey = X509_get_pubkey(signer);
-	if (!skey) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: Could not get OCSP signer public key");
-		goto fail;
-	}
-	if (ASN1_item_verify(ASN1_ITEM_rptr(ResponseData),
-			     basic->signatureAlgorithm, basic->signature,
-			     basic->tbsResponseData, skey) <= 0) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: BasicOCSPResponse signature is invalid");
-		goto fail;
-	}
-
-	X509_NAME_oneline(X509_get_subject_name(signer), buf, sizeof(buf));
-	wpa_printf(MSG_DEBUG,
-		   "OpenSSL: Found OCSP signer certificate %s and verified BasicOCSPResponse signature",
-		   buf);
-
-	if (!X509_STORE_CTX_init(&ctx, store, signer, untrusted))
-		goto fail;
-	X509_STORE_CTX_set_purpose(&ctx, X509_PURPOSE_OCSP_HELPER);
-	ret = X509_verify_cert(&ctx);
-	chain = X509_STORE_CTX_get1_chain(&ctx);
-	X509_STORE_CTX_cleanup(&ctx);
-	if (ret <= 0) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: Could not validate OCSP signer certificate");
-		goto fail;
-	}
-
-	if (!chain || sk_X509_num(chain) <= 0) {
-		wpa_printf(MSG_DEBUG, "OpenSSL: No OCSP signer chain found");
-		goto fail;
-	}
-
-	if (!signer_trusted) {
-		X509_check_purpose(signer, -1, 0);
-		if ((signer->ex_flags & EXFLAG_XKUSAGE) &&
-		    (signer->ex_xkusage & XKU_OCSP_SIGN)) {
-			wpa_printf(MSG_DEBUG,
-				   "OpenSSL: OCSP signer certificate delegation OK");
-		} else {
-			tmp_cert = sk_X509_value(chain, sk_X509_num(chain) - 1);
-			if (X509_check_trust(tmp_cert, NID_OCSP_sign, 0) !=
-			    X509_TRUST_TRUSTED) {
-				wpa_printf(MSG_DEBUG,
-					   "OpenSSL: OCSP signer certificate not trusted");
-				result = OCSP_NO_RESPONSE;
-				goto fail;
-			}
-		}
-	}
-
-	wpa_printf(MSG_DEBUG, "OpenSSL: OCSP version: %lu",
-		   ASN1_INTEGER_get(rd->version));
-
-	txt = responderid_str(rd->responderID);
-	if (txt) {
-		wpa_printf(MSG_DEBUG, "OpenSSL: OCSP responderID: %s",
-			   txt);
-		os_free(txt);
-	}
-
-	txt = generalizedtime_str(rd->producedAt);
-	if (txt) {
-		wpa_printf(MSG_DEBUG, "OpenSSL: OCSP producedAt: %s",
-			   txt);
-		os_free(txt);
-	}
-
-	num_resp = sk_SingleResponse_num(rd->responses);
-	if (num_resp == 0) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: No OCSP SingleResponse within BasicOCSPResponse");
-		result = OCSP_NO_RESPONSE;
-		goto fail;
-	}
-	cmp_sresp = sk_SingleResponse_value(rd->responses, 0);
-	for (j = 0; j < num_resp; j++) {
-		SingleResponse *sresp;
-		CertID *cid1, *cid2;
-
-		sresp = sk_SingleResponse_value(rd->responses, j);
-		wpa_printf(MSG_DEBUG, "OpenSSL: OCSP SingleResponse %u/%u",
-			   j + 1, num_resp);
-
-		txt = algor_str(sresp->certID->hashAlgorithm);
-		if (txt) {
-			wpa_printf(MSG_DEBUG,
-				   "OpenSSL: certID hashAlgorithm: %s", txt);
-			os_free(txt);
-		}
-
-		txt = octet_string_str(sresp->certID->issuerNameHash);
-		if (txt) {
-			wpa_printf(MSG_DEBUG,
-				   "OpenSSL: certID issuerNameHash: %s", txt);
-			os_free(txt);
-		}
-
-		txt = octet_string_str(sresp->certID->issuerKeyHash);
-		if (txt) {
-			wpa_printf(MSG_DEBUG,
-				   "OpenSSL: certID issuerKeyHash: %s", txt);
-			os_free(txt);
-		}
-
-		txt = integer_str(sresp->certID->serialNumber);
-		if (txt) {
-			wpa_printf(MSG_DEBUG,
-				   "OpenSSL: certID serialNumber: %s", txt);
-			os_free(txt);
-		}
-
-		switch (sresp->certStatus->type) {
-		case 0:
-			wpa_printf(MSG_DEBUG, "OpenSSL: certStatus: good");
-			break;
-		case 1:
-			wpa_printf(MSG_DEBUG, "OpenSSL: certStatus: revoked");
-			break;
-		default:
-			wpa_printf(MSG_DEBUG, "OpenSSL: certStatus: unknown");
-			break;
-		}
-
-		txt = generalizedtime_str(sresp->thisUpdate);
-		if (txt) {
-			wpa_printf(MSG_DEBUG, "OpenSSL: thisUpdate: %s", txt);
-			os_free(txt);
-		}
-
-		if (sresp->nextUpdate) {
-			txt = generalizedtime_str(sresp->nextUpdate);
-			if (txt) {
-				wpa_printf(MSG_DEBUG, "OpenSSL: nextUpdate: %s",
-					   txt);
-				os_free(txt);
-			}
-		}
-
-		txt = extensions_str("singleExtensions",
-				     sresp->singleExtensions);
-		if (txt) {
-			wpa_printf(MSG_DEBUG, "OpenSSL: %s", txt);
-			os_free(txt);
-		}
-
-		cid1 = cmp_sresp->certID;
-		cid2 = sresp->certID;
-		if (j > 0 &&
-		    (OBJ_cmp(cid1->hashAlgorithm->algorithm,
-			     cid2->hashAlgorithm->algorithm) != 0 ||
-		     ASN1_OCTET_STRING_cmp(cid1->issuerNameHash,
-					   cid2->issuerNameHash) != 0 ||
-		     ASN1_OCTET_STRING_cmp(cid1->issuerKeyHash,
-					   cid2->issuerKeyHash) != 0)) {
-			wpa_printf(MSG_DEBUG,
-				   "OpenSSL: Different OCSP response issuer information between SingleResponse values within BasicOCSPResponse");
-			goto fail;
-		}
-
-		if (!matching_resp && issuer &&
-		    ASN1_INTEGER_cmp(sresp->certID->serialNumber,
-				     X509_get_serialNumber(cert)) == 0 &&
-		    issuer_match(cert, issuer, sresp->certID) == 0) {
-			wpa_printf(MSG_DEBUG,
-				   "OpenSSL: This response matches peer certificate");
-			matching_resp = sresp;
-		}
-	}
-
-	txt = extensions_str("responseExtensions", rd->responseExtensions);
-	if (txt) {
-		wpa_printf(MSG_DEBUG, "OpenSSL: %s", txt);
-		os_free(txt);
-	}
-
-	if (!matching_resp) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: Could not find OCSP response that matches the peer certificate");
-		result = OCSP_NO_RESPONSE;
-		goto fail;
-	}
-
-	if (!ocsp_resp_valid(matching_resp->thisUpdate,
-			     matching_resp->nextUpdate)) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: OCSP response not valid at this time");
-		goto fail;
-	}
-
-	if (matching_resp->certStatus->type == 1) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: OCSP response indicated that the peer certificate has been revoked");
-		result = OCSP_REVOKED;
-		goto fail;
-	}
-
-	if (matching_resp->certStatus->type != 0) {
-		wpa_printf(MSG_DEBUG,
-			   "OpenSSL: OCSP response did not indicate good status");
-		result = OCSP_NO_RESPONSE;
-		goto fail;
-	}
-
-	/* OCSP response indicated the certificate is good. */
-	result = OCSP_GOOD;
-fail:
-	sk_X509_pop_free(chain, X509_free);
-	sk_X509_free(untrusted);
-	sk_X509_pop_free(certs, X509_free);
-	BasicOCSPResponse_free(basic);
-	OCSPResponse_free(resp);
-
-	return result;
-}
-
-#endif /* OPENSSL_IS_BORINGSSL */
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 1abfc1f..68d7627 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -45,15 +45,6 @@
 #define HOSTAPD_CHAN_INDOOR_ONLY 0x00010000
 #define HOSTAPD_CHAN_GO_CONCURRENT 0x00020000
 
-#define HOSTAPD_CHAN_VHT_10_150 0x00100000
-#define HOSTAPD_CHAN_VHT_30_130 0x00200000
-#define HOSTAPD_CHAN_VHT_50_110 0x00400000
-#define HOSTAPD_CHAN_VHT_70_90  0x00800000
-#define HOSTAPD_CHAN_VHT_90_70  0x01000000
-#define HOSTAPD_CHAN_VHT_110_50 0x02000000
-#define HOSTAPD_CHAN_VHT_130_30 0x04000000
-#define HOSTAPD_CHAN_VHT_150_10 0x08000000
-
 /**
  * enum reg_change_initiator - Regulatory change initiator
  */
@@ -416,15 +407,6 @@ struct wpa_driver_scan_params {
 	 */
 	const u8 *mac_addr_mask;
 
-	/**
-	 * bssid - Specific BSSID to scan for
-	 *
-	 * This optional parameter can be used to replace the default wildcard
-	 * BSSID with a specific BSSID to scan for if results are needed from
-	 * only a single BSS.
-	 */
-	const u8 *bssid;
-
 	/*
 	 * NOTE: Whenever adding new parameters here, please make sure
 	 * wpa_scan_clone_params() and wpa_scan_free_params() get updated with
@@ -846,12 +828,6 @@ struct wpa_driver_associate_params {
 	 * RRM (Radio Resource Measurements)
 	 */
 	int rrm_used;
-
-	/**
-	 * pbss - If set, connect to a PCP in a PBSS. Otherwise, connect to an
-	 * AP as usual. Valid for DMG network only.
-	 */
-	int pbss;
 };
 
 enum hide_ssid {
@@ -1079,12 +1055,6 @@ struct wpa_driver_ap_params {
 	 * reenable - Whether this is to re-enable beaconing
 	 */
 	int reenable;
-
-	/**
-	 * pbss - Whether to start a PCP (in PBSS) instead of an AP in
-	 * infrastructure BSS. Valid only for DMG network.
-	 */
-	int pbss;
 };
 
 struct wpa_driver_mesh_bss_params {
@@ -1244,8 +1214,6 @@ struct wpa_driver_capa {
 #define WPA_DRIVER_FLAGS_VHT_IBSS		0x0000002000000000ULL
 /** Driver supports automatic band selection */
 #define WPA_DRIVER_FLAGS_SUPPORT_HW_MODE_ANY	0x0000004000000000ULL
-/** Driver supports simultaneous off-channel operations */
-#define WPA_DRIVER_FLAGS_OFFCHANNEL_SIMULTANEOUS	0x0000008000000000ULL
 	u64 flags;
 
 #define WPA_DRIVER_SMPS_MODE_STATIC			0x00000001
@@ -1329,13 +1297,6 @@ struct wpa_driver_capa {
  */
 #define WPA_DRIVER_FLAGS_TX_POWER_INSERTION		0x00000008
 	u32 rrm_flags;
-
-	/* Driver concurrency capabilities */
-	unsigned int conc_capab;
-	/* Maximum number of concurrent channels on 2.4 GHz */
-	unsigned int max_conc_chan_2_4;
-	/* Maximum number of concurrent channels on 5 GHz */
-	unsigned int max_conc_chan_5_0;
 };
 
 
@@ -1436,16 +1397,6 @@ enum wpa_driver_if_type {
 	 * WPA_IF_MESH - Mesh interface
 	 */
 	WPA_IF_MESH,
-
-	/*
-	 * WPA_IF_TDLS - TDLS offchannel interface (used for pref freq only)
-	 */
-	WPA_IF_TDLS,
-
-	/*
-	 * WPA_IF_IBSS - IBSS interface (used for pref freq only)
-	 */
-	WPA_IF_IBSS,
 };
 
 struct wpa_init_params {
@@ -1651,7 +1602,6 @@ struct drv_acs_params {
 	/* ACS channel list info */
 	unsigned int ch_list_len;
 	const u8 *ch_list;
-	const int *freq_list;
 };
 
 
@@ -3437,46 +3387,10 @@ struct wpa_driver_ops {
 	 */
 	int (*do_acs)(void *priv, struct drv_acs_params *params);
 
-	/**
-	 * set_band - Notify driver of band selection
-	 * @priv: Private driver interface data
-	 * @band: The selected band(s)
-	 * Returns 0 on success, -1 on failure
-	 */
-	int (*set_band)(void *priv, enum set_band band);
-
-	/**
-	 * abort_scan - Request the driver to abort an ongoing scan
-	 * @priv: Private driver interface data
-	 * Returns 0 on success, -1 on failure
-	 */
-	int (*abort_scan)(void *priv);
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+	int (*ap_priv_cmd)(void *priv, char *cmd, char *buf, size_t buf_len);
+#endif
 
-	/**
-	 * get_pref_freq_list - Get preferred frequency list for an interface
-	 * @priv: Private driver interface data
-	 * @if_type: Interface type
-	 * @num: Number of channels
-	 * @freq_list: Preferred channel frequency list encoded in MHz values
-	 * Returns 0 on success, -1 on failure
-	 *
-	 * This command can be used to query the preferred frequency list from
-	 * the driver specific to a particular interface type.
-	 */
-	int (*get_pref_freq_list)(void *priv, enum wpa_driver_if_type if_type,
-				  unsigned int *num, unsigned int *freq_list);
-
-	/**
-	 * set_prob_oper_freq - Indicate probable P2P operating channel
-	 * @priv: Private driver interface data
-	 * @freq: Channel frequency in MHz
-	 * Returns 0 on success, -1 on failure
-	 *
-	 * This command can be used to inform the driver of the operating
-	 * frequency that an ongoing P2P group formation is likely to come up
-	 * on. Local device is assuming P2P Client role.
-	 */
-	int (*set_prob_oper_freq)(void *priv, unsigned int freq);
 };
 
 
@@ -4136,12 +4050,6 @@ union wpa_event_data {
 		 * ptk_kek_len - The length of ptk_kek
 		 */
 		size_t ptk_kek_len;
-
-		/**
-		 * subnet_status - The subnet status:
-		 * 0 = unknown, 1 = unchanged, 2 = changed
-		 */
-		u8 subnet_status;
 	} assoc_info;
 
 	/**
@@ -4425,9 +4333,6 @@ union wpa_event_data {
 	 * @ssids: Scanned SSIDs (%NULL or zero-length SSID indicates wildcard
 	 *	SSID)
 	 * @num_ssids: Number of entries in ssids array
-	 * @external_scan: Whether the scan info is for an external scan
-	 * @nl_scan_event: 1 if the source of this scan event is a normal scan,
-	 * 	0 if the source of the scan event is a vendor scan
 	 */
 	struct scan_info {
 		int aborted;
@@ -4435,8 +4340,6 @@ union wpa_event_data {
 		size_t num_freqs;
 		struct wpa_driver_scan_ssid ssids[WPAS_MAX_SCAN_SSIDS];
 		size_t num_ssids;
-		int external_scan;
-		int nl_scan_event;
 	} scan_info;
 
 	/**
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 46d457d..d318c9a 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -38,6 +38,14 @@
 #include "rfkill.h"
 #include "driver_nl80211.h"
 
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+#include "../ap/hostapd.h"
+#include "../ap/sta_info.h"
+#ifdef ANDROID
+#include "android_drv.h"
+#endif
+#endif
+
 
 #ifndef CONFIG_LIBNL20
 /*
@@ -1684,6 +1692,18 @@ static void * wpa_driver_nl80211_drv_init(void *ctx, const char *ifname,
 	if (linux_iface_up(drv->global->ioctl_sock, ifname) > 0)
 		drv->start_iface_up = 1;
 
+#ifndef CONFIG_BCMDHD
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE  //Bug 458806 new feature: set max sta num to cp2
+	if(hostapd){
+		char buf[15];
+		struct hostapd_data *hostapd_p = ctx;
+		*buf = hostapd_p->conf->max_num_sta;
+		if(hostapd_p->driver->driver_cmd(bss, "MAX_STA", buf, sizeof(buf)))
+			wpa_printf(MSG_ERROR, "set max_num_sta to driver fail");
+	}
+#endif
+#endif
+
 	if (wpa_driver_nl80211_finish_drv_init(drv, set_addr, 1, driver_params))
 		goto failed;
 
@@ -1878,11 +1898,6 @@ static int nl80211_mgmt_subscribe_non_ap(struct i802_bss *bss)
 			ret = -1;
 	}
 #endif /* CONFIG_TDLS */
-#ifdef CONFIG_FST
-	/* FST Action frames */
-	if (nl80211_register_action_frame(bss, (u8 *) "\x12", 1) < 0)
-		ret = -1;
-#endif /* CONFIG_FST */
 
 	/* FT Action frames */
 	if (nl80211_register_action_frame(bss, (u8 *) "\x06", 1) < 0)
@@ -2438,6 +2453,10 @@ static u32 wpa_cipher_to_cipher_suite(unsigned int cipher)
 		return WLAN_CIPHER_SUITE_WEP40;
 	case WPA_CIPHER_GTK_NOT_USED:
 		return WLAN_CIPHER_SUITE_NO_GROUP_ADDR;
+#ifdef CONFIG_WAPI
+	case WPA_CIPHER_SMS4:
+		return WLAN_CIPHER_SUITE_SMS4;
+#endif
 	}
 
 	return 0;
@@ -3258,7 +3277,7 @@ static int wpa_driver_nl80211_set_acl(void *priv,
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
 	struct nl_msg *msg;
-	struct nl_msg *acl;
+	struct nlattr *acl;
 	unsigned int i;
 	int ret;
 
@@ -3271,26 +3290,23 @@ static int wpa_driver_nl80211_set_acl(void *priv,
 	wpa_printf(MSG_DEBUG, "nl80211: Set %s ACL (num_mac_acl=%u)",
 		   params->acl_policy ? "Accept" : "Deny", params->num_mac_acl);
 
-	acl = nlmsg_alloc();
-	if (!acl)
-		return -ENOMEM;
-	for (i = 0; i < params->num_mac_acl; i++) {
-		if (nla_put(acl, i + 1, ETH_ALEN, params->mac_acl[i].addr)) {
-			nlmsg_free(acl);
-			return -ENOMEM;
-		}
-	}
-
 	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_SET_MAC_ACL)) ||
 	    nla_put_u32(msg, NL80211_ATTR_ACL_POLICY, params->acl_policy ?
 			NL80211_ACL_POLICY_DENY_UNLESS_LISTED :
 			NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED) ||
-	    nla_put_nested(msg, NL80211_ATTR_MAC_ADDRS, acl)) {
+	    (acl = nla_nest_start(msg, NL80211_ATTR_MAC_ADDRS)) == NULL) {
 		nlmsg_free(msg);
-		nlmsg_free(acl);
 		return -ENOMEM;
 	}
-	nlmsg_free(acl);
+
+	for (i = 0; i < params->num_mac_acl; i++) {
+		if (nla_put(msg, i + 1, ETH_ALEN, params->mac_acl[i].addr)) {
+			nlmsg_free(msg);
+			return -ENOMEM;
+		}
+	}
+
+	nla_nest_end(msg, acl);
 
 	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
 	if (ret) {
@@ -3314,6 +3330,11 @@ static int nl80211_put_beacon_int(struct nl_msg *msg, int beacon_int)
 }
 
 
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+int hostapd_init_block_list(void *priv);
+#endif
+
+
 static int wpa_driver_nl80211_set_ap(void *priv,
 				     struct wpa_driver_ap_params *params)
 {
@@ -3508,12 +3529,6 @@ static int wpa_driver_nl80211_set_ap(void *priv,
 	}
 #endif /* CONFIG_P2P */
 
-	if (params->pbss) {
-		wpa_printf(MSG_DEBUG, "nl80211: PBSS");
-		if (nla_put_flag(msg, NL80211_ATTR_PBSS))
-			goto fail;
-	}
-
 	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
 	if (ret) {
 		wpa_printf(MSG_DEBUG, "nl80211: Beacon set failed: %d (%s)",
@@ -3548,6 +3563,11 @@ static int wpa_driver_nl80211_set_ap(void *priv,
 			bss->bandwidth = params->freq->bandwidth;
 		}
 	}
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+	if(!os_strcmp(bss->ifname, "wlan0")){
+		hostapd_init_block_list(bss);
+	}
+#endif
 	return ret;
 fail:
 	nlmsg_free(msg);
@@ -4572,6 +4592,10 @@ static int nl80211_connect_common(struct wpa_driver_nl80211_data *drv,
 			ver |= NL80211_WPA_VERSION_1;
 		if (params->wpa_proto & WPA_PROTO_RSN)
 			ver |= NL80211_WPA_VERSION_2;
+#ifdef CONFIG_WAPI
+		if (params->wpa_proto & WPA_PROTO_WAPI)
+			ver |= NL80211_WAPI_VERSION_1;
+#endif
 
 		wpa_printf(MSG_DEBUG, "  * WPA Versions 0x%x", ver);
 		if (nla_put_u32(msg, NL80211_ATTR_WPA_VERSIONS, ver))
@@ -4601,6 +4625,10 @@ static int nl80211_connect_common(struct wpa_driver_nl80211_data *drv,
 	}
 
 	if (params->key_mgmt_suite == WPA_KEY_MGMT_IEEE8021X ||
+#ifdef CONFIG_WAPI
+	    params->key_mgmt_suite == WPA_KEY_MGMT_WAPI_PSK ||
+	    params->key_mgmt_suite == WPA_KEY_MGMT_WAPI_CERT ||
+#endif
 	    params->key_mgmt_suite == WPA_KEY_MGMT_PSK ||
 	    params->key_mgmt_suite == WPA_KEY_MGMT_FT_IEEE8021X ||
 	    params->key_mgmt_suite == WPA_KEY_MGMT_FT_PSK ||
@@ -4637,6 +4665,16 @@ static int nl80211_connect_common(struct wpa_driver_nl80211_data *drv,
 		case WPA_KEY_MGMT_IEEE8021X_SUITE_B:
 			mgmt = WLAN_AKM_SUITE_8021X_SUITE_B;
 			break;
+#ifdef CONFIG_WAPI
+		case WPA_KEY_MGMT_WAPI_PSK:
+			wpa_printf(MSG_DEBUG, "WAPI: Set NL80211_ATTR_AKM_SUITES to WLAN_AKM_SUITE_WAPI_PSK");
+			mgmt = WLAN_AKM_SUITE_WAPI_PSK;
+			break;
+		case WPA_KEY_MGMT_WAPI_CERT:
+			wpa_printf(MSG_DEBUG, "WAPI: Set NL80211_ATTR_AKM_SUITES to WLAN_AKM_SUITE_WAPI_CERT");
+			mgmt = WLAN_AKM_SUITE_WAPI_CERT;
+			break;
+#endif
 		case WPA_KEY_MGMT_IEEE8021X_SUITE_B_192:
 			mgmt = WLAN_AKM_SUITE_8021X_SUITE_B_192;
 			break;
@@ -4672,12 +4710,6 @@ static int nl80211_connect_common(struct wpa_driver_nl80211_data *drv,
 	if (params->p2p)
 		wpa_printf(MSG_DEBUG, "  * P2P group");
 
-	if (params->pbss) {
-		wpa_printf(MSG_DEBUG, "  * PBSS");
-		if (nla_put_flag(msg, NL80211_ATTR_PBSS))
-			return -1;
-	}
-
 	return 0;
 }
 
@@ -5694,8 +5726,8 @@ static void *i802_init(struct hostapd_data *hapd,
 	struct wpa_driver_nl80211_data *drv;
 	struct i802_bss *bss;
 	size_t i;
-	char master_ifname[IFNAMSIZ];
-	int ifindex, br_ifindex = 0;
+	char brname[IFNAMSIZ];
+	int ifindex, br_ifindex;
 	int br_added = 0;
 
 	bss = wpa_driver_nl80211_drv_init(hapd, params->ifname,
@@ -5706,21 +5738,15 @@ static void *i802_init(struct hostapd_data *hapd,
 
 	drv = bss->drv;
 
-	if (linux_br_get(master_ifname, params->ifname) == 0) {
+	if (linux_br_get(brname, params->ifname) == 0) {
 		wpa_printf(MSG_DEBUG, "nl80211: Interface %s is in bridge %s",
-			   params->ifname, master_ifname);
-		br_ifindex = if_nametoindex(master_ifname);
-		os_strlcpy(bss->brname, master_ifname, IFNAMSIZ);
-	} else if ((params->num_bridge == 0 || !params->bridge[0]) &&
-		   linux_master_get(master_ifname, params->ifname) == 0) {
-		wpa_printf(MSG_DEBUG, "nl80211: Interface %s is in master %s",
-			params->ifname, master_ifname);
-		/* start listening for EAPOL on the master interface */
-		add_ifidx(drv, if_nametoindex(master_ifname));
+			   params->ifname, brname);
+		br_ifindex = if_nametoindex(brname);
+		os_strlcpy(bss->brname, brname, IFNAMSIZ);
 	} else {
-		master_ifname[0] = '\0';
+		brname[0] = '\0';
+		br_ifindex = 0;
 	}
-
 	bss->br_ifindex = br_ifindex;
 
 	for (i = 0; i < params->num_bridge; i++) {
@@ -5740,7 +5766,7 @@ static void *i802_init(struct hostapd_data *hapd,
 		if (i802_check_bridge(drv, bss, params->bridge[0],
 				      params->ifname) < 0)
 			goto failed;
-		if (os_strcmp(params->bridge[0], master_ifname) != 0)
+		if (os_strcmp(params->bridge[0], brname) != 0)
 			br_added = 1;
 	}
 
@@ -5818,9 +5844,8 @@ static enum nl80211_iftype wpa_driver_nl80211_if_type(
 		return NL80211_IFTYPE_P2P_DEVICE;
 	case WPA_IF_MESH:
 		return NL80211_IFTYPE_MESH_POINT;
-	default:
-		return -1;
 	}
+	return -1;
 }
 
 
@@ -6167,20 +6192,6 @@ static int nl80211_send_frame_cmd(struct i802_bss *bss,
 
 		if (cookie_out)
 			*cookie_out = no_ack ? (u64) -1 : cookie;
-
-		if (drv->num_send_action_cookies == MAX_SEND_ACTION_COOKIES) {
-			wpa_printf(MSG_DEBUG,
-				   "nl80211: Drop oldest pending send action cookie 0x%llx",
-				   (long long unsigned int)
-				   drv->send_action_cookies[0]);
-			os_memmove(&drv->send_action_cookies[0],
-				   &drv->send_action_cookies[1],
-				   (MAX_SEND_ACTION_COOKIES - 1) *
-				   sizeof(u64));
-			drv->num_send_action_cookies--;
-		}
-		drv->send_action_cookies[drv->num_send_action_cookies] = cookie;
-		drv->num_send_action_cookies++;
 	}
 
 fail:
@@ -6235,16 +6246,17 @@ static int wpa_driver_nl80211_send_action(struct i802_bss *bss,
 }
 
 
-static void nl80211_frame_wait_cancel(struct i802_bss *bss, u64 cookie)
+static void wpa_driver_nl80211_send_action_cancel_wait(void *priv)
 {
+	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
 	struct nl_msg *msg;
 	int ret;
 
 	wpa_printf(MSG_DEBUG, "nl80211: Cancel TX frame wait: cookie=0x%llx",
-		   (long long unsigned int) cookie);
+		   (long long unsigned int) drv->send_action_cookie);
 	if (!(msg = nl80211_cmd_msg(bss, 0, NL80211_CMD_FRAME_WAIT_CANCEL)) ||
-	    nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie)) {
+	    nla_put_u64(msg, NL80211_ATTR_COOKIE, drv->send_action_cookie)) {
 		nlmsg_free(msg);
 		return;
 	}
@@ -6256,30 +6268,6 @@ static void nl80211_frame_wait_cancel(struct i802_bss *bss, u64 cookie)
 }
 
 
-static void wpa_driver_nl80211_send_action_cancel_wait(void *priv)
-{
-	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	unsigned int i;
-	u64 cookie;
-
-	/* Cancel the last pending TX cookie */
-	nl80211_frame_wait_cancel(bss, drv->send_action_cookie);
-
-	/*
-	 * Cancel the other pending TX cookies, if any. This is needed since
-	 * the driver may keep a list of all pending offchannel TX operations
-	 * and free up the radio only once they have expired or cancelled.
-	 */
-	for (i = drv->num_send_action_cookies; i > 0; i--) {
-		cookie = drv->send_action_cookies[i - 1];
-		if (cookie != drv->send_action_cookie)
-			nl80211_frame_wait_cancel(bss, cookie);
-	}
-	drv->num_send_action_cookies = 0;
-}
-
-
 static int wpa_driver_nl80211_remain_on_channel(void *priv, unsigned int freq,
 						unsigned int duration)
 {
@@ -7272,17 +7260,6 @@ static int driver_nl80211_scan2(void *priv,
 				struct wpa_driver_scan_params *params)
 {
 	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-
-	/*
-	 * Do a vendor specific scan if possible. If only_new_results is
-	 * set, do a normal scan since a kernel (cfg80211) BSS cache flush
-	 * cannot be achieved through a vendor scan. The below condition may
-	 * need to be modified if new scan flags are added in the future whose
-	 * functionality can only be achieved through a normal scan.
-	 */
-	if (drv->scan_vendor_cmd_avail && !params->only_new_results)
-		return wpa_driver_nl80211_vendor_scan(bss, params);
 	return wpa_driver_nl80211_scan(bss, params);
 }
 
@@ -7551,10 +7528,7 @@ static int wpa_driver_nl80211_status(void *priv, char *buf, size_t buflen)
 				  "capa.max_acl_mac_addrs=%u\n"
 				  "capa.num_multichan_concurrent=%u\n"
 				  "capa.mac_addr_rand_sched_scan_supported=%d\n"
-				  "capa.mac_addr_rand_scan_supported=%d\n"
-				  "capa.conc_capab=%u\n"
-				  "capa.max_conc_chan_2_4=%u\n"
-				  "capa.max_conc_chan_5_0=%u\n",
+				  "capa.mac_addr_rand_scan_supported=%d\n",
 				  drv->capa.key_mgmt,
 				  drv->capa.enc,
 				  drv->capa.auth,
@@ -7570,10 +7544,7 @@ static int wpa_driver_nl80211_status(void *priv, char *buf, size_t buflen)
 				  drv->capa.max_acl_mac_addrs,
 				  drv->capa.num_multichan_concurrent,
 				  drv->capa.mac_addr_rand_sched_scan_supported,
-				  drv->capa.mac_addr_rand_scan_supported,
-				  drv->capa.conc_capab,
-				  drv->capa.max_conc_chan_2_4,
-				  drv->capa.max_conc_chan_5_0);
+				  drv->capa.mac_addr_rand_scan_supported);
 		if (os_snprintf_error(end - pos, res))
 			return pos - buf;
 		pos += res;
@@ -8454,26 +8425,6 @@ static int hw_mode_to_qca_acs(enum hostapd_hw_mode hw_mode)
 }
 
 
-static int add_acs_freq_list(struct nl_msg *msg, const int *freq_list)
-{
-	int i, len, ret;
-	u32 *freqs;
-
-	if (!freq_list)
-		return 0;
-	len = int_array_len(freq_list);
-	freqs = os_malloc(sizeof(u32) * len);
-	if (!freqs)
-		return -1;
-	for (i = 0; i < len; i++)
-		freqs[i] = freq_list[i];
-	ret = nla_put(msg, QCA_WLAN_VENDOR_ATTR_ACS_FREQ_LIST,
-		      sizeof(u32) * len, freqs);
-	os_free(freqs);
-	return ret;
-}
-
-
 static int wpa_driver_do_acs(void *priv, struct drv_acs_params *params)
 {
 	struct i802_bss *bss = priv;
@@ -8503,8 +8454,7 @@ static int wpa_driver_do_acs(void *priv, struct drv_acs_params *params)
 			params->ch_width) ||
 	    (params->ch_list_len &&
 	     nla_put(msg, QCA_WLAN_VENDOR_ATTR_ACS_CH_LIST, params->ch_list_len,
-		     params->ch_list)) ||
-	    add_acs_freq_list(msg, params->freq_list)) {
+		     params->ch_list))) {
 		nlmsg_free(msg);
 		return -ENOBUFS;
 	}
@@ -8524,240 +8474,263 @@ static int wpa_driver_do_acs(void *priv, struct drv_acs_params *params)
 	return ret;
 }
 
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
 
-struct nl80211_pcl {
-	unsigned int num;
-	unsigned int *freq_list;
-};
-
-static int preferred_freq_info_handler(struct nl_msg *msg, void *arg)
-{
-	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
-	struct nl80211_pcl *param = arg;
-	struct nlattr *nl_vend, *attr;
-	enum qca_iface_type iface_type;
-	struct nlattr *tb_vendor[QCA_WLAN_VENDOR_ATTR_MAX + 1];
-	unsigned int num, max_num;
-	u32 *freqs;
-
-	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		  genlmsg_attrlen(gnlh, 0), NULL);
-
-	nl_vend = tb[NL80211_ATTR_VENDOR_DATA];
-	if (!nl_vend)
-		return NL_SKIP;
-
-	nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_MAX,
-		  nla_data(nl_vend), nla_len(nl_vend), NULL);
-
-	attr = tb_vendor[
-		QCA_WLAN_VENDOR_ATTR_GET_PREFERRED_FREQ_LIST_IFACE_TYPE];
-	if (!attr) {
-		wpa_printf(MSG_ERROR, "nl80211: iface_type couldn't be found");
-		param->num = 0;
-		return NL_SKIP;
-	}
-
-	iface_type = (enum qca_iface_type) nla_get_u32(attr);
-	wpa_printf(MSG_DEBUG, "nl80211: Driver returned iface_type=%d",
-		   iface_type);
-
-	attr = tb_vendor[QCA_WLAN_VENDOR_ATTR_GET_PREFERRED_FREQ_LIST];
-	if (!attr) {
-		wpa_printf(MSG_ERROR,
-			   "nl80211: preferred_freq_list couldn't be found");
-		param->num = 0;
-		return NL_SKIP;
-	}
+#define HOSTAP_BLOCK_LIST_FILE "/data/misc/wifi/hostapd.blocklist"
+#define HOSTAP_MAX_BLOCK_NUM 8
 
-	/*
-	 * param->num has the maximum number of entries for which there
-	 * is room in the freq_list provided by the caller.
-	 */
-	freqs = nla_data(attr);
-	max_num = nla_len(attr) / sizeof(u32);
-	if (max_num > param->num)
-		max_num = param->num;
-	for (num = 0; num < max_num; num++)
-		param->freq_list[num] = freqs[num];
-	param->num = num;
+int hostapd_add_station_to_mac_addr_list(const u8 *mac_addr);
+int hostapd_del_station_from_mac_addr_list(const u8 *mac_addr);
+int hostapd_read_mac_addr_list(const char *file_path, u8 mac_addr_list[][ETH_ALEN]);
+int hostapd_write_mac_addr_list(const char *file_path, u8 mac_addr_list[][ETH_ALEN], int mac_addr_list_len);
 
-	return NL_SKIP;
-}
-
-
-static int nl80211_get_pref_freq_list(void *priv,
-				      enum wpa_driver_if_type if_type,
-				      unsigned int *num,
-				      unsigned int *freq_list)
+int hostapd_driver_nl80211_ap_priv_cmd(void *priv, char *cmd, char *buf, size_t buf_len )
 {
+	int ret = 0;
 	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	struct nl_msg *msg;
-	int ret;
-	unsigned int i;
-	struct nlattr *params;
-	struct nl80211_pcl param;
-	enum qca_iface_type iface_type;
-
-	if (!drv->get_pref_freq_list)
-		return -1;
-
-	switch (if_type) {
-	case WPA_IF_STATION:
-		iface_type = QCA_IFACE_TYPE_STA;
-		break;
-	case WPA_IF_AP_BSS:
-		iface_type = QCA_IFACE_TYPE_AP;
-		break;
-	case WPA_IF_P2P_GO:
-		iface_type = QCA_IFACE_TYPE_P2P_GO;
-		break;
-	case WPA_IF_P2P_CLIENT:
-		iface_type = QCA_IFACE_TYPE_P2P_CLIENT;
-		break;
-	case WPA_IF_IBSS:
-		iface_type = QCA_IFACE_TYPE_IBSS;
-		break;
-	case WPA_IF_TDLS:
-		iface_type = QCA_IFACE_TYPE_TDLS;
-		break;
-	default:
-		return -1;
-	}
+	struct hostapd_data *hostapd = bss->ctx;
+	struct mac_acl_entry *acl, *newacl;
+	int i, add;
+	if (os_strncasecmp(cmd, "BLOCK ", 6) == 0) {
+		u8 mac_addr[ETH_ALEN];
+		if(sscanf(cmd+6, MACSTR, &mac_addr[0], &mac_addr[1], &mac_addr[2], &mac_addr[3], &mac_addr[4], &mac_addr[5]) != 6)
+			return -1;
+		if(android_driver_priv_cmd(priv, cmd) < 0)
+			return -1;
+		if(hostapd_add_station_to_mac_addr_list(mac_addr) < 0)
+			return -1;
+		ret = os_snprintf(buf, buf_len, "OK");
+	} else if (os_strncasecmp(cmd, "UNBLOCK ", 8) == 0) {
+		u8 mac_addr[ETH_ALEN];
+		if(sscanf(cmd+8, MACSTR, &mac_addr[0], &mac_addr[1], &mac_addr[2], &mac_addr[3], &mac_addr[4], &mac_addr[5]) != 6)
+			return -1;
+		if(android_driver_priv_cmd(priv, cmd) < 0)
+			return -1;
+		if(hostapd_del_station_from_mac_addr_list(mac_addr) < 0)
+			return -1;
+		ret = os_snprintf(buf, buf_len, "OK");
+	} else if (os_strncasecmp(cmd, "BLOCK_LIST", 10) == 0) {
+		u8 mac_addr_list[HOSTAP_MAX_BLOCK_NUM][ETH_ALEN];
+		int mac_addr_list_len;
+		mac_addr_list_len = hostapd_read_mac_addr_list(HOSTAP_BLOCK_LIST_FILE, mac_addr_list);
+		for(i=0; i<mac_addr_list_len; i++) {
+			ret = os_snprintf(buf + i * 18, buf_len - i * 18, MACSTR " ", MAC2STR(mac_addr_list[i]));
+		}
+		ret = mac_addr_list_len * 18;
+	}else if(os_strncasecmp(cmd, "WHITE_ADD_ONCE", 14) == 0){
+		char cmd_buf[MAX_DRV_CMD_SIZE];
+		wpa_printf(MSG_INFO, "%s", cmd);
+		os_memset(cmd_buf, 0, sizeof(cmd_buf));
+		os_strncpy(cmd_buf, cmd, 9);
+		cmd_buf[9] = ' ';
+		os_snprintf(cmd_buf+10, 18, MACSTR, MAC2STR(&cmd[15]));
+		wpa_printf(MSG_INFO, "%s", cmd_buf);
+		if(android_driver_priv_cmd(priv, cmd_buf) < 0)
+			return -1;
+		ret = os_snprintf(buf, buf_len, "OK");
+	}else if(os_strncasecmp(cmd, "WHITE_EN_ONCE", 13) == 0){
+		wpa_printf(MSG_INFO, "%s", cmd);
+		if(android_driver_priv_cmd(priv, "WHITE_EN \0") < 0)
+			return -1;
+		ret = os_snprintf(buf, buf_len, "OK");
+	}else if(os_strncasecmp(cmd, "WHITE_ADD", 9) == 0){
+		wpa_printf(MSG_INFO, "%s", cmd);
+		char addr[ETH_ALEN];
+		hwaddr_aton(cmd+10, addr);
+		add = 1;
+		i = 0;
+		acl = hostapd->conf->accept_mac;
+		while(i < hostapd->conf->num_accept_mac){
+			if(os_memcmp(acl[i].addr, addr, ETH_ALEN) == 0){
+				add = 0;
+				wpa_printf(MSG_INFO, "This mac has been added.");
+				break;
+			}
+			i++;
+		}
 
-	param.num = *num;
-	param.freq_list = freq_list;
+		if(add){
+			if(android_driver_priv_cmd(priv, cmd) < 0)
+				return -1;
+			newacl = os_realloc_array(acl, hostapd->conf->num_accept_mac+ 1, sizeof(*acl));
+			if (newacl == NULL) {
+				wpa_printf(MSG_ERROR, "MAC list reallocation failed");
+				return -1;
+			}
 
-	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
-	    nla_put_u32(msg, NL80211_ATTR_IFINDEX, drv->ifindex) ||
-	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_QCA) ||
-	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
-			QCA_NL80211_VENDOR_SUBCMD_GET_PREFERRED_FREQ_LIST) ||
-	    !(params = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
-	    nla_put_u32(msg,
-			QCA_WLAN_VENDOR_ATTR_GET_PREFERRED_FREQ_LIST_IFACE_TYPE,
-			iface_type)) {
-		wpa_printf(MSG_ERROR,
-			   "%s: err in adding vendor_cmd and vendor_data",
-			   __func__);
-		nlmsg_free(msg);
-		return -1;
-	}
-	nla_nest_end(msg, params);
+			hostapd->conf->accept_mac = newacl;
+			os_memcpy(newacl[hostapd->conf->num_accept_mac].addr, addr, ETH_ALEN);
+			hostapd->conf->num_accept_mac++;
+		}
+		ret = os_snprintf(buf, buf_len, "OK");
+	}else if(os_strncasecmp(cmd, "WHITE_DEL", 9) == 0){
+		wpa_printf(MSG_INFO, "%s", cmd);
+		char addr[ETH_ALEN];
+		hwaddr_aton(cmd+10, addr);
+		i = 0;
+		acl = hostapd->conf->accept_mac;
+		if(android_driver_priv_cmd(priv, cmd) < 0)
+			return -1;
 
-	os_memset(freq_list, 0, *num * sizeof(freq_list[0]));
-	ret = send_and_recv_msgs(drv, msg, preferred_freq_info_handler, &param);
-	if (ret) {
-		wpa_printf(MSG_ERROR,
-			   "%s: err in send_and_recv_msgs", __func__);
-		return ret;
+		while(i < hostapd->conf->num_accept_mac){
+			if(os_memcmp(acl[i].addr, addr, ETH_ALEN) == 0){
+				os_remove_in_array(acl, hostapd->conf->num_accept_mac, sizeof(*acl), i);
+				hostapd->conf->num_accept_mac--;
+				break;
+			}
+			i++;
+		}
+		ret = os_snprintf(buf, buf_len, "OK");
+	}else if(os_strncasecmp(cmd, "WHITE_EN", 8) == 0){
+		struct sta_info *sta;
+		char cmd_buf[MAX_DRV_CMD_SIZE];
+		int sum = 0;
+		os_memset(cmd_buf, 0, sizeof(cmd_buf));
+		os_strncpy(cmd_buf, cmd, 8);
+		cmd_buf[8] = ' ';
+		acl = hostapd->conf->accept_mac;
+		for (sta = hostapd->sta_list; sta; sta = sta->next) {
+			i = 0; add = 1;
+			while(i < hostapd->conf->num_accept_mac){
+				wpa_printf(MSG_INFO, "WHITE_EN accept " MACSTR, MAC2STR(acl[i].addr));
+				if(os_memcmp(acl[i].addr, sta->addr, ETH_ALEN) == 0){
+					add = 0;
+					break;
+				}
+				i++;
+			}
+			if(add){
+				wpa_printf(MSG_INFO, "WHITE_EN add " MACSTR, MAC2STR(sta->addr));
+				os_snprintf(&cmd_buf[10+sum*18], 18, MACSTR, MAC2STR(sta->addr));
+				cmd_buf[10+sum*18+17] = ' ';
+				sum++;
+			}
+		}
+		cmd_buf[9] = sum;
+		wpa_printf(MSG_INFO, "WHITE_EN %d.", cmd_buf[9]);
+		wpa_printf(MSG_INFO, "%s", cmd_buf);
+		if(android_driver_priv_cmd(priv, cmd_buf) < 0)
+			return -1;
+		ret = os_snprintf(buf, buf_len, "OK");
+	}else if(os_strncasecmp(cmd, "WHITE_DIS", 9) == 0){
+		u8 mac_addr_list[HOSTAP_MAX_BLOCK_NUM][ETH_ALEN];
+		int mac_addr_list_len;
+		struct sta_info *sta;
+		char cmd_buf[MAX_DRV_CMD_SIZE];
+		int sum = 0;
+		os_memset(cmd_buf, 0, sizeof(cmd_buf));
+		os_strncpy(cmd_buf, cmd, 9);
+		cmd_buf[9] = ' ';
+		mac_addr_list_len = hostapd_read_mac_addr_list(HOSTAP_BLOCK_LIST_FILE, mac_addr_list);
+		acl = hostapd->conf->accept_mac;
+		for (sta = hostapd->sta_list; sta; sta = sta->next) {
+			i = 0; add = 0;
+			while(i < mac_addr_list_len){
+				if(os_memcmp(mac_addr_list[i], sta->addr, ETH_ALEN) == 0){
+					add = 1;
+					break;
+				}
+				i++;
+			}
+			if(add){
+				wpa_printf(MSG_INFO, "WHITE_DIS add " MACSTR, MAC2STR(sta->addr));
+				os_snprintf(&cmd_buf[11+sum*18], 18, MACSTR, MAC2STR(sta->addr));
+				cmd_buf[11+sum*18+17] = ' ';
+				sum++;
+			}
+		}
+		cmd_buf[10] = sum;
+		wpa_printf(MSG_INFO, "WHITE_DIS %d.", cmd_buf[10]);
+		wpa_printf(MSG_INFO, "%s", cmd_buf);
+		if(android_driver_priv_cmd(priv, cmd_buf) < 0)
+			return -1;
+		ret = os_snprintf(buf, buf_len, "OK");
+	}else {
+		ret = os_snprintf(buf, buf_len, "Unknown driver command: %s", cmd);
 	}
+	return ret;
+}
 
-	*num = param.num;
-
-	for (i = 0; i < *num; i++) {
-		wpa_printf(MSG_DEBUG, "nl80211: preferred_channel_list[%d]=%d",
-			   i, freq_list[i]);
+int hostapd_init_block_list(void *priv)
+{
+	u8 mac_addr_list[HOSTAP_MAX_BLOCK_NUM][ETH_ALEN];
+	int mac_addr_list_len;
+	char cmd[MAX_DRV_CMD_SIZE];
+	int i;
+	mac_addr_list_len = hostapd_read_mac_addr_list(HOSTAP_BLOCK_LIST_FILE, mac_addr_list);
+	for(i=0; i<mac_addr_list_len; i++) {
+		sprintf(cmd,"BLOCK %02x:%02x:%02x:%02x:%02x:%02x", mac_addr_list[i][0], mac_addr_list[i][1], mac_addr_list[i][2], mac_addr_list[i][3], mac_addr_list[i][4], mac_addr_list[i][5]);
+		if(android_driver_priv_cmd(priv, cmd) < 0)
+			return -1;
 	}
-
 	return 0;
 }
 
-
-static int nl80211_set_prob_oper_freq(void *priv, unsigned int freq)
+int hostapd_add_station_to_mac_addr_list(const u8 *mac_addr)
 {
-	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	struct nl_msg *msg;
-	int ret;
-	struct nlattr *params;
-
-	if (!drv->set_prob_oper_freq)
-		return -1;
-
-	wpa_printf(MSG_DEBUG,
-		   "nl80211: Set P2P probable operating freq %u for ifindex %d",
-		   freq, bss->ifindex);
-
-	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
-	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_QCA) ||
-	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
-			QCA_NL80211_VENDOR_SUBCMD_SET_PROBABLE_OPER_CHANNEL) ||
-	    !(params = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
-	    nla_put_u32(msg,
-			QCA_WLAN_VENDOR_ATTR_PROBABLE_OPER_CHANNEL_IFACE_TYPE,
-			QCA_IFACE_TYPE_P2P_CLIENT) ||
-	    nla_put_u32(msg,
-			QCA_WLAN_VENDOR_ATTR_PROBABLE_OPER_CHANNEL_FREQ,
-			freq)) {
-		wpa_printf(MSG_ERROR,
-			   "%s: err in adding vendor_cmd and vendor_data",
-			   __func__);
-		nlmsg_free(msg);
-		return -1;
-	}
-	nla_nest_end(msg, params);
-
-	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
-	msg = NULL;
-	if (ret) {
-		wpa_printf(MSG_ERROR, "%s: err in send_and_recv_msgs",
-			   __func__);
-		return ret;
+	u8 mac_addr_list[HOSTAP_MAX_BLOCK_NUM][ETH_ALEN];
+	int mac_addr_list_len;
+	int i;
+	mac_addr_list_len = hostapd_read_mac_addr_list(HOSTAP_BLOCK_LIST_FILE, mac_addr_list);
+	for(i=0; i<mac_addr_list_len; i++) {
+		if(os_memcmp(mac_addr_list[i], mac_addr, ETH_ALEN) == 0) {
+			return 0;
+		}
 	}
-	nlmsg_free(msg);
-	return 0;
+	if(mac_addr_list_len == HOSTAP_MAX_BLOCK_NUM) return -1;
+	os_memcpy(mac_addr_list[mac_addr_list_len], mac_addr, ETH_ALEN);
+	mac_addr_list_len++;
+	return hostapd_write_mac_addr_list(HOSTAP_BLOCK_LIST_FILE, mac_addr_list, mac_addr_list_len);
 }
 
-
-static int nl80211_set_band(void *priv, enum set_band band)
+int hostapd_del_station_from_mac_addr_list(const u8 *mac_addr)
 {
-	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	struct nl_msg *msg;
-	struct nlattr *data;
-	int ret;
-	enum qca_set_band qca_band;
-
-	if (!drv->setband_vendor_cmd_avail)
-		return -1;
-
-	switch (band) {
-	case WPA_SETBAND_AUTO:
-		qca_band = QCA_SETBAND_AUTO;
-		break;
-	case WPA_SETBAND_5G:
-		qca_band = QCA_SETBAND_5G;
-		break;
-	case WPA_SETBAND_2G:
-		qca_band = QCA_SETBAND_2G;
-		break;
-	default:
-		return -1;
+	u8 mac_addr_list[HOSTAP_MAX_BLOCK_NUM][ETH_ALEN];
+	int mac_addr_list_len;
+	int i;
+	mac_addr_list_len = hostapd_read_mac_addr_list(HOSTAP_BLOCK_LIST_FILE, mac_addr_list);
+	for(i=0; i<mac_addr_list_len; i++) {
+		if(os_memcmp(mac_addr_list[i], mac_addr, ETH_ALEN) == 0) {
+			break;
+		}
 	}
-
-	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
-	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_QCA) ||
-	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
-			QCA_NL80211_VENDOR_SUBCMD_SETBAND) ||
-	    !(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
-	    nla_put_u32(msg, QCA_WLAN_VENDOR_ATTR_SETBAND_VALUE, qca_band)) {
-		nlmsg_free(msg);
-		return -ENOBUFS;
+	if(i == mac_addr_list_len) {
+		return 0;
+	} else {
+		for( ; i<mac_addr_list_len-1; i++) {
+			os_memcpy(mac_addr_list[i], mac_addr_list[i+1], ETH_ALEN);
+		}
+		mac_addr_list_len--;
 	}
-	nla_nest_end(msg, data);
+	return hostapd_write_mac_addr_list(HOSTAP_BLOCK_LIST_FILE, mac_addr_list, mac_addr_list_len);
+}
 
-	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
-	if (ret) {
-		wpa_printf(MSG_DEBUG,
-			   "nl80211: Driver setband function failed: %s",
-			   strerror(errno));
+int hostapd_read_mac_addr_list(const char *file_path, u8 mac_addr_list[][ETH_ALEN])
+{
+	FILE *f;
+	int mac_addr_list_len = 0;
+	f = fopen(file_path, "r");
+	if (f == NULL) return 0;
+	mac_addr_list_len = fread(mac_addr_list, ETH_ALEN, HOSTAP_MAX_BLOCK_NUM, f);
+	fclose(f);
+	return mac_addr_list_len;
+}
+
+int hostapd_write_mac_addr_list(const char *file_path, u8 mac_addr_list[][ETH_ALEN], int mac_addr_list_len)
+{
+	FILE *f;
+	int ret = 0;
+	f = fopen(file_path, "w");
+	if (f == NULL) return -1;
+	if(fwrite(mac_addr_list, ETH_ALEN, mac_addr_list_len, f) != mac_addr_list_len) {
+		wpa_printf(MSG_ERROR, "Failed to write mac address list");
+		ret = -1;
 	}
+	fclose(f);
 	return ret;
 }
 
+#endif
 
 const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.name = "nl80211",
@@ -8769,7 +8742,6 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.sched_scan = wpa_driver_nl80211_sched_scan,
 	.stop_sched_scan = wpa_driver_nl80211_stop_sched_scan,
 	.get_scan_results2 = wpa_driver_nl80211_get_scan_results,
-	.abort_scan = wpa_driver_nl80211_abort_scan,
 	.deauthenticate = driver_nl80211_deauthenticate,
 	.authenticate = driver_nl80211_authenticate,
 	.associate = wpa_driver_nl80211_associate,
@@ -8805,6 +8777,9 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.set_sta_vlan = driver_nl80211_set_sta_vlan,
 	.sta_deauth = i802_sta_deauth,
 	.sta_disassoc = i802_sta_disassoc,
+#ifndef CONFIG_NO_HOSTAPD_ADVANCE
+	.ap_priv_cmd = hostapd_driver_nl80211_ap_priv_cmd,
+#endif
 	.read_sta_data = driver_nl80211_read_sta_data,
 	.set_freq = i802_set_freq,
 	.send_action = driver_nl80211_send_action,
@@ -8867,7 +8842,4 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.add_tx_ts = nl80211_add_ts,
 	.del_tx_ts = nl80211_del_ts,
 	.do_acs = wpa_driver_do_acs,
-	.set_band = nl80211_set_band,
-	.get_pref_freq_list = nl80211_get_pref_freq_list,
-	.set_prob_oper_freq = nl80211_set_prob_oper_freq,
 };
diff --git a/src/drivers/driver_nl80211.h b/src/drivers/driver_nl80211.h
index e2df8b4..37ad55c 100644
--- a/src/drivers/driver_nl80211.h
+++ b/src/drivers/driver_nl80211.h
@@ -145,17 +145,9 @@ struct wpa_driver_nl80211_data {
 	unsigned int get_features_vendor_cmd_avail:1;
 	unsigned int set_rekey_offload:1;
 	unsigned int p2p_go_ctwindow_supported:1;
-	unsigned int setband_vendor_cmd_avail:1;
-	unsigned int get_pref_freq_list:1;
-	unsigned int set_prob_oper_freq:1;
-	unsigned int scan_vendor_cmd_avail:1;
 
-	u64 vendor_scan_cookie;
 	u64 remain_on_chan_cookie;
 	u64 send_action_cookie;
-#define MAX_SEND_ACTION_COOKIES 20
-	u64 send_action_cookies[MAX_SEND_ACTION_COOKIES];
-	unsigned int num_send_action_cookies;
 
 	unsigned int last_mgmt_freq;
 
@@ -187,13 +179,6 @@ struct wpa_driver_nl80211_data {
 	int auth_wep_tx_keyidx;
 	int auth_local_state_change;
 	int auth_p2p;
-
-	/*
-	 * Tells whether the last scan issued from wpa_supplicant was a normal
-	 * scan (NL80211_CMD_TRIGGER_SCAN) or a vendor scan
-	 * (NL80211_CMD_VENDOR). 0 if no pending scan request.
-	 */
-	int last_scan_cmd;
 };
 
 struct nl_msg;
@@ -253,6 +238,10 @@ int android_pno_stop(struct i802_bss *bss);
 extern int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
 					 size_t buf_len);
 
+//NOTE: Add for HOSTAPD_ADVANCE -->
+int android_driver_priv_cmd(struct i802_bss *bss, const char *cmd);
+//<-- Add for HOSTAPD_ADVANCE
+
 #ifdef ANDROID_P2P
 int wpa_driver_set_p2p_noa(void *priv, u8 count, int start, int duration);
 int wpa_driver_get_p2p_noa(void *priv, u8 *buf, size_t len);
@@ -284,9 +273,6 @@ int wpa_driver_nl80211_sched_scan(void *priv,
 int wpa_driver_nl80211_stop_sched_scan(void *priv);
 struct wpa_scan_results * wpa_driver_nl80211_get_scan_results(void *priv);
 void nl80211_dump_scan(struct wpa_driver_nl80211_data *drv);
-int wpa_driver_nl80211_abort_scan(void *priv);
 const u8 * nl80211_get_ie(const u8 *ies, size_t ies_len, u8 ie);
-int wpa_driver_nl80211_vendor_scan(struct i802_bss *bss,
-				   struct wpa_driver_scan_params *params);
 
 #endif /* DRIVER_NL80211_H */
diff --git a/src/drivers/driver_nl80211_android.c b/src/drivers/driver_nl80211_android.c
index ba47888..4061447 100644
--- a/src/drivers/driver_nl80211_android.c
+++ b/src/drivers/driver_nl80211_android.c
@@ -188,3 +188,10 @@ int android_nl_socket_set_nonblocking(struct nl_handle *handle)
 }
 
 
+//NOTE: Add for HOSTAPD_ADVANCE -->
+int android_driver_priv_cmd(struct i802_bss *bss, const char *cmd)
+{
+	return android_priv_cmd(bss, cmd);
+}
+//<-- Add for HOSTAPD_ADVANCE
+
diff --git a/src/drivers/driver_nl80211_capa.c b/src/drivers/driver_nl80211_capa.c
index 7b23a8a..7b1228e 100644
--- a/src/drivers/driver_nl80211_capa.c
+++ b/src/drivers/driver_nl80211_capa.c
@@ -120,8 +120,10 @@ static void wiphy_info_supported_iftypes(struct wiphy_info_data *info,
 			info->capa->flags |= WPA_DRIVER_FLAGS_IBSS;
 			break;
 		case NL80211_IFTYPE_P2P_DEVICE:
+#ifdef CONFIG_BCMDHD
 			info->capa->flags |=
 				WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE;
+#endif
 			break;
 		case NL80211_IFTYPE_P2P_GO:
 			info->p2p_go_supported = 1;
@@ -589,22 +591,10 @@ static int wiphy_info_handler(struct nl_msg *msg, void *arg)
 				case QCA_NL80211_VENDOR_SUBCMD_GET_FEATURES:
 					drv->get_features_vendor_cmd_avail = 1;
 					break;
-				case QCA_NL80211_VENDOR_SUBCMD_GET_PREFERRED_FREQ_LIST:
-					drv->get_pref_freq_list = 1;
-					break;
-				case QCA_NL80211_VENDOR_SUBCMD_SET_PROBABLE_OPER_CHANNEL:
-					drv->set_prob_oper_freq = 1;
-					break;
 				case QCA_NL80211_VENDOR_SUBCMD_DO_ACS:
 					drv->capa.flags |=
 						WPA_DRIVER_FLAGS_ACS_OFFLOAD;
 					break;
-				case QCA_NL80211_VENDOR_SUBCMD_SETBAND:
-					drv->setband_vendor_cmd_avail = 1;
-					break;
-				case QCA_NL80211_VENDOR_SUBCMD_TRIGGER_SCAN:
-					drv->scan_vendor_cmd_avail = 1;
-					break;
 				}
 			}
 
@@ -760,7 +750,6 @@ static void qca_nl80211_check_dfs_capa(struct wpa_driver_nl80211_data *drv)
 struct features_info {
 	u8 *flags;
 	size_t flags_len;
-	struct wpa_driver_capa *capa;
 };
 
 
@@ -786,19 +775,6 @@ static int features_info_handler(struct nl_msg *msg, void *arg)
 			info->flags = nla_data(attr);
 			info->flags_len = nla_len(attr);
 		}
-		attr = tb_vendor[QCA_WLAN_VENDOR_ATTR_CONCURRENCY_CAPA];
-		if (attr)
-			info->capa->conc_capab = nla_get_u32(attr);
-
-		attr = tb_vendor[
-			QCA_WLAN_VENDOR_ATTR_MAX_CONCURRENT_CHANNELS_2_4_BAND];
-		if (attr)
-			info->capa->max_conc_chan_2_4 = nla_get_u32(attr);
-
-		attr = tb_vendor[
-			QCA_WLAN_VENDOR_ATTR_MAX_CONCURRENT_CHANNELS_5_0_BAND];
-		if (attr)
-			info->capa->max_conc_chan_5_0 = nla_get_u32(attr);
 	}
 
 	return NL_SKIP;
@@ -833,7 +809,6 @@ static void qca_nl80211_get_features(struct wpa_driver_nl80211_data *drv)
 	}
 
 	os_memset(&info, 0, sizeof(info));
-	info.capa = &drv->capa;
 	ret = send_and_recv_msgs(drv, msg, features_info_handler, &info);
 	if (ret || !info.flags)
 		return;
@@ -843,10 +818,6 @@ static void qca_nl80211_get_features(struct wpa_driver_nl80211_data *drv)
 
 	if (check_feature(QCA_WLAN_VENDOR_FEATURE_SUPPORT_HW_MODE_ANY, &info))
 		drv->capa.flags |= WPA_DRIVER_FLAGS_SUPPORT_HW_MODE_ANY;
-
-	if (check_feature(QCA_WLAN_VENDOR_FEATURE_OFFCHANNEL_SIMULTANEOUS,
-			  &info))
-		drv->capa.flags |= WPA_DRIVER_FLAGS_OFFCHANNEL_SIMULTANEOUS;
 }
 
 
@@ -932,16 +903,6 @@ int wpa_driver_nl80211_capa(struct wpa_driver_nl80211_data *drv)
 	qca_nl80211_check_dfs_capa(drv);
 	qca_nl80211_get_features(drv);
 
-	/*
-	 * To enable offchannel simultaneous support in wpa_supplicant, the
-	 * underlying driver needs to support the same along with offchannel TX.
-	 * Offchannel TX support is needed since remain_on_channel and
-	 * action_tx use some common data structures and hence cannot be
-	 * scheduled simultaneously.
-	 */
-	if (!(drv->capa.flags & WPA_DRIVER_FLAGS_OFFCHANNEL_TX))
-		drv->capa.flags &= ~WPA_DRIVER_FLAGS_OFFCHANNEL_SIMULTANEOUS;
-
 	return 0;
 }
 
@@ -1398,7 +1359,7 @@ static void nl80211_reg_rule_sec(struct nlattr *tb[],
 
 
 static void nl80211_set_vht_mode(struct hostapd_hw_modes *mode, int start,
-				 int end, int max_bw)
+				 int end)
 {
 	int c;
 
@@ -1415,32 +1376,6 @@ static void nl80211_set_vht_mode(struct hostapd_hw_modes *mode, int start,
 
 		if (chan->freq - 70 >= start && chan->freq + 10 <= end)
 			chan->flag |= HOSTAPD_CHAN_VHT_70_10;
-
-		if (max_bw >= 160) {
-			if (chan->freq - 10 >= start && chan->freq + 150 <= end)
-				chan->flag |= HOSTAPD_CHAN_VHT_10_150;
-
-			if (chan->freq - 30 >= start && chan->freq + 130 <= end)
-				chan->flag |= HOSTAPD_CHAN_VHT_30_130;
-
-			if (chan->freq - 50 >= start && chan->freq + 110 <= end)
-				chan->flag |= HOSTAPD_CHAN_VHT_50_110;
-
-			if (chan->freq - 70 >= start && chan->freq + 90 <= end)
-				chan->flag |= HOSTAPD_CHAN_VHT_70_90;
-
-			if (chan->freq - 90 >= start && chan->freq + 70 <= end)
-				chan->flag |= HOSTAPD_CHAN_VHT_90_70;
-
-			if (chan->freq - 110 >= start && chan->freq + 50 <= end)
-				chan->flag |= HOSTAPD_CHAN_VHT_110_50;
-
-			if (chan->freq - 130 >= start && chan->freq + 30 <= end)
-				chan->flag |= HOSTAPD_CHAN_VHT_130_30;
-
-			if (chan->freq - 150 >= start && chan->freq + 10 <= end)
-				chan->flag |= HOSTAPD_CHAN_VHT_150_10;
-		}
 	}
 }
 
@@ -1471,7 +1406,7 @@ static void nl80211_reg_rule_vht(struct nlattr *tb[],
 		if (!results->modes[m].vht_capab)
 			continue;
 
-		nl80211_set_vht_mode(&results->modes[m], start, end, max_bw);
+		nl80211_set_vht_mode(&results->modes[m], start, end);
 	}
 }
 
diff --git a/src/drivers/driver_nl80211_event.c b/src/drivers/driver_nl80211_event.c
index 0070be8..7b0f721 100644
--- a/src/drivers/driver_nl80211_event.c
+++ b/src/drivers/driver_nl80211_event.c
@@ -268,8 +268,7 @@ static void mlme_event_connect(struct wpa_driver_nl80211_data *drv,
 			       struct nlattr *authorized,
 			       struct nlattr *key_replay_ctr,
 			       struct nlattr *ptk_kck,
-			       struct nlattr *ptk_kek,
-			       struct nlattr *subnet_status)
+			       struct nlattr *ptk_kek)
 {
 	union wpa_event_data event;
 	const u8 *ssid;
@@ -368,17 +367,6 @@ static void mlme_event_connect(struct wpa_driver_nl80211_data *drv,
 		event.assoc_info.ptk_kek_len = nla_len(ptk_kek);
 	}
 
-	if (subnet_status) {
-		/*
-		 * At least for now, this is only available from
-		 * QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_SUBNET_STATUS and that
-		 * attribute has the same values 0, 1, 2 as are used in the
-		 * variable here, so no mapping between different values are
-		 * needed.
-		 */
-		event.assoc_info.subnet_status = nla_get_u8(subnet_status);
-	}
-
 	wpa_supplicant_event(drv->ctx, EVENT_ASSOC, &event);
 }
 
@@ -980,7 +968,7 @@ static void mlme_event_ft_event(struct wpa_driver_nl80211_data *drv,
 
 
 static void send_scan_event(struct wpa_driver_nl80211_data *drv, int aborted,
-			    struct nlattr *tb[], int external_scan)
+			    struct nlattr *tb[])
 {
 	union wpa_event_data event;
 	struct nlattr *nl;
@@ -990,7 +978,7 @@ static void send_scan_event(struct wpa_driver_nl80211_data *drv, int aborted,
 	int freqs[MAX_REPORT_FREQS];
 	int num_freqs = 0;
 
-	if (!external_scan && drv->scan_for_auth) {
+	if (drv->scan_for_auth) {
 		drv->scan_for_auth = 0;
 		wpa_printf(MSG_DEBUG, "nl80211: Scan results for missing "
 			   "cfg80211 BSS entry");
@@ -1001,8 +989,6 @@ static void send_scan_event(struct wpa_driver_nl80211_data *drv, int aborted,
 	os_memset(&event, 0, sizeof(event));
 	info = &event.scan_info;
 	info->aborted = aborted;
-	info->external_scan = external_scan;
-	info->nl_scan_event = 1;
 
 	if (tb[NL80211_ATTR_SCAN_SSIDS]) {
 		nla_for_each_nested(nl, tb[NL80211_ATTR_SCAN_SSIDS], rem) {
@@ -1610,8 +1596,7 @@ static void qca_nl80211_key_mgmt_auth(struct wpa_driver_nl80211_data *drv,
 			   tb[QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_AUTHORIZED],
 			   tb[QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_KEY_REPLAY_CTR],
 			   tb[QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_PTK_KCK],
-			   tb[QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_PTK_KEK],
-			   tb[QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_SUBNET_STATUS]);
+			   tb[QCA_WLAN_VENDOR_ATTR_ROAM_AUTH_PTK_KEK]);
 }
 
 
@@ -1701,138 +1686,6 @@ static void qca_nl80211_dfs_offload_radar_event(
 }
 
 
-static void qca_nl80211_scan_trigger_event(struct wpa_driver_nl80211_data *drv,
-					   u8 *data, size_t len)
-{
-	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SCAN_MAX + 1];
-	u64 cookie = 0;
-	union wpa_event_data event;
-	struct scan_info *info;
-
-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SCAN_MAX,
-		      (struct nlattr *) data, len, NULL) ||
-	    !tb[QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE])
-		return;
-
-	cookie = nla_get_u64(tb[QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE]);
-	if (cookie != drv->vendor_scan_cookie) {
-		/* External scan trigger event, ignore */
-		return;
-	}
-
-	/* Cookie match, own scan */
-	os_memset(&event, 0, sizeof(event));
-	info = &event.scan_info;
-	info->external_scan = 0;
-	info->nl_scan_event = 0;
-
-	drv->scan_state = SCAN_STARTED;
-	wpa_supplicant_event(drv->ctx, EVENT_SCAN_STARTED, &event);
-}
-
-
-static void send_vendor_scan_event(struct wpa_driver_nl80211_data *drv,
-				   int aborted, struct nlattr *tb[],
-				   int external_scan)
-{
-	union wpa_event_data event;
-	struct nlattr *nl;
-	int rem;
-	struct scan_info *info;
-	int freqs[MAX_REPORT_FREQS];
-	int num_freqs = 0;
-
-	os_memset(&event, 0, sizeof(event));
-	info = &event.scan_info;
-	info->aborted = aborted;
-	info->external_scan = external_scan;
-
-	if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS]) {
-		nla_for_each_nested(nl,
-				    tb[QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS], rem) {
-			struct wpa_driver_scan_ssid *s =
-				&info->ssids[info->num_ssids];
-			s->ssid = nla_data(nl);
-			s->ssid_len = nla_len(nl);
-			wpa_printf(MSG_DEBUG,
-				   "nl80211: Scan probed for SSID '%s'",
-				   wpa_ssid_txt(s->ssid, s->ssid_len));
-			info->num_ssids++;
-			if (info->num_ssids == WPAS_MAX_SCAN_SSIDS)
-				break;
-		}
-	}
-
-	if (tb[QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES]) {
-		char msg[200], *pos, *end;
-		int res;
-
-		pos = msg;
-		end = pos + sizeof(msg);
-		*pos = '\0';
-
-		nla_for_each_nested(nl,
-				    tb[QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES],
-				    rem) {
-			freqs[num_freqs] = nla_get_u32(nl);
-			res = os_snprintf(pos, end - pos, " %d",
-					  freqs[num_freqs]);
-			if (!os_snprintf_error(end - pos, res))
-				pos += res;
-			num_freqs++;
-			if (num_freqs == MAX_REPORT_FREQS - 1)
-				break;
-		}
-
-		info->freqs = freqs;
-		info->num_freqs = num_freqs;
-		wpa_printf(MSG_DEBUG, "nl80211: Scan included frequencies:%s",
-			   msg);
-	}
-	wpa_supplicant_event(drv->ctx, EVENT_SCAN_RESULTS, &event);
-}
-
-
-static void qca_nl80211_scan_done_event(struct wpa_driver_nl80211_data *drv,
-					u8 *data, size_t len)
-{
-	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SCAN_MAX + 1];
-	u64 cookie = 0;
-	enum scan_status status;
-	int external_scan;
-
-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SCAN_MAX,
-		      (struct nlattr *) data, len, NULL) ||
-	    !tb[QCA_WLAN_VENDOR_ATTR_SCAN_STATUS] ||
-	    !tb[QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE])
-		return;
-
-	status = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SCAN_STATUS]);
-	if (status >= VENDOR_SCAN_STATUS_MAX)
-		return; /* invalid status */
-
-	cookie = nla_get_u64(tb[QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE]);
-	if (cookie != drv->vendor_scan_cookie) {
-		/* Event from an external scan, get scan results */
-		external_scan = 1;
-	} else {
-		external_scan = 0;
-		if (status == VENDOR_SCAN_STATUS_NEW_RESULTS)
-			drv->scan_state = SCAN_COMPLETED;
-		else
-			drv->scan_state = SCAN_ABORTED;
-
-		eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv,
-				     drv->ctx);
-		drv->vendor_scan_cookie = 0;
-		drv->last_scan_cmd = 0;
-	}
-
-	send_vendor_scan_event(drv, (status == VENDOR_SCAN_STATUS_ABORTED), tb,
-			       external_scan);
-}
-
-
 static void nl80211_vendor_event_qca(struct wpa_driver_nl80211_data *drv,
 				     u32 subcmd, u8 *data, size_t len)
 {
@@ -1856,12 +1709,6 @@ static void nl80211_vendor_event_qca(struct wpa_driver_nl80211_data *drv,
 	case QCA_NL80211_VENDOR_SUBCMD_DFS_OFFLOAD_RADAR_DETECTED:
 		qca_nl80211_dfs_offload_radar_event(drv, subcmd, data, len);
 		break;
-	case QCA_NL80211_VENDOR_SUBCMD_TRIGGER_SCAN:
-		qca_nl80211_scan_trigger_event(drv, data, len);
-		break;
-	case QCA_NL80211_VENDOR_SUBCMD_SCAN_DONE:
-		qca_nl80211_scan_done_event(drv, data, len);
-		break;
 	default:
 		wpa_printf(MSG_DEBUG,
 			   "nl80211: Ignore unsupported QCA vendor event %u",
@@ -1984,7 +1831,6 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 {
 	struct wpa_driver_nl80211_data *drv = bss->drv;
 	union wpa_event_data data;
-	int external_scan_event = 0;
 
 	wpa_printf(MSG_DEBUG, "nl80211: Drv Event %d (%s) received for %s",
 		   cmd, nl80211_command_to_string(cmd), bss->ifname);
@@ -2037,38 +1883,28 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 	case NL80211_CMD_NEW_SCAN_RESULTS:
 		wpa_dbg(drv->ctx, MSG_DEBUG,
 			"nl80211: New scan results available");
+		drv->scan_state = SCAN_COMPLETED;
 		drv->scan_complete_events = 1;
-		if (drv->last_scan_cmd == NL80211_CMD_TRIGGER_SCAN) {
-			drv->scan_state = SCAN_COMPLETED;
-			eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout,
-					     drv, drv->ctx);
-			drv->last_scan_cmd = 0;
-		} else {
-			external_scan_event = 1;
-		}
-		send_scan_event(drv, 0, tb, external_scan_event);
+		eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv,
+				     drv->ctx);
+		send_scan_event(drv, 0, tb);
 		break;
 	case NL80211_CMD_SCHED_SCAN_RESULTS:
 		wpa_dbg(drv->ctx, MSG_DEBUG,
 			"nl80211: New sched scan results available");
 		drv->scan_state = SCHED_SCAN_RESULTS;
-		send_scan_event(drv, 0, tb, 0);
+		send_scan_event(drv, 0, tb);
 		break;
 	case NL80211_CMD_SCAN_ABORTED:
 		wpa_dbg(drv->ctx, MSG_DEBUG, "nl80211: Scan aborted");
-		if (drv->last_scan_cmd == NL80211_CMD_TRIGGER_SCAN) {
-			drv->scan_state = SCAN_ABORTED;
-			/*
-			 * Need to indicate that scan results are available in
-			 * order not to make wpa_supplicant stop its scanning.
-			 */
-			eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout,
-					     drv, drv->ctx);
-			drv->last_scan_cmd = 0;
-		} else {
-			external_scan_event = 1;
-		}
-		send_scan_event(drv, 1, tb, external_scan_event);
+		drv->scan_state = SCAN_ABORTED;
+		/*
+		 * Need to indicate that scan results are available in order
+		 * not to make wpa_supplicant stop its scanning.
+		 */
+		eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv,
+				     drv->ctx);
+		send_scan_event(drv, 1, tb);
 		break;
 	case NL80211_CMD_AUTHENTICATE:
 	case NL80211_CMD_ASSOCIATE:
@@ -2091,7 +1927,7 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 				   tb[NL80211_ATTR_MAC],
 				   tb[NL80211_ATTR_REQ_IE],
 				   tb[NL80211_ATTR_RESP_IE],
-				   NULL, NULL, NULL, NULL, NULL);
+				   NULL, NULL, NULL, NULL);
 		break;
 	case NL80211_CMD_CH_SWITCH_NOTIFY:
 		mlme_event_ch_switch(drv,
diff --git a/src/drivers/driver_nl80211_scan.c b/src/drivers/driver_nl80211_scan.c
index b84b644..9cd3162 100644
--- a/src/drivers/driver_nl80211_scan.c
+++ b/src/drivers/driver_nl80211_scan.c
@@ -14,7 +14,6 @@
 #include "utils/common.h"
 #include "utils/eloop.h"
 #include "common/ieee802_11_defs.h"
-#include "common/qca-vendor.h"
 #include "driver_nl80211.h"
 
 
@@ -250,13 +249,6 @@ int wpa_driver_nl80211_scan(struct i802_bss *bss,
 			goto fail;
 	}
 
-	if (params->bssid) {
-		wpa_printf(MSG_DEBUG, "nl80211: Scan for a specific BSSID: "
-			   MACSTR, MAC2STR(params->bssid));
-		if (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, params->bssid))
-			goto fail;
-	}
-
 	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
 	msg = NULL;
 	if (ret) {
@@ -302,7 +294,6 @@ int wpa_driver_nl80211_scan(struct i802_bss *bss,
 	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
 	eloop_register_timeout(timeout, 0, wpa_driver_nl80211_scan_timeout,
 			       drv, drv->ctx);
-	drv->last_scan_cmd = NL80211_CMD_TRIGGER_SCAN;
 
 fail:
 	nlmsg_free(msg);
@@ -592,11 +583,6 @@ int bss_info_handler(struct nl_msg *msg, void *arg)
 		r->flags |= WPA_SCAN_LEVEL_INVALID | WPA_SCAN_QUAL_INVALID;
 	if (bss[NL80211_BSS_TSF])
 		r->tsf = nla_get_u64(bss[NL80211_BSS_TSF]);
-	if (bss[NL80211_BSS_BEACON_TSF]) {
-		u64 tsf = nla_get_u64(bss[NL80211_BSS_BEACON_TSF]);
-		if (tsf > r->tsf)
-			r->tsf = tsf;
-	}
 	if (bss[NL80211_BSS_SEEN_MS_AGO])
 		r->age = nla_get_u32(bss[NL80211_BSS_SEEN_MS_AGO]);
 	r->ie_len = ie_len;
@@ -787,209 +773,3 @@ void nl80211_dump_scan(struct wpa_driver_nl80211_data *drv)
 
 	wpa_scan_results_free(res);
 }
-
-
-int wpa_driver_nl80211_abort_scan(void *priv)
-{
-	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	int ret;
-	struct nl_msg *msg;
-
-	wpa_printf(MSG_DEBUG, "nl80211: Abort scan");
-	msg = nl80211_cmd_msg(bss, 0, NL80211_CMD_ABORT_SCAN);
-	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
-	if (ret) {
-		wpa_printf(MSG_DEBUG, "nl80211: Abort scan failed: ret=%d (%s)",
-			   ret, strerror(-ret));
-	}
-
-	return ret;
-}
-
-
-static int scan_cookie_handler(struct nl_msg *msg, void *arg)
-{
-	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
-	u64 *cookie = arg;
-
-	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		  genlmsg_attrlen(gnlh, 0), NULL);
-
-	if (tb[NL80211_ATTR_VENDOR_DATA]) {
-		struct nlattr *nl_vendor = tb[NL80211_ATTR_VENDOR_DATA];
-		struct nlattr *tb_vendor[QCA_WLAN_VENDOR_ATTR_SCAN_MAX + 1];
-
-		nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_SCAN_MAX,
-			  nla_data(nl_vendor), nla_len(nl_vendor), NULL);
-
-		if (tb_vendor[QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE])
-			*cookie = nla_get_u64(
-				tb_vendor[QCA_WLAN_VENDOR_ATTR_SCAN_COOKIE]);
-	}
-
-	return NL_SKIP;
-}
-
-
-/**
- * wpa_driver_nl80211_vendor_scan - Request the driver to initiate a vendor scan
- * @bss: Pointer to private driver data from wpa_driver_nl80211_init()
- * @params: Scan parameters
- * Returns: 0 on success, -1 on failure
- */
-int wpa_driver_nl80211_vendor_scan(struct i802_bss *bss,
-				   struct wpa_driver_scan_params *params)
-{
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	struct nl_msg *msg = NULL;
-	struct nlattr *attr;
-	size_t i;
-	u32 scan_flags = 0;
-	int ret = -1;
-	u64 cookie = 0;
-
-	wpa_dbg(drv->ctx, MSG_DEBUG, "nl80211: vendor scan request");
-	drv->scan_for_auth = 0;
-
-	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
-	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_QCA) ||
-	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
-			QCA_NL80211_VENDOR_SUBCMD_TRIGGER_SCAN) )
-		goto fail;
-
-	attr = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
-	if (attr == NULL)
-		goto fail;
-
-	if (params->num_ssids) {
-		struct nlattr *ssids;
-
-		ssids = nla_nest_start(msg, QCA_WLAN_VENDOR_ATTR_SCAN_SSIDS);
-		if (ssids == NULL)
-			goto fail;
-		for (i = 0; i < params->num_ssids; i++) {
-			wpa_hexdump_ascii(MSG_MSGDUMP, "nl80211: Scan SSID",
-					params->ssids[i].ssid,
-					params->ssids[i].ssid_len);
-			if (nla_put(msg, i + 1, params->ssids[i].ssid_len,
-				    params->ssids[i].ssid))
-				goto fail;
-		}
-		nla_nest_end(msg, ssids);
-	}
-
-	if (params->extra_ies) {
-		wpa_hexdump(MSG_MSGDUMP, "nl80211: Scan extra IEs",
-			    params->extra_ies, params->extra_ies_len);
-		if (nla_put(msg, QCA_WLAN_VENDOR_ATTR_SCAN_IE,
-			    params->extra_ies_len, params->extra_ies))
-			goto fail;
-	}
-
-	if (params->freqs) {
-		struct nlattr *freqs;
-
-		freqs = nla_nest_start(msg,
-				       QCA_WLAN_VENDOR_ATTR_SCAN_FREQUENCIES);
-		if (freqs == NULL)
-			goto fail;
-		for (i = 0; params->freqs[i]; i++) {
-			wpa_printf(MSG_MSGDUMP,
-				   "nl80211: Scan frequency %u MHz",
-				   params->freqs[i]);
-			if (nla_put_u32(msg, i + 1, params->freqs[i]))
-				goto fail;
-		}
-		nla_nest_end(msg, freqs);
-	}
-
-	os_free(drv->filter_ssids);
-	drv->filter_ssids = params->filter_ssids;
-	params->filter_ssids = NULL;
-	drv->num_filter_ssids = params->num_filter_ssids;
-
-	if (params->low_priority && drv->have_low_prio_scan) {
-		wpa_printf(MSG_DEBUG,
-			   "nl80211: Add NL80211_SCAN_FLAG_LOW_PRIORITY");
-		scan_flags |= NL80211_SCAN_FLAG_LOW_PRIORITY;
-	}
-
-	if (params->mac_addr_rand) {
-		wpa_printf(MSG_DEBUG,
-			   "nl80211: Add NL80211_SCAN_FLAG_RANDOM_ADDR");
-		scan_flags |= NL80211_SCAN_FLAG_RANDOM_ADDR;
-
-		if (params->mac_addr) {
-			wpa_printf(MSG_DEBUG, "nl80211: MAC address: " MACSTR,
-				   MAC2STR(params->mac_addr));
-			if (nla_put(msg, QCA_WLAN_VENDOR_ATTR_SCAN_MAC,
-				    ETH_ALEN, params->mac_addr))
-				goto fail;
-		}
-
-		if (params->mac_addr_mask) {
-			wpa_printf(MSG_DEBUG, "nl80211: MAC address mask: "
-				   MACSTR, MAC2STR(params->mac_addr_mask));
-			if (nla_put(msg, QCA_WLAN_VENDOR_ATTR_SCAN_MAC_MASK,
-				    ETH_ALEN, params->mac_addr_mask))
-				goto fail;
-		}
-	}
-
-	if (scan_flags &&
-	    nla_put_u32(msg, NL80211_ATTR_SCAN_FLAGS, scan_flags))
-		goto fail;
-
-	if (params->p2p_probe) {
-		struct nlattr *rates;
-
-		wpa_printf(MSG_DEBUG, "nl80211: P2P probe - mask SuppRates");
-
-		rates = nla_nest_start(msg,
-				       QCA_WLAN_VENDOR_ATTR_SCAN_SUPP_RATES);
-		if (rates == NULL)
-			goto fail;
-
-		/*
-		 * Remove 2.4 GHz rates 1, 2, 5.5, 11 Mbps from supported rates
-		 * by masking out everything else apart from the OFDM rates 6,
-		 * 9, 12, 18, 24, 36, 48, 54 Mbps from non-MCS rates. All 5 GHz
-		 * rates are left enabled.
-		 */
-		if (nla_put(msg, NL80211_BAND_2GHZ, 8,
-			    "\x0c\x12\x18\x24\x30\x48\x60\x6c"))
-			goto fail;
-		nla_nest_end(msg, rates);
-
-		if (nla_put_flag(msg, QCA_WLAN_VENDOR_ATTR_SCAN_TX_NO_CCK_RATE))
-			goto fail;
-	}
-
-	nla_nest_end(msg, attr);
-
-	ret = send_and_recv_msgs(drv, msg, scan_cookie_handler, &cookie);
-	msg = NULL;
-	if (ret) {
-		wpa_printf(MSG_DEBUG,
-			   "nl80211: Vendor scan trigger failed: ret=%d (%s)",
-			   ret, strerror(-ret));
-		goto fail;
-	}
-
-	drv->vendor_scan_cookie = cookie;
-	drv->scan_state = SCAN_REQUESTED;
-
-	wpa_printf(MSG_DEBUG,
-		   "nl80211: Vendor scan requested (ret=%d) - scan timeout 30 seconds, scan cookie:0x%llx",
-		   ret, (long long unsigned int) cookie);
-	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
-	eloop_register_timeout(30, 0, wpa_driver_nl80211_scan_timeout,
-			       drv, drv->ctx);
-	drv->last_scan_cmd = NL80211_CMD_VENDOR;
-
-fail:
-	nlmsg_free(msg);
-	return ret;
-}
diff --git a/src/drivers/linux_ioctl.c b/src/drivers/linux_ioctl.c
index e21147a..837971d 100644
--- a/src/drivers/linux_ioctl.c
+++ b/src/drivers/linux_ioctl.c
@@ -219,26 +219,3 @@ int linux_br_get(char *brname, const char *ifname)
 	os_strlcpy(brname, pos, IFNAMSIZ);
 	return 0;
 }
-
-
-int linux_master_get(char *master_ifname, const char *ifname)
-{
-	char buf[128], masterlink[128], *pos;
-	ssize_t res;
-
-	/* check whether there is a master */
-	os_snprintf(buf, sizeof(buf), "/sys/class/net/%s/master", ifname);
-
-	res = readlink(buf, masterlink, sizeof(masterlink));
-	if (res < 0 || (size_t) res >= sizeof(masterlink))
-		return -1;
-
-	masterlink[res] = '\0';
-
-	pos = os_strrchr(masterlink, '/');
-	if (pos == NULL)
-		return -1;
-	pos++;
-	os_strlcpy(master_ifname, pos, IFNAMSIZ);
-	return 0;
-}
diff --git a/src/drivers/linux_ioctl.h b/src/drivers/linux_ioctl.h
index 6de4d9b..c03fe6e 100644
--- a/src/drivers/linux_ioctl.h
+++ b/src/drivers/linux_ioctl.h
@@ -18,6 +18,5 @@ int linux_br_del(int sock, const char *brname);
 int linux_br_add_if(int sock, const char *brname, const char *ifname);
 int linux_br_del_if(int sock, const char *brname, const char *ifname);
 int linux_br_get(char *brname, const char *ifname);
-int linux_master_get(char *master_ifname, const char *ifname);
 
 #endif /* LINUX_IOCTL_H */
diff --git a/src/drivers/nl80211_copy.h b/src/drivers/nl80211_copy.h
index 7758969..83babaf 100644
--- a/src/drivers/nl80211_copy.h
+++ b/src/drivers/nl80211_copy.h
@@ -10,7 +10,6 @@
  * Copyright 2008, 2009 Luis R. Rodriguez <lrodriguez@atheros.com>
  * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
  * Copyright 2008 Colin McCabe <colin@cozybit.com>
- * Copyright 2015	Intel Deutschland GmbH
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -329,15 +328,7 @@
  *	partial scan results may be available
  *
  * @NL80211_CMD_START_SCHED_SCAN: start a scheduled scan at certain
- *	intervals and certain number of cycles, as specified by
- *	%NL80211_ATTR_SCHED_SCAN_PLANS. If %NL80211_ATTR_SCHED_SCAN_PLANS is
- *	not specified and only %NL80211_ATTR_SCHED_SCAN_INTERVAL is specified,
- *	scheduled scan will run in an infinite loop with the specified interval.
- *	These attributes are mutually exculsive,
- *	i.e. NL80211_ATTR_SCHED_SCAN_INTERVAL must not be passed if
- *	NL80211_ATTR_SCHED_SCAN_PLANS is defined.
- *	If for some reason scheduled scan is aborted by the driver, all scan
- *	plans are canceled (including scan plans that did not start yet).
+ *	intervals, as specified by %NL80211_ATTR_SCHED_SCAN_INTERVAL.
  *	Like with normal scans, if SSIDs (%NL80211_ATTR_SCAN_SSIDS)
  *	are passed, they are used in the probe requests.  For
  *	broadcast, a broadcast SSID must be passed (ie. an empty
@@ -820,10 +811,6 @@
  *	as an event to indicate changes for devices with wiphy-specific regdom
  *	management.
  *
- * @NL80211_CMD_ABORT_SCAN: Stop an ongoing scan. Returns -ENOENT if a scan is
- *	not running. The driver indicates the status of the scan through
- *	cfg80211_scan_done().
- *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -1010,8 +997,6 @@ enum nl80211_commands {
 
 	NL80211_CMD_WIPHY_REG_CHANGE,
 
-	NL80211_CMD_ABORT_SCAN,
-
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -1769,31 +1754,12 @@ enum nl80211_commands {
  *	should be contained in the result as the sum of the respective counters
  *	over all channels.
  *
- * @NL80211_ATTR_SCHED_SCAN_DELAY: delay before the first cycle of a
- *	scheduled scan is started.  Or the delay before a WoWLAN
- *	net-detect scan is started, counting from the moment the
- *	system is suspended.  This value is a u32, in seconds.
+ * @NL80211_ATTR_SCHED_SCAN_DELAY: delay before a scheduled scan (or a
+ *	WoWLAN net-detect scan) is started, u32 in seconds.
 
  * @NL80211_ATTR_REG_INDOOR: flag attribute, if set indicates that the device
  *      is operating in an indoor environment.
  *
- * @NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS: maximum number of scan plans for
- *	scheduled scan supported by the device (u32), a wiphy attribute.
- * @NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL: maximum interval (in seconds) for
- *	a scan plan (u32), a wiphy attribute.
- * @NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS: maximum number of iterations in
- *	a scan plan (u32), a wiphy attribute.
- * @NL80211_ATTR_SCHED_SCAN_PLANS: a list of scan plans for scheduled scan.
- *	Each scan plan defines the number of scan iterations and the interval
- *	between scans. The last scan plan will always run infinitely,
- *	thus it must not specify the number of iterations, only the interval
- *	between scans. The scan plans are executed sequentially.
- *	Each scan plan is a nested attribute of &enum nl80211_sched_scan_plan.
- * @NL80211_ATTR_PBSS: flag attribute. If set it means operate
- *	in a PBSS. Specified in %NL80211_CMD_CONNECT to request
- *	connecting to a PCP, and in %NL80211_CMD_START_AP to start
- *	a PCP instead of AP. Relevant for DMG networks only.
- *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -2163,13 +2129,6 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_REG_INDOOR,
 
-	NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS,
-	NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL,
-	NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS,
-	NL80211_ATTR_SCHED_SCAN_PLANS,
-
-	NL80211_ATTR_PBSS,
-
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -2660,17 +2619,16 @@ enum nl80211_band_attr {
  *	an indoor surroundings, i.e., it is connected to AC power (and not
  *	through portable DC inverters) or is under the control of a master
  *	that is acting as an AP and is connected to AC power.
- * @NL80211_FREQUENCY_ATTR_IR_CONCURRENT: IR operation is allowed on this
+ * @NL80211_FREQUENCY_ATTR_GO_CONCURRENT: GO operation is allowed on this
  *	channel if it's connected concurrently to a BSS on the same channel on
  *	the 2 GHz band or to a channel in the same UNII band (on the 5 GHz
- *	band), and IEEE80211_CHAN_RADAR is not set. Instantiating a GO or TDLS
- *	off-channel on a channel that has the IR_CONCURRENT attribute set can be
- *	done when there is a clear assessment that the device is operating under
- *	the guidance of an authorized master, i.e., setting up a GO or TDLS
- *	off-channel while the device is also connected to an AP with DFS and
- *	radar detection on the UNII band (it is up to user-space, i.e.,
- *	wpa_supplicant to perform the required verifications). Using this
- *	attribute for IR is disallowed for master interfaces (IBSS, AP).
+ *	band), and IEEE80211_CHAN_RADAR is not set. Instantiating a GO on a
+ *	channel that has the GO_CONCURRENT attribute set can be done when there
+ *	is a clear assessment that the device is operating under the guidance of
+ *	an authorized master, i.e., setting up a GO while the device is also
+ *	connected to an AP with DFS and radar detection on the UNII band (it is
+ *	up to user-space, i.e., wpa_supplicant to perform the required
+ *	verifications)
  * @NL80211_FREQUENCY_ATTR_NO_20MHZ: 20 MHz operation is not allowed
  *	on this channel in current regulatory domain.
  * @NL80211_FREQUENCY_ATTR_NO_10MHZ: 10 MHz operation is not allowed
@@ -2682,7 +2640,7 @@ enum nl80211_band_attr {
  * See https://apps.fcc.gov/eas/comments/GetPublishedDocument.html?id=327&tn=528122
  * for more information on the FCC description of the relaxations allowed
  * by NL80211_FREQUENCY_ATTR_INDOOR_ONLY and
- * NL80211_FREQUENCY_ATTR_IR_CONCURRENT.
+ * NL80211_FREQUENCY_ATTR_GO_CONCURRENT.
  */
 enum nl80211_frequency_attr {
 	__NL80211_FREQUENCY_ATTR_INVALID,
@@ -2700,7 +2658,7 @@ enum nl80211_frequency_attr {
 	NL80211_FREQUENCY_ATTR_NO_160MHZ,
 	NL80211_FREQUENCY_ATTR_DFS_CAC_TIME,
 	NL80211_FREQUENCY_ATTR_INDOOR_ONLY,
-	NL80211_FREQUENCY_ATTR_IR_CONCURRENT,
+	NL80211_FREQUENCY_ATTR_GO_CONCURRENT,
 	NL80211_FREQUENCY_ATTR_NO_20MHZ,
 	NL80211_FREQUENCY_ATTR_NO_10MHZ,
 
@@ -2713,8 +2671,6 @@ enum nl80211_frequency_attr {
 #define NL80211_FREQUENCY_ATTR_PASSIVE_SCAN	NL80211_FREQUENCY_ATTR_NO_IR
 #define NL80211_FREQUENCY_ATTR_NO_IBSS		NL80211_FREQUENCY_ATTR_NO_IR
 #define NL80211_FREQUENCY_ATTR_NO_IR		NL80211_FREQUENCY_ATTR_NO_IR
-#define NL80211_FREQUENCY_ATTR_GO_CONCURRENT \
-					NL80211_FREQUENCY_ATTR_IR_CONCURRENT
 
 /**
  * enum nl80211_bitrate_attr - bitrate attributes
@@ -2873,7 +2829,7 @@ enum nl80211_sched_scan_match_attr {
  * @NL80211_RRF_AUTO_BW: maximum available bandwidth should be calculated
  *	base on contiguous rules and wider channels will be allowed to cross
  *	multiple contiguous/overlapping frequency ranges.
- * @NL80211_RRF_IR_CONCURRENT: See &NL80211_FREQUENCY_ATTR_IR_CONCURRENT
+ * @NL80211_RRF_GO_CONCURRENT: See &NL80211_FREQUENCY_ATTR_GO_CONCURRENT
  * @NL80211_RRF_NO_HT40MINUS: channels can't be used in HT40- operation
  * @NL80211_RRF_NO_HT40PLUS: channels can't be used in HT40+ operation
  * @NL80211_RRF_NO_80MHZ: 80MHz operation not allowed
@@ -2890,7 +2846,7 @@ enum nl80211_reg_rule_flags {
 	NL80211_RRF_NO_IR		= 1<<7,
 	__NL80211_RRF_NO_IBSS		= 1<<8,
 	NL80211_RRF_AUTO_BW		= 1<<11,
-	NL80211_RRF_IR_CONCURRENT	= 1<<12,
+	NL80211_RRF_GO_CONCURRENT	= 1<<12,
 	NL80211_RRF_NO_HT40MINUS	= 1<<13,
 	NL80211_RRF_NO_HT40PLUS		= 1<<14,
 	NL80211_RRF_NO_80MHZ		= 1<<15,
@@ -2902,7 +2858,6 @@ enum nl80211_reg_rule_flags {
 #define NL80211_RRF_NO_IR		NL80211_RRF_NO_IR
 #define NL80211_RRF_NO_HT40		(NL80211_RRF_NO_HT40MINUS |\
 					 NL80211_RRF_NO_HT40PLUS)
-#define NL80211_RRF_GO_CONCURRENT	NL80211_RRF_IR_CONCURRENT
 
 /* For backport compatibility with older userspace */
 #define NL80211_RRF_NO_IR_ALL		(NL80211_RRF_NO_IR | __NL80211_RRF_NO_IBSS)
@@ -3404,9 +3359,6 @@ enum nl80211_bss_scan_width {
  *	(not present if no beacon frame has been received yet)
  * @NL80211_BSS_PRESP_DATA: the data in @NL80211_BSS_INFORMATION_ELEMENTS and
  *	@NL80211_BSS_TSF is known to be from a probe response (flag attribute)
- * @NL80211_BSS_LAST_SEEN_BOOTTIME: CLOCK_BOOTTIME timestamp when this entry
- *	was last updated by a received frame. The value is expected to be
- *	accurate to about 10ms. (u64, nanoseconds)
  * @__NL80211_BSS_AFTER_LAST: internal
  * @NL80211_BSS_MAX: highest BSS attribute
  */
@@ -3426,7 +3378,6 @@ enum nl80211_bss {
 	NL80211_BSS_CHAN_WIDTH,
 	NL80211_BSS_BEACON_TSF,
 	NL80211_BSS_PRESP_DATA,
-	NL80211_BSS_LAST_SEEN_BOOTTIME,
 
 	/* keep last */
 	__NL80211_BSS_AFTER_LAST,
@@ -3506,6 +3457,9 @@ enum nl80211_mfp {
 enum nl80211_wpa_versions {
 	NL80211_WPA_VERSION_1 = 1 << 0,
 	NL80211_WPA_VERSION_2 = 1 << 1,
+#ifdef CONFIG_WAPI
+	NL80211_WAPI_VERSION_1 = 1 << 2,
+#endif
 };
 
 /**
@@ -4633,28 +4587,4 @@ enum nl80211_tdls_peer_capability {
 	NL80211_TDLS_PEER_WMM = 1<<2,
 };
 
-/**
- * enum nl80211_sched_scan_plan - scanning plan for scheduled scan
- * @__NL80211_SCHED_SCAN_PLAN_INVALID: attribute number 0 is reserved
- * @NL80211_SCHED_SCAN_PLAN_INTERVAL: interval between scan iterations. In
- *	seconds (u32).
- * @NL80211_SCHED_SCAN_PLAN_ITERATIONS: number of scan iterations in this
- *	scan plan (u32). The last scan plan must not specify this attribute
- *	because it will run infinitely. A value of zero is invalid as it will
- *	make the scan plan meaningless.
- * @NL80211_SCHED_SCAN_PLAN_MAX: highest scheduled scan plan attribute number
- *	currently defined
- * @__NL80211_SCHED_SCAN_PLAN_AFTER_LAST: internal use
- */
-enum nl80211_sched_scan_plan {
-	__NL80211_SCHED_SCAN_PLAN_INVALID,
-	NL80211_SCHED_SCAN_PLAN_INTERVAL,
-	NL80211_SCHED_SCAN_PLAN_ITERATIONS,
-
-	/* keep last */
-	__NL80211_SCHED_SCAN_PLAN_AFTER_LAST,
-	NL80211_SCHED_SCAN_PLAN_MAX =
-		__NL80211_SCHED_SCAN_PLAN_AFTER_LAST - 1
-};
-
 #endif /* __LINUX_NL80211_H */
diff --git a/src/eap_peer/eap.c b/src/eap_peer/eap.c
index 1dbe003..ad9c871 100644
--- a/src/eap_peer/eap.c
+++ b/src/eap_peer/eap.c
@@ -1375,10 +1375,131 @@ static int eap_sm_imsi_identity(struct eap_sm *sm,
 
 #endif /* PCSC_FUNCS */
 
+#ifdef CONFIG_ATCI
+
+int eap_sm_get_sim_slot(struct eap_sm *sm)
+{
+	struct eap_peer_config *conf;
+	conf = eap_get_config(sm);
+	if (conf == NULL) return -1;
+	return conf->sim_num;
+}
+
+static int eap_sm_append_3gpp_realm(struct eap_sm *sm, char *imsi,
+				    size_t max_len, size_t *imsi_len)
+{
+	int mnc_len;
+	char *pos, mnc[4];
+
+	if (*imsi_len + 36 > max_len) {
+		wpa_printf(MSG_WARNING, "No room for realm in IMSI buffer");
+		return -1;
+	}
+
+	/* MNC (2 or 3 digits) */
+	mnc_len = scard_get_mnc_len(eap_sm_get_sim_slot(sm));
+	if (mnc_len < 0) {
+		wpa_printf(MSG_INFO, "Failed to get MNC length from (U)SIM "
+			   "assuming 3");
+		mnc_len = 3;
+	}
+
+	if (mnc_len == 2) {
+		mnc[0] = '0';
+		mnc[1] = imsi[3];
+		mnc[2] = imsi[4];
+	} else if (mnc_len == 3) {
+		mnc[0] = imsi[3];
+		mnc[1] = imsi[4];
+		mnc[2] = imsi[5];
+	}
+	mnc[3] = '\0';
+
+	pos = imsi + *imsi_len;
+	pos += os_snprintf(pos, imsi + max_len - pos,
+			   "@wlan.mnc%s.mcc%c%c%c.3gppnetwork.org",
+			   mnc, imsi[0], imsi[1], imsi[2]);
+	*imsi_len = pos - imsi;
+
+	return 0;
+}
+
+static int eap_sm_imsi_identity(struct eap_sm *sm,
+				struct eap_peer_config *conf)
+{
+	enum { EAP_SM_SIM, EAP_SM_AKA, EAP_SM_AKA_PRIME } method = EAP_SM_SIM;
+	char imsi[100];
+	size_t imsi_len;
+	struct eap_method_type *m = conf->eap_methods;
+	int i;
+
+	imsi_len = sizeof(imsi);
+	if (scard_get_imsi(eap_sm_get_sim_slot(sm), imsi, &imsi_len)) {
+		wpa_printf(MSG_WARNING, "Failed to get IMSI from SIM");
+		return -1;
+	}
+
+	wpa_hexdump_ascii(MSG_DEBUG, "IMSI", (u8 *) imsi, imsi_len);
+
+	if (imsi_len < 7) {
+		wpa_printf(MSG_WARNING, "Too short IMSI for SIM identity");
+		return -1;
+	}
+
+	if (eap_sm_append_3gpp_realm(sm, imsi, sizeof(imsi), &imsi_len) < 0) {
+		wpa_printf(MSG_WARNING, "Could not add realm to SIM identity");
+		return -1;
+	}
+	wpa_hexdump_ascii(MSG_DEBUG, "IMSI + realm", (u8 *) imsi, imsi_len);
+
+	for (i = 0; m && (m[i].vendor != EAP_VENDOR_IETF ||
+			  m[i].method != EAP_TYPE_NONE); i++) {
+		if (m[i].vendor == EAP_VENDOR_IETF &&
+		    m[i].method == EAP_TYPE_AKA_PRIME) {
+			method = EAP_SM_AKA_PRIME;
+			break;
+		}
+
+		if (m[i].vendor == EAP_VENDOR_IETF &&
+		    m[i].method == EAP_TYPE_AKA) {
+			method = EAP_SM_AKA;
+			break;
+		}
+	}
+
+	os_free(conf->identity);
+	conf->identity = os_malloc(1 + imsi_len);
+	if (conf->identity == NULL) {
+		wpa_printf(MSG_WARNING, "Failed to allocate buffer for "
+			   "IMSI-based identity");
+		return -1;
+	}
+
+	switch (method) {
+	case EAP_SM_SIM:
+		conf->identity[0] = '1';
+		break;
+	case EAP_SM_AKA:
+		conf->identity[0] = '0';
+		break;
+	case EAP_SM_AKA_PRIME:
+		conf->identity[0] = '6';
+		break;
+	}
+	os_memcpy(conf->identity + 1, imsi, imsi_len);
+	conf->identity_len = 1 + imsi_len;
+
+	return 0;
+}
+
+#endif /* CONFIG_ATCI */
 
 static int eap_sm_set_scard_pin(struct eap_sm *sm,
 				struct eap_peer_config *conf)
 {
+#ifdef CONFIG_ATCI
+	return 0;
+#endif
 #ifdef PCSC_FUNCS
 	if (scard_set_pin(sm->scard_ctx, conf->pin)) {
 		/*
@@ -1401,6 +1522,9 @@ static int eap_sm_set_scard_pin(struct eap_sm *sm,
 static int eap_sm_get_scard_identity(struct eap_sm *sm,
 				     struct eap_peer_config *conf)
 {
+#ifdef CONFIG_ATCI
+	return eap_sm_imsi_identity(sm, conf);
+#endif
 #ifdef PCSC_FUNCS
 	if (eap_sm_set_scard_pin(sm, conf))
 		return -1;
@@ -1441,6 +1565,44 @@ struct wpabuf * eap_sm_buildIdentity(struct eap_sm *sm, int id, int encrypted)
 					    &identity_len)) != NULL) {
 		wpa_hexdump_ascii(MSG_DEBUG, "EAP: using method re-auth "
 				  "identity", identity, identity_len);
+#ifdef CONFIG_ATCI
+	} else if (config->eap_methods && (config->eap_methods[0].method == EAP_TYPE_SIM
+								|| config->eap_methods[0].method == EAP_TYPE_AKA
+								|| config->eap_methods[0].method == EAP_TYPE_AKA_PRIME)) {
+		if(config->identity == NULL) {
+			if (eap_sm_get_scard_identity(sm, config) < 0) return NULL;
+			wpa_printf(MSG_DEBUG, "EAP-SIM: the identity in configuration file was NULL");
+			identity = config->identity;
+			identity_len = config->identity_len;
+		} else {
+			u8 nai[100];
+			size_t nai_len;
+			os_memcpy(nai, config->identity, config->identity_len);
+			nai_len = config->identity_len;
+			if (eap_sm_get_scard_identity(sm, config) < 0) return NULL;
+			if(nai_len != config->identity_len) {
+				wpa_printf(MSG_DEBUG, "EAP-SIM: the nai length in configuration file does not match the current sim value");
+				identity = config->identity;
+				identity_len = config->identity_len;
+			}
+			if(os_memcmp(nai, config->identity, config->identity_len) ) {
+				wpa_printf(MSG_DEBUG, "EAP-SIM: the nai in configuration file does not match the current sim value");
+				identity = config->identity;
+				identity_len = config->identity_len;
+			} else {
+				if(config->anonymous_identity) {
+					wpa_printf(MSG_DEBUG, "EAP-SIM: the sim card has not been changed, use pseudonym NAI");
+					identity = config->anonymous_identity;
+					identity_len = config->anonymous_identity_len;
+				} else {
+					wpa_printf(MSG_DEBUG, "EAP-SIM: the sim card has not been changed, use real NAI");
+					identity = config->identity;
+					identity_len = config->identity_len;
+				}
+			}
+		}
+		wpa_hexdump_ascii(MSG_DEBUG, "EAP-SIM: the NAI is", identity, identity_len);
+#endif
 	} else if (!encrypted && config->anonymous_identity) {
 		identity = config->anonymous_identity;
 		identity_len = config->anonymous_identity_len;
diff --git a/src/eap_peer/eap.h b/src/eap_peer/eap.h
index 1a645af..325d384 100644
--- a/src/eap_peer/eap.h
+++ b/src/eap_peer/eap.h
@@ -348,6 +348,9 @@ void eap_sm_set_ext_pw_ctx(struct eap_sm *sm, struct ext_password_data *ext);
 void eap_set_anon_id(struct eap_sm *sm, const u8 *id, size_t len);
 int eap_peer_was_failure_expected(struct eap_sm *sm);
 void eap_peer_erp_free_keys(struct eap_sm *sm);
+#ifdef CONFIG_ATCI
+int eap_sm_get_sim_slot(struct eap_sm *sm);
+#endif
 
 #endif /* IEEE8021X_EAPOL */
 
diff --git a/src/eap_peer/eap_aka.c b/src/eap_peer/eap_aka.c
index dc9e8cc..7531798 100644
--- a/src/eap_peer/eap_aka.c
+++ b/src/eap_peer/eap_aka.c
@@ -249,6 +249,12 @@ static int eap_aka_umts_auth(struct eap_sm *sm, struct eap_aka_data *data)
 	if (conf == NULL)
 		return -1;
 
+#ifdef CONFIG_ATCI
+		return scard_umts_auth(eap_sm_get_sim_slot(sm), data->rand,
+					   data->autn, data->res, &data->res_len,
+					   data->ik, data->ck, data->auts);
+#endif
+
 	if (sm->external_sim) {
 		if (conf->external_sim_resp)
 			return eap_aka_ext_sim_result(sm, data, conf);
diff --git a/src/eap_peer/eap_proxy_qmi.c b/src/eap_peer/eap_proxy_qmi.c
deleted file mode 100644
index fc469e6..0000000
--- a/src/eap_peer/eap_proxy_qmi.c
+++ /dev/null
@@ -1,2064 +0,0 @@
-/*--------------------------------------------------------------------------
-Copyright (c) 2013, The Linux Foundation. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-    * Neither the name of The Linux Foundation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------*/
-
-#include "includes.h"
-#include "common.h"
-
-#ifdef CONFIG_EAP_PROXY
-#include "qmi_client.h"
-#include "eap_proxy_qmi.h"
-#include "qmi_client.h"
-#include "qmi_idl_lib.h"
-#include "authentication_service_v01.h"
-#include "user_identity_module_v01.h"
-#include "eap_config.h"
-#include "common/wpa_ctrl.h"
-#if defined(ANDROID)
-#include <cutils/properties.h>
-#ifdef CONFIG_EAP_PROXY_MDM_DETECT
-#include "mdm_detect.h"
-#endif /* CONFIG_EAP_PROXY_MDM_DETECT */
-#if defined(__BIONIC_FORTIFY)
-#include <sys/system_properties.h>
-#endif
-#endif
-#include <pthread.h>
-#include <sys/syscall.h>
-#include <sys/types.h>
-
-#define IMSI_LENGTH 15
-#define WPA_UIM_QMI_EVENT_MASK_CARD_STATUS        \
-					(1 << QMI_UIM_EVENT_CARD_STATUS_BIT_V01)
-#define WPA_UIM_QMI_EVENT_READ_TRANSPARENT_REQ    \
-					(1 << QMI_UIM_READ_TRANSPARENT_REQ_V01)
-
-/* Default timeout (in milli-seconds) for synchronous QMI message */
-#define WPA_UIM_QMI_DEFAULT_TIMEOUT               5000
-
-#define EAP_PROXY_PROPERTY_BASEBAND	"ro.baseband"
-#ifdef CONFIG_EAP_PROXY_MSM8994_TARGET
-#define EAP_PROXY_TARGET_PLATFORM	"ro.board.platform"
-#endif /* CONFIG_EAP_PROXY_MSM8994_TARGET */
-#if defined(__BIONIC_FORTIFY)
-#define EAP_PROXY_PROPERTY_BASEBAND_SIZE   PROP_VALUE_MAX
-#else
-#define EAP_PROXY_PROPERTY_BASEBAND_SIZE   10
-#endif
-#define EAP_PROXY_BASEBAND_VALUE_MSM       "msm"
-#define EAP_PROXY_BASEBAND_VALUE_APQ       "apq"
-#define EAP_PROXY_BASEBAND_VALUE_SVLTE1    "svlte1"
-#define EAP_PROXY_BASEBAND_VALUE_SVLTE2A   "svlte2a"
-#define EAP_PROXY_BASEBAND_VALUE_SGLTE     "sglte"
-#define EAP_PROXY_BASEBAND_VALUE_CSFB      "csfb"
-#define EAP_PROXY_BASEBAND_VALUE_MDMUSB    "mdm"
-#ifdef CONFIG_EAP_PROXY_MSM8994_TARGET
-#define EAP_PROXY_TARGET_PLATFORM_MSM8994  "msm8994"
-#endif /* CONFIG_EAP_PROXY_MSM8994_TARGET */
-#define EAP_PROXY_TARGET_FUSION4_5_PCIE    "fusion4_5_pcie"
-#define EAP_PROXY_BASEBAND_VALUE_UNDEFINED "undefined"
-
-#ifndef ANDROID
-#ifdef SYS_gettid
-static inline pid_t gettid(void)
-{
-	return syscall(SYS_gettid);
-}
-#else
-static inline pid_t gettid(void)
-{
-	return -1;
-}
-#endif
-#endif
-
-
-static void eap_proxy_eapol_sm_set_bool(struct eap_proxy_sm *sm,
-			 enum eapol_bool_var var, Boolean value);
-static Boolean eap_proxy_eapol_sm_get_bool(struct eap_proxy_sm *sm,
-					enum eapol_bool_var var);
-
-/* Call-back function to process an authenticationr result indication from
- * QMI EAP service */
-static void handle_qmi_eap_ind(qmi_client_type user_handle,
-                unsigned int msg_id,
-                void* ind_buf,
-                unsigned int ind_buf_len,
-                void* ind_cb_data);
-
-static u8 *eap_proxy_getKey(struct eap_proxy_sm *eap_proxy);
-static enum eap_proxy_status eap_proxy_qmi_response_wait(struct eap_proxy_sm *eap_proxy);
-static int eap_proxy_is_state_changed(struct eap_proxy_sm *sm);
-static enum eap_proxy_status eap_proxy_process(struct eap_proxy_sm  *eap_proxy,
-					u8 *eapReqData, int eapReqDataLen, struct eap_sm *eap_sm);
-static char bin_to_hexchar(u8 ch);
-
-static void wpa_qmi_client_indication_cb
-(
-	qmi_client_type                user_handle,
-	unsigned long                  msg_id,
-	unsigned char                 *ind_buf_ptr,
-	int                            ind_buf_len,
-	void                          *ind_cb_data
-);
-static void dump_buff(u8 *buff, int len);
-#ifdef CONFIG_CTRL_IFACE
-static const char *eap_proxy_sm_state_txt(int state);
-#endif /* CONFIG_CTRL_IFACE */
-static Boolean eap_proxy_build_identity(struct eap_proxy_sm *eap_proxy, u8 id,
-                                                 struct eap_sm *eap_sm);
-
-#ifdef SIM_AKA_IDENTITY_IMSI
-static char *imsi;
-static int imsi_len_g = 0;
-static int card_mnc_len = -1;
-#ifdef CONFIG_EAP_PROXY_DUAL_SIM
-static unsigned int slot = 0;
-static unsigned int session_type;
-#endif /* CONFIG_EAP_PROXY_DUAL_SIM */
-
-static Boolean wpa_qmi_register_events(int sim_num, wpa_uim_struct_type *wpa_uim);
-static Boolean wpa_qmi_read_card_imsi(int sim_num, wpa_uim_struct_type *wpa_uim);
-static Boolean wpa_qmi_read_card_status(int sim_num, wpa_uim_struct_type *wpa_uim);
-
-#endif
-#define EAP_SUB_TYPE_SIM_START     0x0a
-#define EAP_SUB_TYPE_AKA_IDENTITY  0x05
-#define EAP_RESP_TYPE_NAK             3
-
-
-#ifdef SIM_AKA_IDENTITY_IMSI
-static void wpa_qmi_client_indication_cb
-(
-        qmi_client_type                user_handle,
-        unsigned long                  msg_id,
-        unsigned char                 *ind_buf_ptr,
-        int                            ind_buf_len,
-        void                          *ind_cb_data
-)
-{
-        /* we currently not need the card status changes */
-        /* Making this a dummy CB handler */
-}
-
-static Boolean wpa_qmi_register_events(int sim_num, wpa_uim_struct_type *wpa_uim)
-{
-	qmi_client_error_type               qmi_err_code      = 0;
-	uim_event_reg_resp_msg_v01          event_resp_msg;
-	uim_event_reg_req_msg_v01           event_reg_params;
-
-	/* Register for events first */
-	os_memset(&event_reg_params, 0, sizeof(uim_event_reg_req_msg_v01));
-	os_memset(&event_resp_msg, 0, sizeof(uim_event_reg_resp_msg_v01));
-
-	event_reg_params.event_mask |= (WPA_UIM_QMI_EVENT_MASK_CARD_STATUS);
-	qmi_err_code = qmi_client_send_msg_sync(wpa_uim[sim_num].qmi_uim_svc_client_ptr,
-						QMI_UIM_EVENT_REG_REQ_V01,
-						(void *) &event_reg_params,
-						sizeof(uim_event_reg_req_msg_v01),
-						(void *) &event_resp_msg,
-						sizeof(uim_event_reg_resp_msg_v01),
-						WPA_UIM_QMI_DEFAULT_TIMEOUT);
-
-	wpa_printf(MSG_ERROR, "eap_proxy: QMI_UIM_EVENT_REG_REQ_V01, "
-		   "qmi_err_code: 0x%x wpa_uim[%d].qmi_uim_svc_client_ptr =%p"
-		   "Error=0x%x", qmi_err_code, sim_num,
-		    wpa_uim[sim_num].qmi_uim_svc_client_ptr,
-		    event_resp_msg.resp.error);
-
-	if (qmi_err_code != QMI_NO_ERR ||
-	    (event_resp_msg.resp.result != QMI_RESULT_SUCCESS_V01 &&
-	     event_resp_msg.resp.error != QMI_ERR_NO_EFFECT_V01)) {
-		wpa_printf(MSG_ERROR,"QMI-ERROR Error for "
-			   "QMI_UIM_EVENT_REG_REQ_V01, qmi_err_code=%d"
-			   "Error=%d\n", qmi_err_code,
-			    event_resp_msg.resp.error);
-		return FALSE;
-	}
-
-	if(event_resp_msg.event_mask_valid)
-	{
-		wpa_printf(MSG_ERROR, "eap_proxy: event_resp_msg.event=%d,\n",
-			   event_resp_msg.event_mask);
-
-	}
-
-	if (wpa_qmi_read_card_status(sim_num, wpa_uim))
-		return TRUE;
-	else {
-		wpa_printf(MSG_ERROR,"eap_proxy: Error while reading SIM card status\n");
-		return FALSE;
-	}
-}
-
-static Boolean wpa_qmi_read_card_status(int sim_num, wpa_uim_struct_type *wpa_uim)
-{
-	unsigned int                        i = 0, j = 0;
-	Boolean                             card_found = FALSE;
-	qmi_client_error_type               qmi_err_code      = 0;
-	uim_get_card_status_resp_msg_v01   card_status_resp_msg;
-
-	wpa_printf (MSG_ERROR, "eap_proxy: reading card %d values\n", sim_num+1);
-	os_memset(&card_status_resp_msg,
-		  0,
-		  sizeof(uim_get_card_status_resp_msg_v01));
-	qmi_err_code = qmi_client_send_msg_sync(wpa_uim[sim_num].qmi_uim_svc_client_ptr,
-						QMI_UIM_GET_CARD_STATUS_REQ_V01,
-						NULL,
-						0,
-						(void *)&card_status_resp_msg,
-						sizeof(uim_get_card_status_resp_msg_v01),
-						WPA_UIM_QMI_DEFAULT_TIMEOUT);
-
-	if (qmi_err_code != QMI_NO_ERR ||
-	    card_status_resp_msg.resp.result != QMI_RESULT_SUCCESS_V01) {
-		wpa_printf(MSG_ERROR, "QMI-ERROR Error for "
-			   "QMI_UIM_GET_CARD_STATUS_REQ_V01, qmi_err_code: 0x%x\n "
-			   "resp_err = %d \n", qmi_err_code, card_status_resp_msg.resp.error);
-		return FALSE;
-	}
-
-	/* Updated global card status if needed */
-	if (!card_status_resp_msg.card_status_valid ||
-	    (card_status_resp_msg.resp.result != QMI_RESULT_SUCCESS_V01)) {
-		wpa_printf(MSG_ERROR, "eap_proxy: card_status is not valid !\n");
-		return FALSE;
-	}
-	/* Update global in case of new card state or error code */
-	i = sim_num;
-	if ( i < QMI_UIM_CARDS_MAX_V01 &&
-	     i < card_status_resp_msg.card_status.card_info_len ) {
-		wpa_printf(MSG_ERROR, "eap_proxy: card_info[i].card_state: 0x%x\n",
-			card_status_resp_msg.card_status.card_info[i].card_state);
-		wpa_printf(MSG_ERROR, "eap_proxy: card_info[i].error_code: 0x%x\n",
-			card_status_resp_msg.card_status.card_info[i].error_code);
-
-		wpa_uim[sim_num].card_info[i].card_state =
-			card_status_resp_msg.card_status.card_info[i].card_state;
-
-		wpa_uim[sim_num].card_info[i].card_error_code =
-			card_status_resp_msg.card_status.card_info[i].error_code;
-#ifdef CONFIG_EAP_PROXY_DUAL_SIM
-	    do {
-		   if (card_status_resp_msg.card_status.index_gw_pri != 0xFFFF) {
-			slot = (card_status_resp_msg.card_status.index_gw_pri & 0xFF00) >> 8;
-			if (slot == i) {
-			    session_type = UIM_SESSION_TYPE_PRIMARY_GW_V01;
-			    wpa_printf (MSG_ERROR, "eap_proxy: read_card_status: prime slot = %d\n", slot);
-			    break;
-			}
-		   }
-		   if (card_status_resp_msg.card_status.index_gw_sec != 0xFFFF) {
-			slot = (card_status_resp_msg.card_status.index_gw_sec & 0xFF00) >> 8;
-			if (slot == i) {
-			    session_type = UIM_SESSION_TYPE_SECONDARY_GW_V01;
-			    wpa_printf (MSG_ERROR, "eap_proxy: read_card_status: second slot = %d\n", slot);
-			    break;
-			}
-		   }
-		   wpa_printf (MSG_ERROR, "eap_proxy: read_card_status: Not GW it's 1x\n");
-		   return FALSE;
-		}while(0);
-
-		if (slot > 1){
-			wpa_printf (MSG_ERROR, "eap_proxy: read_card_status: INVALID slot = %d and i = %d\n", slot, i);
-			return FALSE;
-		}
-#endif /* CONFIG_EAP_PROXY_DUAL_SIM */
-
-		if (card_status_resp_msg.card_status.card_info[i].card_state ==
-		    UIM_CARD_STATE_PRESENT_V01) {
-			for (j = 0 ; j < QMI_UIM_APPS_MAX_V01 ; j++) {
-				wpa_uim[sim_num].card_info[i].app_type =
-					card_status_resp_msg.card_status.card_info[i].app_info[j].app_type;
-
-				wpa_uim[sim_num].card_info[i].app_state =
-					card_status_resp_msg.card_status.card_info[i].app_info[j].app_state;
-
-				if (((card_status_resp_msg.card_status.card_info[i].app_info[j].app_type == 1) ||
-				(card_status_resp_msg.card_status.card_info[i].app_info[j].app_type == 2)) &&
-				(card_status_resp_msg.card_status.card_info[i].app_info[j].app_state ==
-				UIM_APP_STATE_READY_V01)) {
-					wpa_printf(MSG_ERROR, "eap_proxy: card READY\n");
-					wpa_printf(MSG_ERROR, "eap_proxy: card_info[i].app_type : 0x%x\n",
-					card_status_resp_msg.card_status.card_info[i].app_info[j].app_type);
-					wpa_printf(MSG_ERROR, "eap_proxy: card_info[i].app_state : 0x%x\n",
-					card_status_resp_msg.card_status.card_info[i].app_info[j].app_state);
-					card_found = TRUE;
-					break;
-				}
-			}
-		}
-
-		if (card_found) {
-			wpa_printf(MSG_ERROR, "eap_proxy: card found for SIM = %d\n", sim_num+1);
-		}
-	}
-
-	if ((!card_found) || (i == QMI_UIM_CARDS_MAX_V01) ||
-		(j == QMI_UIM_APPS_MAX_V01)) {
-		wpa_printf(MSG_ERROR, "eap_proxy: SIM/USIM not ready card_found=%d\n",card_found);
-		return FALSE;
-	}
-
-	wpa_printf(MSG_ERROR, "eap_proxy: SIM/USIM ready\n");
-	wpa_uim[sim_num].card_ready_idx = i;
-
-	return TRUE;
-} /* wpa_qmi_read_card_status */
-
-static int check_for_3_digit()
-{
-	int mcc = 0,i =0;
-//      -- 3 digits if MCC belongs to this group: 302, 310, 311, 312, 313, 314, 315, 316, 334, 348 (decimal)
-//      -- 2 digits in all other cases
-	int valid_mcc[] = {302, 310, 311, 312, 313, 314, 315, 316, 334, 348};
-
-        mcc = ((imsi[0]-0x30)*100) + ((imsi[1]-0x30)*10) + (imsi[2]-0x30); //imsi values are hex characters
-	wpa_printf(MSG_ERROR, "mcc from the SIM is %d\n", mcc);
-	for(i = 0; i < sizeof(valid_mcc)/sizeof(valid_mcc[0]); i++)
-	{
-		if(mcc == valid_mcc[i])
-			return 1;
-	}
-	return 0;
-}
-
-static Boolean wpa_qmi_read_card_imsi(int sim_num, wpa_uim_struct_type *wpa_uim)
-{
-	int			length;
-	unsigned char           *data;
-	int                     src = 0, dst = 0;
-	Boolean                 card_found = FALSE,
-	qmi_status = TRUE;
-	qmi_client_error_type               qmi_err_code = 0;
-	uim_read_transparent_req_msg_v01   qmi_read_trans_req;
-	uim_read_transparent_resp_msg_v01  read_trans_resp;
-	card_mnc_len = -1;
-
-
-	os_memset(&read_trans_resp, 0,
-		  sizeof(uim_read_transparent_resp_msg_v01));
-	os_memset(&qmi_read_trans_req, 0,
-			sizeof(uim_read_transparent_req_msg_v01));
-
-	qmi_read_trans_req.read_transparent.length = 0;
-	qmi_read_trans_req.read_transparent.offset = 0;
-	qmi_read_trans_req.file_id.file_id = 0x6F07;
-	qmi_read_trans_req.file_id.path_len = 4;
-
-#ifdef CONFIG_EAP_PROXY_DUAL_SIM
-	wpa_printf (MSG_ERROR, "eap_proxy: read_card_imsi: session_type = %d\n", session_type);
-	qmi_read_trans_req.session_information.session_type = session_type;
-#else
-	qmi_read_trans_req.session_information.session_type =
-				UIM_SESSION_TYPE_PRIMARY_GW_V01;
-#endif /* CONFIG_EAP_PROXY_DUAL_SIM */
-	qmi_read_trans_req.session_information.aid_len = 0;
-
-	/* For USIM*/
-	if (wpa_uim[sim_num].card_info[wpa_uim[sim_num].card_ready_idx].app_type ==
-		UIM_APP_TYPE_USIM_V01) {
-		qmi_read_trans_req.file_id.path[0] = 0x00;
-		qmi_read_trans_req.file_id.path[1] = 0x3F;
-		qmi_read_trans_req.file_id.path[2] = 0xFF;
-		qmi_read_trans_req.file_id.path[3] = 0x7F;
-
-	} else /* For SIM*/
-	if (wpa_uim[sim_num].card_info[wpa_uim[sim_num].card_ready_idx].app_type ==
-		UIM_APP_TYPE_SIM_V01) {
-		qmi_read_trans_req.file_id.path[0] = 0x00;
-		qmi_read_trans_req.file_id.path[1] = 0x3F;
-		qmi_read_trans_req.file_id.path[2] = 0x20;
-		qmi_read_trans_req.file_id.path[3] = 0x7F;
-	}
-	else {
-		return FALSE;
-	}
-
-	qmi_err_code = qmi_client_send_msg_sync(wpa_uim[sim_num].qmi_uim_svc_client_ptr,
-					QMI_UIM_READ_TRANSPARENT_REQ_V01,
-					(void *)&qmi_read_trans_req,
-					sizeof(uim_read_transparent_req_msg_v01),
-					(void *) &read_trans_resp,
-					sizeof(uim_read_transparent_resp_msg_v01),
-					WPA_UIM_QMI_DEFAULT_TIMEOUT);
-	if (QMI_NO_ERR != qmi_err_code ||
-	    read_trans_resp.resp.result != QMI_RESULT_SUCCESS_V01) {
-		wpa_printf(MSG_ERROR, "QMI-ERROR Unable to read IMSI from UIM service;"
-                           " error_ret=%d; qmi_err=%d\n", qmi_err_code,
-			   read_trans_resp.resp.error);
-		qmi_status = FALSE;
-        }
-
-	if (QMI_NO_ERR == qmi_err_code) {
-		if (read_trans_resp.read_result_valid) {
-			length  =
-				read_trans_resp.read_result.content_len;
-			data    =
-				read_trans_resp.read_result.content;
-				wpa_printf(MSG_ERROR,
-					"eap_proxy: IMSI SIM content length = %d\n",
-					length);
-
-			/* Received IMSI is in the 3GPP format
-				converting it into ascii string */
-			imsi = os_zalloc(2 * length);
-			if (imsi == NULL) {
-				wpa_printf(MSG_ERROR, "eap_proxy: Couldn't allocate memmory for imsi");
-				return FALSE;
-			}
-			for (src = 1, dst = 0;
-				(src < length) && (dst < (length * 2));
-				src++) {
-				wpa_printf(MSG_ERROR,
-					"eap_proxy: IMSI read from SIM = %d src %d\n",
-					data[src], src);
-				if(data[src] == 0xFF) {
-					break;
-				}
-				if (src > 1) {
-					imsi[dst] = bin_to_hexchar(data[src] & 0x0F);
-					dst++;
-					wpa_printf(MSG_ERROR,
-					"eap_proxy: IMSI dst = %d dst %d\n",
-					imsi[dst-1], dst);
-				}
-				/* Process upper part of byte for all bytes */
-				imsi[dst] = bin_to_hexchar(data[src] >> 4);
-				dst++;
-				wpa_printf(MSG_ERROR,
-					"eap_proxy: IMSI dst = %d dst %d\n",
-					imsi[dst-1], dst);
-			}
-				imsi_len_g = (data[0]*2 - 1); //dst;
-				wpa_printf(MSG_ERROR,
-					"eap_proxy: IMSI first digit = %d read length = %d imsi %20s\n",
-					data[0],imsi_len_g, imsi);
-			} else{
-				wpa_printf(MSG_ERROR,
-					"eap_proxy: IMSI read failure read_result_valid = %d\n",
-					read_trans_resp.read_result_valid);
-				qmi_status = FALSE;
-			}
-		}
-	/* READ EF_AD */
-	/* if qmi_status is FALSE, UIM read for mnc may not be required - To Do */
-	qmi_read_trans_req.file_id.file_id = 0x6FAD;
-	qmi_err_code = qmi_client_send_msg_sync(wpa_uim[sim_num].qmi_uim_svc_client_ptr,
-					QMI_UIM_READ_TRANSPARENT_REQ_V01,
-					(void *)&qmi_read_trans_req,
-					sizeof(uim_read_transparent_req_msg_v01),
-					(void *)&read_trans_resp,
-					sizeof(uim_read_transparent_resp_msg_v01),
-					WPA_UIM_QMI_DEFAULT_TIMEOUT);
-	if (QMI_NO_ERR != qmi_err_code ||
-	   read_trans_resp.resp.result != QMI_RESULT_SUCCESS_V01) {
-		wpa_printf(MSG_ERROR, "QMI-ERROR Unable to read MNC from UIM service;"
-                           " error_ret=%d; qmi_err=%d\n", qmi_err_code,
-			   read_trans_resp.resp.error);
-		qmi_status = FALSE;
-        }
-	if (QMI_NO_ERR == qmi_err_code) {
-		if (read_trans_resp.read_result_valid) {
-			length  =
-				read_trans_resp.read_result.content_len;
-			data    =
-				read_trans_resp.read_result.content;
-
-			if(length >= 4)
-				card_mnc_len = 0x0f & data[3];
-			if ((card_mnc_len != 2) && (card_mnc_len != 3)) {
-				if(check_for_3_digit())
-					card_mnc_len = 3;
-				else
-					card_mnc_len = 2;
-				wpa_printf(MSG_ERROR, "Failed to get MNC length from (U)SIM "
-				"assuming %d as mcc %s to 3 digit mnc group\n", card_mnc_len, card_mnc_len == 3? "belongs":"not belongs");
-			}
-		}
-	}
-
-
-	return qmi_status;
-} /* wpa_qmi_read_card_imsi */
-#endif /* SIM_AKA_IDENTITY_IMSI */
-
-#ifdef CONFIG_EAP_PROXY_MDM_DETECT
-static int eap_modem_compatible(struct dev_info *mdm_detect_info)
-{
-	char args[EAP_PROXY_PROPERTY_BASEBAND_SIZE] = {0};
-	int ret = 0;
-
-	/* Get the hardware property */
-	ret = property_get(EAP_PROXY_PROPERTY_BASEBAND, args, "");
-	if (ret > EAP_PROXY_PROPERTY_BASEBAND_SIZE){
-		wpa_printf(MSG_ERROR,"eap_proxy: property [%s] has size [%d] that exceeds max [%d]",
-			   EAP_PROXY_PROPERTY_BASEBAND,
-			   ret,
-			   EAP_PROXY_PROPERTY_BASEBAND_SIZE);
-		return FALSE;
-	}
-
-	/* This will check for the type of hardware, and if the hardware type
-	 * needs external modem, it will check if the modem type is external */
-	if(!os_strncmp(EAP_PROXY_BASEBAND_VALUE_APQ, args, 3)) {
-		for (ret = 0; ret < mdm_detect_info->num_modems; ret++) {
-			if (mdm_detect_info->mdm_list[ret].type == MDM_TYPE_EXTERNAL) {
-				wpa_printf(MSG_INFO, "eap_proxy: hardware supports external modem");
-				return TRUE;
-			}
-		}
-		wpa_printf(MSG_ERROR, "eap_proxy: hardware does not support external modem");
-		return FALSE;
-	}
-	return TRUE;
-}
-#endif /* CONFIG_EAP_PROXY_MDM_DETECT */
-
-static void exit_proxy_init(int signum)
-{
-       pthread_exit(NULL);
-}
-
-static void eap_proxy_post_init(struct eap_proxy_sm *eap_proxy)
-{
-	int qmiErrorCode;
-	int qmiRetCode;
-	qmi_idl_service_object_type qmi_client_service_obj[MAX_NO_OF_SIM_SUPPORTED];
-	int index;
-	static Boolean flag = FALSE;
-	struct sigaction    actions;
-	int ret = 0;
-	wpa_uim_struct_type *wpa_uim = eap_proxy->wpa_uim;
-#ifdef CONFIG_EAP_PROXY_MDM_DETECT
-	struct dev_info mdm_detect_info;
-
-	/* Call ESOC API to get the number of modems.
-	 * If the number of modems is not zero, only then proceed
-	 * with the eap_proxy intialization.
-	 */
-	ret = get_system_info(&mdm_detect_info);
-	if (ret > 0)
-		wpa_printf(MSG_ERROR, "eap_proxy: Failed to get system info, ret %d", ret);
-
-	if (mdm_detect_info.num_modems == 0) {
-		eap_proxy->proxy_state = EAP_PROXY_DISABLED;
-		wpa_printf(MSG_ERROR, "eap_proxy: No Modem support for this target"
-			   " number of modems is %d", mdm_detect_info.num_modems);
-		return;
-	}
-	wpa_printf(MSG_DEBUG, "eap_proxy: num_modems = %d", mdm_detect_info.num_modems);
-
-	if(eap_modem_compatible(&mdm_detect_info) == FALSE) {
-		eap_proxy->proxy_state = EAP_PROXY_DISABLED;
-		wpa_printf(MSG_ERROR, "eap_proxy: build does not support EAP-SIM feature");
-		return;
-	}
-#endif /* CONFIG_EAP_PROXY_MDM_DETECT */
-
-        sigemptyset(&actions.sa_mask);
-        actions.sa_flags = 0;
-        actions.sa_handler = exit_proxy_init;
-        ret = sigaction(SIGUSR1,&actions,NULL);
-	if(ret < 0)
-		wpa_printf(MSG_DEBUG, "sigaction\n");
-	eap_proxy->proxy_state = EAP_PROXY_INITIALIZE;
-	eap_proxy->qmi_state = QMI_STATE_IDLE;
-	eap_proxy->key = NULL;
-	eap_proxy->iskey_valid = FALSE;
-	eap_proxy->is_state_changed = FALSE;
-	eap_proxy->isEap = FALSE;
-	eap_proxy->eap_type = EAP_TYPE_NONE;
-	eap_proxy->user_selected_sim = 0;
-
-#ifdef CONFIG_EAP_PROXY_DUAL_SIM
-	wpa_printf (MSG_ERROR, "eap_proxy: eap_proxy Initializing for DUAL SIM build %d tid %d", MAX_NO_OF_SIM_SUPPORTED, gettid());
-#else
-	wpa_printf (MSG_ERROR, "eap_proxy: eap_proxy Initializing for Single SIM build %d tid %d", MAX_NO_OF_SIM_SUPPORTED, gettid());
-#endif
-
-
-	for (index = 0; index < MAX_NO_OF_SIM_SUPPORTED; ++index) {
-
-#ifdef SIM_AKA_IDENTITY_IMSI
-                if (FALSE == eap_proxy->qmi_uim_svc_client_initialized[index])  {
-                        qmi_client_os_params eap_os_params;
-                        /* Init QMI_UIM service for EAP-SIM/AKA */
-                        os_memset(&eap_os_params, 0, sizeof(qmi_client_os_params));
-
-                        qmiErrorCode = qmi_client_init_instance(uim_get_service_object_v01(),
-                                                                (unsigned int)QMI_CLIENT_INSTANCE_ANY,
-                                                                wpa_qmi_client_indication_cb,
-                                                                eap_proxy, &eap_os_params,
-                                                                10000,
-                                                                &wpa_uim[index].qmi_uim_svc_client_ptr);
-
-                        if ((wpa_uim[index].qmi_uim_svc_client_ptr == NULL) || (qmiErrorCode > 0)) {
-                                wpa_printf(MSG_ERROR, "eap_proxy: Could not register with QMI UIM Service,"
-                                                "qmi_uim_svc_client_ptr: %p,qmi_err_code: %d\n",
-                                                wpa_uim[index].qmi_uim_svc_client_ptr, qmiErrorCode);
-                                wpa_uim[index].qmi_uim_svc_client_ptr = NULL;
-                                flag = FALSE;
-                                continue;
-                        }
-                        eap_proxy->qmi_uim_svc_client_initialized[index] = TRUE;
-
-                        wpa_printf (MSG_ERROR, "eap_proxy: QMI uim service client initialized with success tid is %d %p %d\n", gettid(),
-                                    wpa_uim[index].qmi_uim_svc_client_ptr, qmiErrorCode);
-                        /* Register the card events with the QMI / UIM */
-                        wpa_qmi_register_events(index, wpa_uim);
-		} else
-			wpa_printf (MSG_ERROR, "eap_proxy: QMI uim service client is already initialized tid is %d \n", gettid());
-
-
-		qmi_client_os_params eap_os_params;
-		os_memset(&eap_os_params, 0, sizeof(qmi_client_os_params));
-
-		qmiErrorCode = qmi_client_init_instance(auth_get_service_object_v01(),
-							QMI_CLIENT_INSTANCE_ANY,
-							handle_qmi_eap_ind,
-							eap_proxy,
-							&eap_os_params,
-							10000,
-							&eap_proxy->qmi_auth_svc_client_ptr[index]);
-
-
-		if ((eap_proxy->qmi_auth_svc_client_ptr[index] == NULL) || (qmiErrorCode > 0)) {
-			wpa_printf(MSG_ERROR, "eap_proxy: Could not register with QMI auth Service,"
-					"qmi_auth_svc_client_ptr: %p,qmi_err_code: %d\n",
-					eap_proxy->qmi_auth_svc_client_ptr[index], qmiErrorCode);
-			eap_proxy->qmi_auth_svc_client_ptr[index] = NULL;
-			flag = FALSE;
-			continue;
-		}
-		wpa_printf (MSG_ERROR, "eap_proxy: QMI auth service client initialized with success tid is %d  %p eapol_proxy=%p\n", gettid(),
-				eap_proxy->qmi_auth_svc_client_ptr[index], eap_proxy);
-		flag = TRUE;
-
-#endif /* SIM_AKA_IDENTITY_IMSI */
-	}
-
-	if ( flag == FALSE ) {
-		eap_proxy->proxy_state = EAP_PROXY_DISABLED;
-		wpa_printf(MSG_ERROR, "eap_proxy: flag = %d proxy init failed\n", flag);
-		return;
-	}
-
-	eap_proxy->proxy_state = EAP_PROXY_IDLE;
-	eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapSuccess, FALSE);
-	eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapFail, FALSE);
-	eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapRestart, FALSE);
-	eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapResp, FALSE);
-	eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapNoResp, FALSE);
-	wpa_printf (MSG_ERROR, "eap_proxy: Eap_proxy initialized successfully tid is %d \n", gettid());
-	return;
-
-}
-
-int eap_auth_end_eap_session(qmi_client_type qmi_auth_svc_client_ptr)
-{
-	qmi_client_error_type qmiRetCode = 0;
-	auth_end_eap_session_resp_msg_v01 end_eap_session_resp_msg ;
-
-	wpa_printf(MSG_ERROR, "eap_proxy: eap_auth_end_eap_session: Ending EAP auth session");
-
-
-/* Send QMI_AUTH_END_EAP_SESSION_REQ */
-
-	os_memset(&end_eap_session_resp_msg,
-			0,
-			sizeof(auth_end_eap_session_resp_msg_v01));
-
-	qmiRetCode = qmi_client_send_msg_sync(qmi_auth_svc_client_ptr,
-					      QMI_AUTH_END_EAP_SESSION_REQ_V01,
-					      NULL,
-					      0,
-					      (void *) &end_eap_session_resp_msg,
-					      sizeof(auth_end_eap_session_resp_msg_v01),
-					      WPA_UIM_QMI_DEFAULT_TIMEOUT);
-
-	if (QMI_NO_ERR != qmiRetCode ||
-	    end_eap_session_resp_msg.resp.result != QMI_RESULT_SUCCESS_V01) {
-		wpa_printf(MSG_ERROR, "QMI-ERROR Unable to End the EAP session;"
-				" error_ret=%d; qmi_err=%d\n", qmiRetCode,
-				end_eap_session_resp_msg.resp.error);
-		return -1;
-	}
-
-	wpa_printf(MSG_ERROR, "eap_proxy: eap_auth_end_eap_session: EAP auth session ended successfuly");
-
-	return 0;
-}
-
-static void eap_proxy_schedule_thread(void *eloop_ctx, void *timeout_ctx)
-{
-        struct eap_proxy_sm *eap_proxy = eloop_ctx;
-        pthread_attr_t attr;
-        int ret = -1;
-
-        pthread_attr_init(&attr);
-        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-        ret = pthread_create(&eap_proxy->thread_id, &attr, eap_proxy_post_init, eap_proxy);
-        if(ret < 0)
-               wpa_printf(MSG_ERROR, "eap_proxy: starting thread is failed %d\n", ret);
-}
-
-
-struct eap_proxy_sm *
-eap_proxy_init(void *eapol_ctx, struct eapol_callbacks *eapol_cb,
-	       void *msg_ctx)
-{
-	int qmiErrorCode;
-	int qmiRetCode;
-	struct eap_proxy_sm *eap_proxy;
-	qmi_idl_service_object_type    qmi_client_service_obj;
-
-	eap_proxy =  os_malloc(sizeof(struct eap_proxy_sm));
-	if (NULL == eap_proxy) {
-		wpa_printf(MSG_ERROR, "eap_proxy: Error memory alloc  for eap_proxy"
-						"eap_proxy_init\n");
-		return NULL;
-	}
-	os_memset(eap_proxy, 0, sizeof(*eap_proxy));
-
-	eap_proxy->ctx = eapol_ctx;
-	eap_proxy->eapol_cb = eapol_cb;
-	eap_proxy->msg_ctx = msg_ctx;
-	eap_proxy->proxy_state = EAP_PROXY_DISABLED;
-	eap_proxy->qmi_state = QMI_STATE_IDLE;
-	eap_proxy->key = NULL;
-	eap_proxy->iskey_valid = FALSE;
-	eap_proxy->is_state_changed = FALSE;
-	eap_proxy->isEap = FALSE;
-	eap_proxy->eap_type = EAP_TYPE_NONE;
-
-	/* delay the qmi client initialization after the eloop_run starts,
-	* in order to avoid the case of daemonize enabled, which exits the
-	* parent process that created the qmi client context.
-	*/
-
-	eloop_register_timeout(0, 0, eap_proxy_schedule_thread, eap_proxy, NULL);
-	return eap_proxy;
-}
-
-
-void eap_proxy_deinit(struct eap_proxy_sm *eap_proxy)
-{
-	int qmiRetCode;
-	int qmiErrorCode;
-	int index;
-	wpa_uim_struct_type *wpa_uim = eap_proxy->wpa_uim;
-
-	if (NULL == eap_proxy)
-		return;
-
-	pthread_kill(eap_proxy->thread_id, SIGUSR1);
-	eap_proxy->proxy_state = EAP_PROXY_DISABLED;
-
-	for (index = 0; index < MAX_NO_OF_SIM_SUPPORTED; ++index) {
-		if (TRUE == eap_proxy->eap_auth_session_flag[index]) {
-
-			/* end the current EAP session */
-			if(eap_auth_end_eap_session(eap_proxy->qmi_auth_svc_client_ptr[index]) < 0 ){
-				wpa_printf(MSG_ERROR, "eap_proxy: Unable to end the EAP session for "
-						"client %d",
-						index+1);
-			} else {
-				wpa_printf(MSG_ERROR, "eap_proxy: Ended the QMI EAP session for "
-						"client %d\n",
-						index+1);
-				eap_proxy->eap_auth_session_flag[index] = FALSE;
-			}
-		} else {
-			wpa_printf (MSG_ERROR, "eap_proxy: session not started for client = %d\n", index+1);
-			continue;
-		}
-
-		if ((TRUE == eap_proxy->qmi_uim_svc_client_initialized[index]))  {
-			qmiRetCode = qmi_client_release(wpa_uim[index].qmi_uim_svc_client_ptr);
-			if (QMI_NO_ERR != qmiRetCode) {
-				wpa_printf (MSG_ERROR, "eap_proxy: Unable to Releas the connection"
-						" to uim service for client=%d; error_ret=%d\n;",
-						index+1, qmiRetCode);
-			}
-			wpa_printf(MSG_ERROR, "eap_proxy: Released QMI UIM service client\n");
-			eap_proxy->qmi_uim_svc_client_initialized[index] = FALSE;
-		}
-
-		qmiRetCode = qmi_client_release(eap_proxy->qmi_auth_svc_client_ptr[index]);
-		if (QMI_NO_ERR != qmiRetCode) {
-			wpa_printf (MSG_ERROR, "eap_proxy: Unable to Releas the connection"
-					" to auth service for client=%d; error_ret=%d\n;",
-					index+1, qmiRetCode);
-		}  else {
-			wpa_printf(MSG_ERROR, "eap_proxy: Released QMI EAP service client\n");
-		}
-
-	}
-
-	if (NULL != eap_proxy->key) {
-		os_free(eap_proxy->key);
-		eap_proxy->key = NULL;
-	}
-
-	eap_proxy->iskey_valid = FALSE;
-	eap_proxy->is_state_changed = FALSE;
-        eap_proxy->user_selected_sim = 0;
-
-	os_free(eap_proxy);
-	eap_proxy = NULL;
-	wpa_printf(MSG_INFO, "eap_proxy: eap_proxy Deinitialzed\n");
-}
-
-/* Call-back function to process an authentication result indication
-*  from QMI EAP service */
-static void handle_qmi_eap_ind(qmi_client_type user_handle,
-			       unsigned int msg_id,
-			       void* ind_buf,
-			       unsigned int ind_buf_len,
-			       void* ind_cb_data)
-{
-	qmi_client_error_type qmi_err;
-	auth_eap_session_result_ind_msg_v01 eap_session_result;
-	memset(&eap_session_result, 0, sizeof(auth_eap_session_result_ind_msg_v01));
-	eap_session_result.eap_result = -1;
-	struct eap_proxy_sm *sm = (struct eap_proxy_sm *)ind_cb_data;
-	wpa_printf(MSG_ERROR, "eap_proxy: Handle_qmi_eap_ind msgId =%d  sm=%p\n", msg_id,sm);
-	/* Decode */
-	qmi_err = qmi_client_message_decode(user_handle, QMI_IDL_INDICATION,
-					    msg_id, (void*)ind_buf, ind_buf_len,
-					    &eap_session_result,
-					    sizeof(auth_eap_session_result_ind_msg_v01));
-	if (qmi_err != QMI_NO_ERR)
-	{
-		wpa_printf(MSG_ERROR, "eap_proxy: Error in qmi_client_message_decode;"
-				" error_code=%d \n", qmi_err);
-		sm->srvc_result = EAP_PROXY_QMI_SRVC_FAILURE;
-		return;
-	}
-
-	switch(msg_id)
-	{
-		case QMI_AUTH_EAP_SESSION_RESULT_IND_V01:
-			if ((eap_session_result.eap_result == 0) &&
-			    (QMI_STATE_RESP_TIME_OUT != sm->qmi_state)) {
-				sm->proxy_state = EAP_PROXY_AUTH_SUCCESS;
-				sm->qmi_state = QMI_STATE_RESP_RECEIVED;
-				wpa_printf(MSG_ERROR, "eap_proxy: Handle_qmi_eap_ind EAP PROXY AUTH SUCCESS %p set to %d\n",
-					   (void *)&sm->qmi_state, sm->qmi_state);
-			} else {
-				sm->proxy_state = EAP_PROXY_AUTH_FAILURE;
-				wpa_printf(MSG_ERROR, "eap_proxy: Handle_qmi_eap_ind EAP PROXY AUTH FAILURE \n");
-			}
-			sm->srvc_result = EAP_PROXY_QMI_SRVC_SUCCESS;
-			break;
-		default:
-			wpa_printf(MSG_ERROR, "eap_proxy: An unexpected msg Id=%d"
-					" is given\n", msg_id);
-			break;
-	}
-
-
-}
-
-
-/* Call-back function to process an EAP response from QMI EAP service */
-static void handle_qmi_eap_reply(
-		qmi_client_type userHandle, unsigned int msg_id,
-		void *resp_c_struct, unsigned int resp_c_struct_len,
-		void *userData, qmi_client_error_type sysErrCode)
-{
-	struct eap_proxy_sm *eap_proxy = (struct eap_proxy_sm *)userData;
-	auth_send_eap_packet_resp_msg_v01* rspData = (auth_send_eap_packet_resp_msg_v01*)resp_c_struct;
-
-	u8 *resp_data;
-	u32 length;
-
-	wpa_printf(MSG_ERROR, "eap_proxy: %s started\n", __func__);
-	if (eap_proxy == NULL) {
-		wpa_printf(MSG_ERROR, "eap_proxy: eap_proxy is NULL");
-		return;
-	}
-	if (QMI_STATE_RESP_PENDING == eap_proxy->qmi_state) {
-
-		wpa_printf(MSG_ERROR, "eap_proxy: user_selected_sim = %d\n",
-			   eap_proxy->user_selected_sim+1);
-
-
-		if (QMI_NO_ERR != sysErrCode) {
-			wpa_printf(MSG_ERROR, "eap_proxy: An error is encountered with"
-					" the request: sysErrorCode=%d\n",
-					sysErrCode);
-			eap_proxy->qmi_state = QMI_STATE_RESP_TIME_OUT;
-			return;
-		}
-
-		if (NULL == rspData) {
-			wpa_printf(MSG_ERROR, "eap_proxy: Response data is NULL\n");
-			eap_proxy->qmi_state = QMI_STATE_RESP_TIME_OUT;
-			return;
-		}
-#ifdef QMI_AUTH_EAP_REQ_PACKET_EXT_MAX_V01
-		if((QMI_AUTH_SEND_EAP_PACKET_REQ_V01 != msg_id) &&
-		   (QMI_AUTH_SEND_EAP_PACKET_EXT_REQ_V01 != msg_id))
-		{
-			wpa_printf(MSG_ERROR, "eap_proxy: Invalid msgId =%d\n", msg_id);
-			eap_proxy->qmi_state = QMI_STATE_RESP_TIME_OUT;
-			return;
-		}
-#else
-		if(QMI_AUTH_SEND_EAP_PACKET_REQ_V01 != msg_id)
-		{
-			wpa_printf(MSG_ERROR, "eap_proxy: Invalid msgId =%d\n", msg_id);
-			eap_proxy->qmi_state = QMI_STATE_RESP_TIME_OUT;
-			return;
-		}
-#endif
-
-		/* ensure the reply packet exists  */
-		if (rspData->eap_response_pkt_len <= 0
-#ifdef QMI_AUTH_EAP_REQ_PACKET_EXT_MAX_V01
-		    || rspData->eap_response_pkt_len > QMI_AUTH_EAP_RESP_PACKET_EXT_MAX_V01
-#endif
-            ) {
-			wpa_printf(MSG_ERROR, "eap_proxy: Reply packet is of"
-				"invalid length %d error %d result %d\n",
-				rspData->eap_response_pkt_len, rspData->resp.error, rspData->resp.result);
-			eap_proxy->qmi_state = QMI_STATE_RESP_TIME_OUT;
-			return;
-		}
-
-		length = rspData->eap_response_pkt_len;
-		eap_proxy->qmi_resp_data.eap_send_pkt_resp.length = length;
-		/* allocate a buffer to store the response data; size is EAP resp len field */
-		eap_proxy->qmi_resp_data.eap_send_pkt_resp.resp_data =
-			os_malloc(rspData->eap_response_pkt_len);
-
-		resp_data =
-			(u8 *)eap_proxy->qmi_resp_data.eap_send_pkt_resp.resp_data;
-
-		if (NULL == resp_data) {
-			wpa_printf(MSG_ERROR, "eap_proxy: Unable to allocate memory for"
-					" reply packet\n");
-			eap_proxy->qmi_state = QMI_STATE_RESP_TIME_OUT;
-
-			return;
-		}
-
-		/* copy the response data to the allocated buffer */
-		os_memcpy(resp_data,
-				rspData->eap_response_pkt, length);
-		eap_proxy->qmi_state = QMI_STATE_RESP_RECEIVED;
-		wpa_printf(MSG_ERROR, "eap_proxy: **HANDLE_QMI_EAP_REPLY CALLBACK ENDDED **");
-
-		wpa_printf(MSG_ERROR, "eap_proxy: Dump Resp Data len %d\n", length);
-		dump_buff(resp_data, length);
-	}
-
-	return;
-}
-
-static enum eap_proxy_status eap_proxy_process(struct eap_proxy_sm  *eap_proxy,
-					u8 *eapReqData, int eapReqDataLen, struct eap_sm *eap_sm)
-{
-	struct eap_hdr *hdr;
-	int qmiErrorCode = 0;
-	enum eap_proxy_status proxy_status = EAP_PROXY_SUCCESS;
-	auth_send_eap_packet_req_msg_v01 eap_send_packet_req;
-	auth_send_eap_packet_resp_msg_v01 eap_send_packet_resp;
-	qmi_txn_handle async_txn_hdl = 0;
-
-#ifdef QMI_AUTH_EAP_REQ_PACKET_EXT_MAX_V01
-	auth_send_eap_packet_ext_req_msg_v01 eap_send_packet_ext_req;
-	auth_send_eap_packet_ext_resp_msg_v01 eap_send_packet_ext_resp;
-#endif
-
-	hdr = (struct eap_hdr *)eapReqData;
-	if ((EAP_CODE_REQUEST == hdr->code) &&
-	    (EAP_TYPE_IDENTITY == eapReqData[4])) {
-		if (eap_proxy_eapol_sm_get_bool(eap_proxy, EAPOL_eapRestart) &&
-		    eap_proxy_eapol_sm_get_bool(eap_proxy, EAPOL_portEnabled)) {
-			wpa_printf (MSG_ERROR, "eap_proxy: Already Authenticated."
-				    " Clear all the flags");
-			eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapSuccess, FALSE);
-			eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapFail, FALSE);
-			eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapResp, FALSE);
-			eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapNoResp, FALSE);
-			if (eap_proxy->key) {
-                                os_free(eap_proxy->key);
-                                eap_proxy->key = NULL;
-                        }
-                        eap_proxy->iskey_valid = FALSE;
-                        eap_proxy->is_state_changed = TRUE;
-		}
-		eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapRestart, FALSE);
-
-		if(eap_proxy_build_identity(eap_proxy, hdr->identifier, eap_sm)) {
-			eap_proxy->proxy_state = EAP_PROXY_IDENTITY;
-		} else {
-			wpa_printf(MSG_ERROR, "eap_proxy: Error in build identity\n");
-			return EAP_PROXY_FAILURE;
-		}
-	}
-	wpa_printf(MSG_ERROR, "eap_proxy: ***********Dump ReqData len %d***********", eapReqDataLen);
-	dump_buff(eapReqData, eapReqDataLen);
-	if (eapReqDataLen <= QMI_AUTH_EAP_REQ_PACKET_MAX_V01) {
-		os_memset(&eap_send_packet_req, 0, sizeof(auth_send_eap_packet_req_msg_v01));
-		os_memset(&eap_send_packet_resp, 0, sizeof(auth_send_eap_packet_resp_msg_v01));
-		eap_send_packet_req.eap_request_pkt_len = eapReqDataLen ;
-		memcpy(eap_send_packet_req.eap_request_pkt, eapReqData, eapReqDataLen);
-#ifdef QMI_AUTH_EAP_REQ_PACKET_EXT_MAX_V01
-	} else if (eapReqDataLen <= QMI_AUTH_EAP_REQ_PACKET_EXT_MAX_V01) {
-		os_memset(&eap_send_packet_ext_req, 0, sizeof(auth_send_eap_packet_ext_req_msg_v01));
-		os_memset(&eap_send_packet_ext_resp, 0, sizeof(auth_send_eap_packet_ext_resp_msg_v01));
-		eap_send_packet_ext_req.eap_request_ext_pkt_len = eapReqDataLen;
-		memcpy(eap_send_packet_ext_req.eap_request_ext_pkt, eapReqData, eapReqDataLen);
-#endif
-	} else {
-			wpa_printf(MSG_ERROR, "eap_proxy: Error in eap_send_packet_req\n");
-			return EAP_PROXY_FAILURE;
-	}
-
-	wpa_printf(MSG_ERROR, "eap_proxy: SIM selected by User: Selected sim = %d\n", eap_proxy->user_selected_sim+1);
-	if (eap_proxy->qmi_state != QMI_STATE_IDLE) {
-		wpa_printf(MSG_ERROR, "Error in QMI state=%d\n",
-					 eap_proxy->qmi_state);
-		return EAP_PROXY_FAILURE;
-	}
-
-	wpa_printf (MSG_ERROR, "eap_proxy: In eap_proxy_process case %d\n", hdr->code);
-	eap_proxy->qmi_state = QMI_STATE_RESP_PENDING;
-
-	if(eapReqDataLen <= QMI_AUTH_EAP_REQ_PACKET_MAX_V01) {
-		qmiErrorCode = qmi_client_send_msg_async(
-				eap_proxy->qmi_auth_svc_client_ptr[eap_proxy->user_selected_sim],
-				QMI_AUTH_SEND_EAP_PACKET_REQ_V01,
-				(void *) &eap_send_packet_req,
-				sizeof(auth_send_eap_packet_req_msg_v01),
-				(void *) &eap_send_packet_resp,
-				sizeof(auth_send_eap_packet_resp_msg_v01),
-				&handle_qmi_eap_reply, eap_proxy,
-				&async_txn_hdl);
-#ifdef QMI_AUTH_EAP_REQ_PACKET_EXT_MAX_V01
-	} else if(eapReqDataLen <= QMI_AUTH_EAP_REQ_PACKET_EXT_MAX_V01) {
-		qmiErrorCode = qmi_client_send_msg_async(
-				eap_proxy->qmi_auth_svc_client_ptr[eap_proxy->user_selected_sim],
-				QMI_AUTH_SEND_EAP_PACKET_EXT_REQ_V01,
-				(void *) &eap_send_packet_ext_req,
-				sizeof(auth_send_eap_packet_ext_req_msg_v01),
-				(void *) &eap_send_packet_ext_resp,
-				sizeof(auth_send_eap_packet_ext_resp_msg_v01),
-				&handle_qmi_eap_reply, eap_proxy,
-				&async_txn_hdl);
-#endif
-	}
-
-	if (QMI_NO_ERR != qmiErrorCode) {
-		wpa_printf(MSG_ERROR, "QMI-ERROR Error in sending EAP packet;"
-				" error_code=%d\n", qmiErrorCode);
-		eap_proxy->proxy_state = EAP_PROXY_DISCARD;
-		eap_proxy_eapol_sm_set_bool(eap_proxy, EAPOL_eapNoResp, TRUE);
-		eap_proxy->qmi_state = QMI_STATE_RESP_PENDING;
-		return EAP_PROXY_FAILURE;
-	} else {
-		wpa_printf (MSG_ERROR, "eap_proxy: In eap_proxy_process case %d\n", hdr->code);
-		switch (hdr->code) {
-		case EAP_CODE_SUCCESS:
-			if (EAP_PROXY_SUCCESS !=
-				eap_proxy_qmi_response_wait(eap_proxy)) {
-				eap_proxy->proxy_state = EAP_PROXY_DISCARD;
-				eap_proxy_eapol_sm_set_bool(eap_proxy,
-							EAPOL_eapNoResp, TRUE);
-				return EAP_PROXY_FAILURE;
-			} else if( eap_proxy->proxy_state == EAP_PROXY_AUTH_SUCCESS ) {
-				eap_proxy_getKey(eap_proxy);
-				eap_proxy_eapol_sm_set_bool(eap_proxy,
-						 EAPOL_eapSuccess, TRUE);
-	/*
-	 * RFC 4137 does not clear eapReq here, but this seems to be required
-	 * to avoid processing the same request twice when state machine is
-	 * initialized.
-	 */
-			eap_proxy_eapol_sm_set_bool(eap_proxy,
-							EAPOL_eapReq, FALSE);
-
-	/*
-	 * RFC 4137 does not set eapNoResp here, but this seems to be required
-	 * to get EAPOL Supplicant backend state machine into SUCCESS state. In
-	 * addition, either eapResp or eapNoResp is required to be set after
-	 * processing the received EAP frame.
-	 */
-			eap_proxy_eapol_sm_set_bool(eap_proxy,
-						EAPOL_eapNoResp, TRUE);
-
-			wpa_msg(eap_proxy->msg_ctx, MSG_INFO, WPA_EVENT_EAP_SUCCESS
-				"eap_proxy: EAP authentication completed successfully");
-
-			eap_proxy->is_state_changed = TRUE;
-
-				/* Retrieve the keys  and store*/
-			} else if( eap_proxy->proxy_state == EAP_PROXY_AUTH_FAILURE ){
-
-				eap_proxy_eapol_sm_set_bool(eap_proxy,
-						EAPOL_eapFail, TRUE);
-				eap_proxy_eapol_sm_set_bool(eap_proxy,
-						EAPOL_eapReq, FALSE);
-				eap_proxy_eapol_sm_set_bool(eap_proxy,
-						EAPOL_eapNoResp, TRUE);
-				eap_proxy->is_state_changed = TRUE;
-
-			}
-
-			break;
-
-		case EAP_CODE_FAILURE:
-			wpa_printf (MSG_ERROR, "eap_proxy: in eap_proxy_process case EAP_CODE_FAILURE\n");
-			eap_proxy->proxy_state = EAP_PROXY_AUTH_FAILURE;
-			eap_proxy_eapol_sm_set_bool(eap_proxy,
-						EAPOL_eapFail, TRUE);
-
-	/*
-	 * RFC 4137 does not clear eapReq here, but this seems to be required
-	 * to avoid processing the same request twice when state machine is
-	 * initialized.
-	*/
-			eap_proxy_eapol_sm_set_bool(eap_proxy,
-						EAPOL_eapReq, FALSE);
-
-	/*
-	 * RFC 4137 does not set eapNoResp here. However, either eapResp or
-	 * eapNoResp is required to be set after processing the received EAP
-	 * frame.
-	 */
-			eap_proxy_eapol_sm_set_bool(eap_proxy,
-						EAPOL_eapNoResp, TRUE);
-
-			wpa_msg(eap_proxy->msg_ctx, MSG_INFO, WPA_EVENT_EAP_FAILURE
-				"EAP authentication failed");
-
-			eap_proxy->is_state_changed = TRUE;
-			break;
-
-		case EAP_CODE_REQUEST:
-					eap_proxy->proxy_state = EAP_PROXY_SEND_RESPONSE;
-			if (EAP_PROXY_SUCCESS !=
-				eap_proxy_qmi_response_wait(eap_proxy)) {
-				eap_proxy->proxy_state = EAP_PROXY_DISCARD;
-				eap_proxy_eapol_sm_set_bool(eap_proxy,
-							EAPOL_eapNoResp, TRUE);
-				return EAP_PROXY_FAILURE;
-			} else {
-				eap_proxy_eapol_sm_set_bool(eap_proxy,
-							EAPOL_eapResp, TRUE);
-				eap_proxy->proxy_state =
-						EAP_PROXY_SEND_RESPONSE;
-			}
-
-			eap_proxy_eapol_sm_set_bool(eap_proxy,
-						EAPOL_eapReq, FALSE);
-			eap_proxy->is_state_changed = TRUE;
-			break;
-
-		default:
-			wpa_printf(MSG_ERROR, "eap_proxy: Error in sending EAP packet;"
-					 " error_code=%d\n", qmiErrorCode);
-			eap_proxy->proxy_state = EAP_PROXY_DISCARD;
-			eap_proxy_eapol_sm_set_bool(eap_proxy,
-				EAPOL_eapNoResp, TRUE);
-			return EAP_PROXY_FAILURE;
-		}
-	}
-
-	return EAP_PROXY_SUCCESS;
-}
-
-
-
-static u8 *eap_proxy_getKey(struct eap_proxy_sm *eap_proxy)
-{
-	int qmiErrorCode;
-	int qmiRetCode;
-
-	auth_get_eap_session_keys_resp_msg_v01 key_resp_msg;
-	os_memset(&key_resp_msg, 0, sizeof(auth_get_eap_session_keys_resp_msg_v01));
-
-	qmiRetCode = qmi_client_send_msg_sync(eap_proxy->qmi_auth_svc_client_ptr[eap_proxy->user_selected_sim],
-			QMI_AUTH_GET_EAP_SESSION_KEYS_REQ_V01,
-			NULL,
-			0,
-			(void *) &key_resp_msg,
-			sizeof(auth_get_eap_session_keys_resp_msg_v01),
-			WPA_UIM_QMI_DEFAULT_TIMEOUT);
-
-
-	/* see if the MSK is acquired successfully */
-	if (QMI_NO_ERR != qmiRetCode || key_resp_msg.resp.result != QMI_RESULT_SUCCESS_V01) {
-		wpa_printf(MSG_ERROR, "QMI-ERROR Unable to get session keys;"
-				 " err_code=%d qmiErr=%d\n", qmiRetCode, key_resp_msg.resp.error);
-		eap_proxy->key = NULL;
-		return NULL;
-	}
-	wpa_printf(MSG_ERROR, "eap_proxy: %s:session_key_len =%d", __func__, key_resp_msg.session_key_len);
-
-	if(key_resp_msg.session_key_len <=0 || key_resp_msg.session_key_len > EAP_PROXY_KEYING_DATA_LEN)
-	{
-		return NULL;
-
-	}
-	eap_proxy->key = os_malloc(EAP_PROXY_KEYING_DATA_LEN);
-	if(eap_proxy->key == NULL)
-		return NULL;
-
-	memset(eap_proxy->key, 0, EAP_PROXY_KEYING_DATA_LEN);
-	memcpy(eap_proxy->key, key_resp_msg.session_key, key_resp_msg.session_key_len);
-
-	eap_proxy->iskey_valid = TRUE;
-	eap_proxy->proxy_state = EAP_PROXY_AUTH_SUCCESS;
-
-	wpa_printf(MSG_ERROR, "eap_proxy: eap_proxy_getkey EAP KEYS ");
-	dump_buff(eap_proxy->key, EAP_PROXY_KEYING_DATA_LEN);
-	return eap_proxy->key;
-}
-
-
-/**
- * eap_key_available - Get key availability (eapKeyAvailable variable)
- * @sm: Pointer to EAP state machine allocated with eap_sm_init()
- * Returns: 1 if EAP keying material is available, 0 if not
- */
-int eap_proxy_key_available(struct eap_proxy_sm *sm)
-{
-	return sm ? sm->iskey_valid : 0;
-}
-
-
-static int eap_proxy_is_state_changed(struct eap_proxy_sm *sm)
-{
-	if (NULL == sm)
-		return 0;
-
-	if (TRUE == sm->is_state_changed) {
-		sm->is_state_changed = FALSE;
-		return 1;
-	} else {
-		return 0;
-	}
-}
-
-
-/**
- * eap_get_eapKeyData - Get master session key (MSK) from EAP state machine
- * @sm: Pointer to EAP state machine allocated with eap_sm_init()
- * @len: Pointer to variable that will be set to number of bytes in the key
- * Returns: Pointer to the EAP keying data or %NULL on failure
- *
- * Fetch EAP keying material (MSK, eapKeyData) from the EAP state machine. The
- * key is available only after a successful authentication. EAP state machine
- * continues to manage the key data and the caller must not change or free the
- * returned data.
- */
-const u8 * eap_proxy_get_eapKeyData(struct eap_proxy_sm *sm, size_t *len)
-{
-	if (sm == NULL || sm->key == NULL) {
-		*len = 0;
-		return NULL;
-	}
-
-	*len = EAP_PROXY_KEYING_DATA_LEN;
-	return sm->key;
-}
-
-/**
- * eap_proxy_get_eapRespData - Get EAP response data
- * @sm: Pointer to EAP state machine allocated with eap_sm_init()
- * @len: Pointer to variable that will be set to the length of the response
- * Returns: Pointer to the EAP response (eapRespData) or %NULL on failure
- *
- * Fetch EAP response (eapRespData) from the EAP state machine. This data is
- * available when EAP state machine has processed an incoming EAP request. The
- * EAP state machine does not maintain a reference to the response after this
- * function is called and the caller is responsible for freeing the data.
- */
-struct wpabuf * eap_proxy_get_eapRespData(struct eap_proxy_sm *eap_proxy)
-{
-	struct wpabuf *resp;
-	int len;
-//	int i;
-
-	wpa_printf(MSG_ERROR, "eap_proxy: eap_proxy_get_eapRespData");
-        if ( (eap_proxy == NULL) ||
-             (eap_proxy->qmi_resp_data.eap_send_pkt_resp.resp_data == NULL)
-           )
-        {
-                return NULL;
-        }
-
-        len = eap_proxy->qmi_resp_data.eap_send_pkt_resp.length;
-	wpa_printf(MSG_ERROR, "eap_proxy: eap_proxy_get_eapRespData len = %d", len);
-	resp = wpabuf_alloc(len);
-	if (resp == NULL) {
-		wpa_printf(MSG_ERROR, "eap_proxy: buf allocation failed\n");
-		return NULL;
-	}
-
-	resp->used = len;
-	os_memcpy(resp->buf, eap_proxy->qmi_resp_data.eap_send_pkt_resp.resp_data,
-		   len);
-/*
-	for (i = 0; i < len; i++) {
-		wpa_printf (MSG_ERROR, "%c", resp->buf[i]);
-	}
-*/
-	os_free(eap_proxy->qmi_resp_data.eap_send_pkt_resp.resp_data);
-        eap_proxy->qmi_resp_data.eap_send_pkt_resp.resp_data = NULL;
-        eap_proxy->qmi_resp_data.eap_send_pkt_resp.length = 0;
-
-        return resp;
-}
-
-
-static enum eap_proxy_status eap_proxy_qmi_response_wait(struct eap_proxy_sm *eap_proxy)
-{
-
-	int count = 0;
-
-	wpa_printf(MSG_DEBUG, "eap_proxy_qmi_response_wait: Start blocking "
-		   "wait eap_proxy=%p",eap_proxy);
-	do {
-		count++;
-		if (count > QMI_RESP_TIME_OUT / 2) {
-			wpa_printf(MSG_ERROR,
-				   "eap_proxy: eap_proxy_qmi_response_wait "
-				   "!QMI STATE %d TIME_OUT\n",
-				   eap_proxy->qmi_state);
-			eap_proxy->qmi_state = QMI_STATE_RESP_TIME_OUT;
-			break;
-		}
-
-		os_sleep(0, 2000);
-
-		if ((QMI_STATE_RESP_RECEIVED == eap_proxy->qmi_state) ||
-		   (QMI_STATE_RESP_TIME_OUT == eap_proxy->qmi_state))
-			break;
-	} while (1);
-
-	wpa_printf(MSG_DEBUG, "eap_proxy: eap_proxy_qmi_response_wait: Wait done after %d "
-		   "iterations: qmi_state=%d", count,
-		   eap_proxy->qmi_state);
-
-	if (QMI_STATE_RESP_TIME_OUT == eap_proxy->qmi_state) {
-		wpa_printf(MSG_ERROR, "eap_proxy: QMI state Response Time out\n");
-		eap_proxy->proxy_state = EAP_PROXY_DISCARD;
-		return EAP_PROXY_FAILURE;
-	}
-	eap_proxy->qmi_state = QMI_STATE_IDLE;
-
-	return EAP_PROXY_SUCCESS;
-}
-
-
-static void eap_proxy_eapol_sm_set_bool(struct eap_proxy_sm *sm,
-			enum eapol_bool_var var, Boolean value)
-{
-	sm->eapol_cb->set_bool(sm->ctx, var, value);
-}
-
-
-static Boolean eap_proxy_eapol_sm_get_bool(struct eap_proxy_sm *sm,
-			 enum eapol_bool_var var)
-{
-	return  sm->eapol_cb->get_bool(sm->ctx, var);
-}
-
-
-int eap_proxy_sm_step(struct eap_proxy_sm *sm, struct eap_sm *eap_sm)
-{
-	if ((sm->proxy_state != EAP_PROXY_INITIALIZE) &&
-				 (sm->proxy_state != EAP_PROXY_DISABLED)) {
-		if (TRUE == sm->isEap) {
-			if(!eap_proxy_process(sm, sm->eapReqData,
-						 sm->eapReqDataLen,eap_sm)) {
-				sm->proxy_state = EAP_PROXY_AUTH_FAILURE;
-				eap_proxy_eapol_sm_set_bool(sm, EAPOL_eapRestart, TRUE);
-			}
-			sm->isEap = FALSE;
-		}
-	}
-	return eap_proxy_is_state_changed(sm);
-}
-
-
-enum eap_proxy_status
-eap_proxy_packet_update(struct eap_proxy_sm *eap_proxy, u8 *eapReqData,
-			int eapReqDataLen)
-{
-	eap_proxy->eapReqData = eapReqData;
-	eap_proxy->eapReqDataLen = eapReqDataLen;
-	eap_proxy->isEap = TRUE;
-	return EAP_PROXY_SUCCESS;
-}
-
-
-static void dump_buff(u8 *buff, int len)
-{
-	int i ;
-
-	wpa_printf(MSG_ERROR, "eap_proxy: ---- EAP Buffer----LEN %d\n",len);
-	for (i = 0; i < len; i++) {
-		if (0 == i%8)
-			wpa_printf(MSG_DEBUG, " \n");
-		wpa_printf(MSG_ERROR, "eap_proxy: 0x%x  ", buff[i]);
-	}
-	return;
-}
-static char bin_to_hexchar(u8 ch)
-{
-	if (ch < 0x0a) {
-		return ch + '0';
-	}
-	return ch + 'a' - 10;
-}
-
-extern struct eap_peer_config * eap_get_config(struct eap_sm *sm) __attribute__((weak));
-static Boolean eap_proxy_build_identity(struct eap_proxy_sm *eap_proxy, u8 id, struct eap_sm *eap_sm)
-{
-	struct eap_hdr *resp;
-	unsigned int len;
-	u8 identity_len = 0, ret;
-	u8 imsi_id_len = 0;
-	int mnc_len = -1;
-	u8 *pos;
-	int qmiRetCode;
-	u8 idx = 0, mcc_idx = 0;
-	unsigned char *identity = NULL;
-	unsigned char *imsi_identity = NULL;
-	auth_start_eap_session_req_msg_v01 eap_auth_start;
-	auth_start_eap_session_resp_msg_v01 eap_auth_start_resp;
-	auth_set_subscription_binding_req_msg_v01 sub_req_binding;
-	auth_set_subscription_binding_resp_msg_v01 sub_resp_binding;
-
-	struct eap_method_type *m;
-	eap_identity_format_e identity_format = EAP_IDENTITY_ANNONYMOUS;
-	Boolean simEnabled = FALSE, akaEnabled = FALSE;
-	struct eap_peer_config *config = eap_get_config(eap_sm);
-	const char *realm_3gpp = "@wlan.mnc000.mcc000.3gppnetwork.org";
-	int sim_num;
-
-	wpa_printf(MSG_ERROR, "eap_proxy: %s\n", __func__);
-	sim_num = config->sim_num - 1;
-	os_memset(&eap_auth_start, 0, sizeof(eap_auth_start));
-	os_memset(&eap_auth_start_resp, 0, sizeof(eap_auth_start_resp));
-
-	eap_auth_start.user_id_len = 0;
-	m = config->eap_methods;
-
-	if (sim_num >= MAX_NO_OF_SIM_SUPPORTED || sim_num < 0) {
-		wpa_printf (MSG_ERROR, "eap_proxy: Invalid SIM selected sim by user = %d\n",
-			     sim_num+1);
-		return FALSE;
-	}
-	wpa_printf(MSG_ERROR, "eap_proxy: User selected sim = %d\n", sim_num + 1);
-
-	if (m != NULL) {
-		for (idx = 0; m[idx].vendor != EAP_VENDOR_IETF ||
-				m[idx].method != EAP_TYPE_NONE; idx++) {
-			if (m[idx].method == EAP_TYPE_AKA) {
-				akaEnabled = TRUE;
-				eap_auth_start.eap_method_mask_valid = 1;
-				eap_auth_start.eap_method_mask |= QMI_AUTH_EAP_METHOD_MASK_AKA_V01;
-				wpa_printf(MSG_ERROR, "eap_proxy: AKA Enabled\n");
-			} else if (m[idx].method == EAP_TYPE_SIM) {
-				simEnabled = TRUE;
-				eap_auth_start.eap_method_mask_valid = 1;
-				eap_auth_start.eap_method_mask |= QMI_AUTH_EAP_METHOD_MASK_SIM_V01;
-				wpa_printf(MSG_ERROR, "eap_proxy: SIM Enabled\n");
-#ifdef CONFIG_EAP_PROXY_AKA_PRIME
-			} else if (m[idx].method == EAP_TYPE_AKA_PRIME) {
-				eap_auth_start.eap_method_mask_valid = 1;
-				eap_auth_start.eap_method_mask |= QMI_AUTH_EAP_METHOD_MASK_AKA_PRIME_V01;
-				wpa_printf(MSG_ERROR, "eap_proxy: AKA Prime Enabled\n");
-#endif /* CONFIG_EAP_PROXY_AKA_PRIME */
-			}
-		}
-	} else {
-		wpa_printf(MSG_ERROR, "eap_proxy: eap_methods is NULL!\n");
-		return FALSE;
-	}
-
-	eap_auth_start.eap_method_mask_valid = 1;
-
-	idx = 0;
-#ifdef SIM_AKA_IMSI_RAW_ENABLED
-
-	identity_format = EAP_IDENTITY_IMSI_RAW;
-	eap_auth_start.user_id_valid = 1;
-	wpa_printf(MSG_ERROR, "eap_proxy: EAP_IDENTITY_IMSI_RAW selected %d \n", eap_auth_start.user_id_len);
-
-#else /* SIM_AKA_IMSI_RAW_ENABLED */
-
-	if (config->identity_len && config->identity != NULL) {
-		for (idx = 0; idx < config->identity_len; idx++) {
-			if (config->identity[idx] == 64) {
-				wpa_printf(MSG_ERROR, "eap_proxy: @ found \n");
-				mcc_idx = idx;
-				if ((mcc_idx + 18) > config->identity_len)
-					mcc_idx = 0;
-				else {
-					/* Looking for mnc and mcc pattern */
-					if (109 == config->identity[mcc_idx + 6] &&
-						(110 == config->identity[mcc_idx + 7]) &&
-						(99 == config->identity[mcc_idx + 8]) &&
-						(109 == config->identity[mcc_idx + 13]) &&
-						(99 == config->identity[mcc_idx + 14]) &&
-						(99 == config->identity[mcc_idx + 15])) {
-						mcc_idx += 9;
-					} else
-						mcc_idx = 0;
-				}
-				break;
-			}
-		}
-
-		wpa_printf(MSG_ERROR, "eap_proxy: idx %d\n", idx);
-		wpa_printf(MSG_ERROR, "eap_proxy: mcc idx %d\n", mcc_idx);
-
-		if (!idx && (config->identity_len == 1)) {
-			/* config file : @ */
-			config->identity_len = 0;
-			identity_format = EAP_IDENTITY_IMSI_3GPP_REALM;
-			wpa_printf(MSG_ERROR, "eap_proxy: EAP_IDENTITY_IMSI_3GPP_REALM selected \n");
-		} else if (idx && (idx < config->identity_len) && (config->identity != NULL)) {
-
-			/* config file : <>@<> or <>@<wlan.mnc000.mcc000.<>.<> */
-			identity_len = config->identity_len;
-			identity = os_malloc(config->identity_len);
-
-			if (NULL != identity) {
-				os_memset(identity, 0, config->identity_len);
-				os_memcpy(identity, config->identity,
-						config->identity_len);
-			}
-
-			/* To Do for 3GPP realm */
-			identity_format = EAP_IDENTITY_CFG_3GPP_REALM;
-			eap_auth_start.user_id_valid = 1;
-			wpa_printf(MSG_ERROR, "eap_proxy: EAP_IDENTITY_CFG_3GPP_REALM selected %d \n", eap_auth_start.user_id_len);
-
-		} else if ((idx == config->identity_len) && config->identity_len &&
-					(config->identity != NULL)) {
-
-			/* config file : <identity in RAW format >*/
-			identity_len = config->identity_len;
-			identity = os_malloc(config->identity_len);
-
-			if (NULL != identity) {
-				os_memset(identity, 0, config->identity_len);
-				os_memcpy(identity, config->identity,
-						config->identity_len);
-			}
-
-			identity_format = EAP_IDENTITY_CFG_RAW;
-			eap_auth_start.user_id_valid = 1;
-			wpa_printf(MSG_ERROR, "eap_proxy: EAP_IDENTITY_CFG_RAW selected %d \n", eap_auth_start.user_id_len);
-		} else if (!idx && mcc_idx) {
-
-			/* config file: @wlan.mnc000.mcc000.<>.<> */
-			identity_len = config->identity_len;
-			identity = os_malloc(config->identity_len);
-
-			if (NULL != identity) {
-				os_memset(identity, 0, config->identity_len);
-				os_memcpy(identity, config->identity,
-					 config->identity_len);
-			}
-
-			identity_format = EAP_IDENTITY_IMSI_3GPP_REALM;
-			eap_auth_start.user_id_valid = 1;
-			wpa_printf(MSG_ERROR, "eap_proxy: config EAP_IDENTITY_IMSI_3GPP_REALM selected %d \n", eap_auth_start.user_id_len);
-		}
-	} else {
-
-		if (config->anonymous_identity_len && config->anonymous_identity != NULL) {
-
-			eap_auth_start.eap_meta_identity_len = config->anonymous_identity_len;
-			os_memcpy(&eap_auth_start.eap_meta_identity ,
-						config->anonymous_identity ,
-						config->anonymous_identity_len);
-
-			identity_format = EAP_IDENTITY_ANNONYMOUS;
-			eap_auth_start.eap_meta_identity_valid = 1;
-			wpa_printf(MSG_ERROR, "eap_proxy: EAP_IDENTITY_ANNONYMOUS selected user id %d, annonymous %d\n",
-						eap_auth_start.user_id_len, eap_auth_start.eap_meta_identity_len);
-		} else {
-			/* config file doesn't contain any identity
-				generating IMSI@realm */
-			identity_format = EAP_IDENTITY_IMSI_3GPP_REALM;
-			eap_auth_start.user_id_valid = 1;
-			wpa_printf(MSG_ERROR, "eap_proxy: EAP_IDENTITY_IMSI_3GPP_REALM id len %d \n", eap_auth_start.user_id_len);
-		}
-	}
-#endif /* SIM_AKA_IMSI_RAW_ENABLED */
-	if (identity_format == EAP_IDENTITY_IMSI_3GPP_REALM ||
-		identity_format == EAP_IDENTITY_IMSI_RAW || mcc_idx) {
-
-		wpa_printf(MSG_ERROR, "eap_proxy: EAP_IDENTITY_IMSI_3GPP_REALM is selected\n");
-		if (!wpa_qmi_read_card_status(sim_num, eap_proxy->wpa_uim)) {
-			wpa_printf(MSG_INFO, "eap_proxy: Read Card Status failed, return\n");
-			if (NULL != identity) {
-				os_free(identity);
-				identity = NULL;
-			}
-			return FALSE;
-		}
-
-		if (!wpa_qmi_read_card_imsi(sim_num, eap_proxy->wpa_uim)) {
-			wpa_printf(MSG_INFO, "eap_proxy: Read Card IMSI failed, return\n");
-			if (NULL != identity) {
-				os_free(identity);
-				identity = NULL;
-			}
-			return FALSE;
-		}
-
-		if (imsi == NULL) {
-			wpa_printf(MSG_INFO, "eap_proxy: IMSI not available, return\n");
-			if (NULL != identity) {
-				os_free(identity);
-				identity = NULL;
-			}
-			return FALSE;
-		} else {
-			wpa_printf(MSG_ERROR, "eap_proxy: IMSI not NULL \n");
-			if (NULL == identity)
-				wpa_printf(MSG_ERROR, "eap_proxy: config file doesn't contain identity \n");
-			else
-				wpa_printf(MSG_ERROR, "eap_proxy: config file contains identity \n");
-
-			wpa_printf(MSG_ERROR, "eap_proxy: eap_type: %d\n", eap_proxy->eap_type);
-
-			if (!idx) {
-
-				/* IMSI is expected as username */
-				wpa_printf(MSG_ERROR, "eap_proxy:  username is not available in config picking IMSI \n");
-
-				if (config->identity_len > 1)
-					/* @realm provided in config */
-					imsi_identity = os_malloc(1 + IMSI_LENGTH + config->identity_len);
-				else if (identity_format == EAP_IDENTITY_IMSI_3GPP_REALM)
-					/* IMSI@realm not provided through config */
-					imsi_identity = os_malloc(1 + IMSI_LENGTH + os_strlen(realm_3gpp));
-				else
-					/* IMSI RAW */
-					imsi_identity = os_malloc(1 + IMSI_LENGTH);
-
-				if (NULL == imsi_identity) {
-					wpa_printf(MSG_ERROR, "eap_proxy: Memory not available\n");
-					if (NULL != identity) {
-						os_free(identity);
-						identity = NULL;
-					}
-					return FALSE;
-				} else {
-					if (config->identity_len > 1)
-						os_memset(imsi_identity, 0, (1 + IMSI_LENGTH + config->identity_len));
-					else if (identity_format == EAP_IDENTITY_IMSI_3GPP_REALM)
-						os_memset(imsi_identity, 0, (1 + IMSI_LENGTH + os_strlen(realm_3gpp)));
-					else
-						os_memset(imsi_identity, 0, (1 + IMSI_LENGTH));
-
-					if (eap_proxy->eap_type == EAP_TYPE_SIM)
-						imsi_identity[0] = '1';
-					else if (eap_proxy->eap_type == EAP_TYPE_AKA)
-						imsi_identity[0] = '0';
-#ifdef CONFIG_EAP_PROXY_AKA_PRIME
-					else if (eap_proxy->eap_type == EAP_TYPE_AKA_PRIME)
-						imsi_identity[0] = '6';
-#endif /* CONFIG_EAP_PROXY_AKA_PRIME */
-					else
-						/* Default value is set as SIM */
-						imsi_identity[0] = '1';
-
-					/* copying IMSI value */
-					os_memcpy(imsi_identity + 1 , imsi , imsi_len_g);
-
-					if (config->identity_len > 1 && NULL != identity) {
-						/* copying realm tag */
-						os_memcpy(imsi_identity + 1 + imsi_len_g , identity , config->identity_len);
-						imsi_id_len = imsi_len_g + 1 + config->identity_len;
-						os_free(identity);
-						identity = NULL;
-					} else if (identity_format == EAP_IDENTITY_IMSI_3GPP_REALM) {
-						/* realm is not available so append it */
-						os_memcpy(imsi_identity + 1 + imsi_len_g , realm_3gpp, os_strlen(realm_3gpp));
-						imsi_id_len = imsi_len_g + 1 + os_strlen(realm_3gpp);
-					} else
-						/* IMSI RAW */
-						imsi_id_len = imsi_len_g + 1;
-				}
-			} else if (identity) {
-				/* idx is non-zero implies username available */
-				imsi_identity = identity;
-				imsi_id_len = config->identity_len;
-			}
-		}
-
-		if (identity_format == EAP_IDENTITY_IMSI_3GPP_REALM || mcc_idx) {
-
-			if (0 == idx) {
-			/* id = @wlan.mnc000.mcc000.<>.<> realm exist
-				but need to insert mnc and mcc values */
-				idx = imsi_len_g + 1;
-			}
-
-			if (imsi_identity != NULL) {
-				/* mcc valus */
-				imsi_identity[idx + 16] = imsi[0];
-				imsi_identity[idx + 17] = imsi[1];
-				imsi_identity[idx + 18] = imsi[2];
-			}
-
-			/* mnc valus */
-			mnc_len = card_mnc_len;
-			wpa_printf(MSG_ERROR, "eap_proxy: card mnc len %d\n", card_mnc_len);
-
-			if ((mnc_len == 2) && (imsi_identity != NULL)) {
-				imsi_identity[idx + 9]  = '0';
-				imsi_identity[idx + 10] = imsi[3];
-				imsi_identity[idx + 11] = imsi[4];
-			} else if ((mnc_len == 3) && (imsi_identity != NULL)) {
-				imsi_identity[idx + 9]  = imsi[3];
-				imsi_identity[idx + 10] = imsi[4];
-				imsi_identity[idx + 11] = imsi[5];
-			}
-			wpa_printf(MSG_ERROR, "eap_proxy:  Appending 3gpp realm\n ");
-		}
-		identity = imsi_identity;
-		identity_len = imsi_id_len;
-		eap_auth_start.user_id_valid = 1;
-	}
-
-	eap_auth_start.user_id_len = identity_len;
-
-	if(identity_len >= QMI_AUTH_EAP_IDENTITY_MAX_CHAR_V01)
-	{
-		wpa_printf(MSG_ERROR, "eap_proxy: Invalid User Identity length =%d",identity_len);
-		return FALSE;
-	}
-
-	if(identity)
-	{
-		memcpy(&eap_auth_start.user_id, identity, identity_len);
-		eap_auth_start.user_id_valid = 1;
-	}
-
-	wpa_printf(MSG_ERROR, "eap_proxy: eap auth user identity  - %20s length-%d\n ",
-		    eap_auth_start.user_id, eap_auth_start.user_id_len);
-
-	if ( (sim_num < 0) || (sim_num >= MAX_NO_OF_SIM_SUPPORTED)) {
-		wpa_printf(MSG_ERROR, "eap_proxy: SIM: Invalid SIM selected by "
-			    "User: Selected sim = %d\n", sim_num+1);
-		return FALSE;
-	}
-
-
-        eap_proxy->user_selected_sim = sim_num;
-	wpa_printf(MSG_ERROR, "eap_proxy: SIM selected by User: Selected sim = %d\n",
-		    eap_proxy->user_selected_sim+1);
-
-	memset(&sub_req_binding, 0, sizeof(auth_set_subscription_binding_req_msg_v01));
-	memset(&sub_resp_binding, 0, sizeof(auth_set_subscription_binding_resp_msg_v01));
-#ifdef CONFIG_EAP_PROXY_DUAL_SIM
-	if (sim_num == 0) {
-		sub_req_binding.bind_subs = AUTH_PRIMARY_SUBS_V01;
-		qmiRetCode = qmi_client_send_msg_sync(eap_proxy->qmi_auth_svc_client_ptr[sim_num],
-				QMI_AUTH_SET_SUBSCRIPTION_BINDING_REQ_V01,
-						(void *) &sub_req_binding,
-						sizeof(auth_set_subscription_binding_req_msg_v01),
-						(void *) &sub_resp_binding,
-						sizeof(auth_set_subscription_binding_resp_msg_v01),
-						WPA_UIM_QMI_DEFAULT_TIMEOUT);
-
-				if ((QMI_NO_ERR != qmiRetCode || sub_resp_binding.resp.result != QMI_RESULT_SUCCESS_V01 ) &&
-				    (QMI_ERR_OP_DEVICE_UNSUPPORTED_V01 != sub_resp_binding.resp.error)) {
-			wpa_printf(MSG_ERROR, "QMI-ERROR Unable to get the qmi_auth_set_subscription_binding for"
-					" sim 1; error_ret=%d; error_code=%d\n", qmiRetCode,
-					sub_resp_binding.resp.error);
-			return FALSE;
-		}
-		wpa_printf (MSG_ERROR, "eap_proxy: Binded with PRIMARY Subscription\n");
-	} else if (sim_num == 1) {
-		sub_req_binding.bind_subs = AUTH_SECONDARY_SUBS_V01;
-		qmiRetCode = qmi_client_send_msg_sync(eap_proxy->qmi_auth_svc_client_ptr[sim_num],
-				QMI_AUTH_SET_SUBSCRIPTION_BINDING_REQ_V01,
-						(void *) &sub_req_binding,
-						sizeof(auth_set_subscription_binding_req_msg_v01),
-						(void *) &sub_resp_binding,
-						sizeof(auth_set_subscription_binding_resp_msg_v01),
-						WPA_UIM_QMI_DEFAULT_TIMEOUT);
-
-		if (QMI_NO_ERR != qmiRetCode || sub_resp_binding.resp.result != QMI_RESULT_SUCCESS_V01 ) {
-			wpa_printf(MSG_ERROR, "QMI-ERROR Unable to get the qmi_auth_set_subscription_binding for"
-					" sim 2; error_ret=%d; error_code=%d\n", qmiRetCode,
-					sub_resp_binding.resp.error);
-			return FALSE;
-		}
-
-		wpa_printf (MSG_ERROR, "eap_proxy: Binded with SECONDARY Subscription\n");
-	} else {
-		wpa_printf(MSG_ERROR, "eap_proxy: Invalid SIM selected by User: Selected sim = %d\n", sim_num+1);
-		return FALSE;
-	}
-#endif
-	if (TRUE == eap_proxy->eap_auth_session_flag[sim_num]) {
-			if(eap_auth_end_eap_session(eap_proxy->qmi_auth_svc_client_ptr[sim_num]) < 0) {
-				wpa_printf(MSG_ERROR, "eap_proxy: Unable to end the EAP session;"
-						" sim_num%d;", sim_num);
-			}
-			eap_proxy->eap_auth_session_flag[sim_num] = FALSE;
-	}
-
-	if (FALSE == eap_proxy->eap_auth_session_flag[sim_num]) {
-			wpa_printf(MSG_ERROR, "eap_proxy: eap_auth_start values\n");
-			wpa_printf(MSG_ERROR, "eap_proxy: eap_auth_start.eap_method_mask = %d\n", eap_auth_start.eap_method_mask);
-			wpa_printf(MSG_ERROR, "eap_proxy: eap_auth_start.user_id_len = %d\n", eap_auth_start.user_id_len);
-			wpa_printf(MSG_ERROR, "eap_proxy: eap_auth_start.eap_meta_id_len = %d\n", eap_auth_start.eap_meta_identity_len);
-			wpa_printf(MSG_ERROR, "eap_auth_start.eap_sim_aka_algo = %d\n", eap_auth_start.eap_sim_aka_algo);
-	qmiRetCode = qmi_client_send_msg_sync(eap_proxy->qmi_auth_svc_client_ptr[sim_num],
-						QMI_AUTH_START_EAP_SESSION_REQ_V01,
-						(void *) &eap_auth_start,
-						sizeof(auth_start_eap_session_req_msg_v01),
-						(void *) &eap_auth_start_resp,
-						sizeof(auth_start_eap_session_resp_msg_v01),
-						WPA_UIM_QMI_DEFAULT_TIMEOUT);
-	if (QMI_NO_ERR != qmiRetCode ||
-	    eap_auth_start_resp.resp.result != QMI_RESULT_SUCCESS_V01) {
-		wpa_printf(MSG_ERROR, " QMI-ERROR Unable to start the EAP session;"
-			   " error_ret=%d; qmi_err=%d\n", qmiRetCode,
-			   eap_auth_start_resp.resp.error);
-		if(eap_auth_start.eap_method_mask == QMI_AUTH_EAP_METHOD_MASK_AKA_PRIME_V01 &&
-		   eap_auth_start_resp.resp.error == QMI_ERR_INVALID_ARG_V01)
-			wpa_printf(MSG_ERROR, "QMI-ERROR AKA' not supported\n");
-
-		return FALSE;
-		}
-		eap_proxy->eap_auth_session_flag[sim_num] = TRUE;
-		eap_proxy->qmi_state = QMI_STATE_IDLE;
-		wpa_printf(MSG_ERROR, "eap_proxy: EAP session started"
-			   " error_ret=%d; Resp=%d\n", qmiRetCode,
-			    eap_auth_start_resp.resp.error);
-	}
-
-	return TRUE;
-}
-
-
-
-#ifdef CONFIG_CTRL_IFACE
-
-/**
- * eap_proxyl_sm_get_status - Get EAP state machine status
- * @sm: Pointer to EAP state machine allocated with eap_sm_init()
- * @buf: Buffer for status information
- * @buflen: Maximum buffer length
- * @verbose: Whether to include verbose status information
- * Returns: Number of bytes written to buf.
- *
- * Query EAP state machine for status information. This function fills in a
- * text area with current status information from the EAPOL state machine. If
- * the buffer (buf) is not large enough, status information will be truncated
- * to fit the buffer.
- */
-int eap_proxy_sm_get_status(struct eap_proxy_sm *sm, char *buf, size_t buflen,
-			    int verbose)
-{
-	int len, ret;
-
-	if (sm == NULL)
-		return 0;
-
-	len = os_snprintf(buf, buflen, "eap_proxy: EAP state=%s\n",
-			  eap_proxy_sm_state_txt(sm->proxy_state));
-	if (len < 0 || (size_t)len >= buflen)
-		return 0;
-
-	if (sm->eap_type != EAP_TYPE_NONE) {
-		char name[8] = "Unknown";
-
-	if (sm->eap_type == EAP_TYPE_SIM)
-		os_strlcpy(name, "SIM", 4);
-	else if (sm->eap_type == EAP_TYPE_AKA)
-		os_strlcpy(name, "AKA", 4);
-
-		ret = os_snprintf(buf + len, buflen - len,
-				"selectedMethod=%d (EAP-%s)\n",
-					sm->eap_type, name);
-		if (ret < 0 || (size_t)ret >= buflen - len)
-			return len;
-		len += ret;
-	}
-
-	return len;
-}
-
-
-static const char *eap_proxy_sm_state_txt(int state)
-{
-	switch (state) {
-	case EAP_PROXY_INITIALIZE:
-		return "INITIALIZE";
-	case EAP_PROXY_DISABLED:
-		return "DISABLED";
-	case EAP_PROXY_IDLE:
-		return "IDLE";
-	case EAP_PROXY_RECEIVED:
-		return "RECEIVED";
-	case EAP_PROXY_GET_METHOD:
-		return "GET_METHOD";
-	case EAP_PROXY_METHOD:
-		return "METHOD";
-	case EAP_PROXY_SEND_RESPONSE:
-		return "SEND_RESPONSE";
-	case EAP_PROXY_DISCARD:
-		return "DISCARD";
-	case EAP_PROXY_IDENTITY:
-		return "IDENTITY";
-	case EAP_PROXY_NOTIFICATION:
-		return "NOTIFICATION";
-	case EAP_PROXY_RETRANSMIT:
-		return "RETRANSMIT";
-	case EAP_PROXY_AUTH_SUCCESS:
-		return "SUCCESS";
-	case EAP_PROXY_AUTH_FAILURE:
-		return "FAILURE";
-	default:
-		return "UNKNOWN";
-	}
-}
-#endif /* CONFIG_CTRL_IFACE */
-
-
-/**
- * eap_proxy_get_mcc_mnc - Get MCC/MNC
- * @imsi_buf: Buffer for returning IMSI
- * @imsi_len: Buffer for returning IMSI length
- * Returns: MNC length (2 or 3) or -1 on error
- */
-int eap_proxy_get_imsi(struct eap_proxy_sm *eap_proxy, char *imsi_buf,
-			size_t *imsi_len)
-{
-#ifdef SIM_AKA_IDENTITY_IMSI
-	int mnc_len;
-	int sim_num = eap_proxy->user_selected_sim;
-
-	if ((eap_proxy->proxy_state == EAP_PROXY_DISABLED) ||
-	    (eap_proxy->proxy_state == EAP_PROXY_INITIALIZE)) {
-		wpa_printf(MSG_ERROR, "eap_proxy:%s: Not initialized\n", __func__);
-		return FALSE;
-	}
-	if (!wpa_qmi_read_card_status(sim_num, eap_proxy->wpa_uim)) {
-	wpa_printf(MSG_INFO, "eap_proxy: Card not ready");
-		return -1;
-	}
-
-	if (!wpa_qmi_read_card_imsi(sim_num, eap_proxy->wpa_uim) || imsi == NULL) {
-		wpa_printf(MSG_INFO, "eap_proxy: Failed to read card IMSI");
-		return -1;
-	}
-
-	*imsi_len = os_strlen(imsi);
-	os_memcpy(imsi_buf, imsi, *imsi_len + 1);
-
-	mnc_len = card_mnc_len;
-	if (mnc_len < 2 || mnc_len > 3)
-		mnc_len = 3; /* Default to 3 if MNC length is unknown */
-
-	os_free(imsi);
-	imsi = NULL;
-
-	return mnc_len;
-#else /* SIM_AKA_IDENTITY_IMSI */
-	return -1;
-#endif /* SIM_AKA_IDENTITY_IMSI */
-}
-
-int eap_proxy_notify_config(struct eap_proxy_sm *eap_proxy,
-                            struct eap_peer_config *config)
-{
-	int ret_val;
-
-	wpa_printf(MSG_ERROR, "eap_proxy: eap_proxy_notify_config\n");
-	if (!eap_proxy) {
-		wpa_printf(MSG_ERROR, "eap_proxy: is NULL");
-		return FALSE;
-	}
-
-	if ((eap_proxy->proxy_state == EAP_PROXY_DISABLED) ||
-	    (eap_proxy->proxy_state == EAP_PROXY_INITIALIZE)) {
-		wpa_printf(MSG_ERROR, "eap_proxy: Not initialized\n");
-		return FALSE;
-	}
-
-	if ( config && eap_proxy_allowed_method(config, EAP_VENDOR_IETF,
-			EAP_TYPE_SIM)) {
-		eap_proxy->eap_type =  EAP_TYPE_SIM;
-		ret_val = TRUE;
-	} else if ( config && eap_proxy_allowed_method(config, EAP_VENDOR_IETF,
-	                        EAP_TYPE_AKA)) {
-		eap_proxy->eap_type =  EAP_TYPE_AKA;
-		ret_val = TRUE;
-	} else if ( config && eap_proxy_allowed_method(config, EAP_VENDOR_IETF,
-	                        EAP_TYPE_AKA_PRIME)) {
-		eap_proxy->eap_type =  EAP_TYPE_AKA_PRIME;
-		ret_val = TRUE;
-	} else
-		ret_val = FALSE;
-
-	return ret_val;
-}
-
-int eap_proxy_allowed_method(struct eap_peer_config *config, int vendor,
-			      u32 method)
-{
-	int i;
-	struct eap_method_type *m;
-
-	wpa_printf(MSG_ERROR, "eap_proxy: eap_proxy_allowed_method");
-	if (config == NULL || config->eap_methods == NULL)
-		return -1;
-
-	m = config->eap_methods;
-	for (i = 0; m[i].vendor != EAP_VENDOR_IETF ||
-		     m[i].method != EAP_TYPE_NONE; i++) {
-		if (m[i].vendor == vendor && m[i].method == method)
-			return 1;
-	}
-	return 0;
-}
-
-#endif  /* CONFIG_EAP_PROXY */
diff --git a/src/eap_peer/eap_proxy_qmi.h b/src/eap_peer/eap_proxy_qmi.h
deleted file mode 100644
index 04f0fc9..0000000
--- a/src/eap_peer/eap_proxy_qmi.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/*--------------------------------------------------------------------------
-Copyright (c) 2013, The Linux Foundation. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-    * Neither the name of The Linux Foundation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------*/
-
-#ifndef EAP_PROXY_QMI_H
-#define EAP_PROXY_QMI_H
-
-
-#include "eap_i.h"
-#include "eap_config.h"
-#include "eloop.h"
-#include "eapol_supp/eapol_supp_sm.h"
-#include "user_identity_module_v01.h"
-
-/*msec Response Timeout*/
-#define QMI_RESP_TIME_OUT 2000
-#define EAP_PROXY_KEYING_DATA_LEN 64
-
-#ifdef CONFIG_EAP_PROXY_DUAL_SIM
-#define MAX_NO_OF_SIM_SUPPORTED 2
-#else
-#define MAX_NO_OF_SIM_SUPPORTED 1
-#endif /* CONFIG_EAP_PROXY_DUAL_SIM */
-
-typedef enum {
-  QMI_STATE_IDLE = 0x00,
-  QMI_STATE_RESP_PENDING  = 0x01,
-  QMI_STATE_RESP_RECEIVED = 0x02,
-  QMI_STATE_RESP_TIME_OUT = 0x03
-} qmi_state_e;
-
-typedef enum {
-  EAP_PROXY_QMI_SRVC_NO_RESULT,
-  EAP_PROXY_QMI_SRVC_SUCCESS,
-  EAP_PROXY_QMI_SRVC_FAILURE
-} eap_proxy_qmi_srv_result;
-
-/* should match the EAP_state  of eap_i.h */
-typedef enum {
- EAP_PROXY_INITIALIZE, EAP_PROXY_DISABLED, EAP_PROXY_IDLE, EAP_PROXY_RECEIVED,
- EAP_PROXY_GET_METHOD, EAP_PROXY_METHOD, EAP_PROXY_SEND_RESPONSE,
- EAP_PROXY_DISCARD, EAP_PROXY_IDENTITY, EAP_PROXY_NOTIFICATION,
- EAP_PROXY_RETRANSMIT,
- EAP_PROXY_AUTH_SUCCESS,  EAP_PROXY_AUTH_FAILURE
-} eap_proxy_state;
-
-
-enum eap_proxy_status {
-   EAP_PROXY_FAILURE = 0x00,
-   EAP_PROXY_SUCCESS
-};
-
-typedef enum {
-  EAP_IDENTITY_ANNONYMOUS = 0x00,
-  EAP_IDENTITY_IMSI_RAW  = 0x02,
-  EAP_IDENTITY_IMSI_3GPP_REALM = 0x03,
-  EAP_IDENTITY_IMSI_REALM = 0x04,
-  EAP_IDENTITY_CFG_RAW = 0x05,
-  EAP_IDENTITY_CFG_3GPP_REALM = 0x06,
-  EAP_IDENTITY_CFG_REALM = 0x07,
-} eap_identity_format_e;
-
-typedef union
-{
-       struct
-       {
-               void *resp_data; /* Pointer to the Response Packet*/
-               unsigned long length;     /*Length of the Response Packet*/
-       }eap_send_pkt_resp;
-
-}qmi_eap_sync_rsp_data_type;
-
-typedef struct {
-  uim_card_state_enum_v01                      card_state;
-  uim_card_error_code_enum_v01                 card_error_code;
-  u8                                           app_state;
-  u8                                           app_type;
-} wpa_uim_card_info_type;
-
-typedef struct {
-  int                                   card_ready_idx;
-  wpa_uim_card_info_type                card_info[QMI_UIM_CARDS_MAX_V01];
-  qmi_client_type                       qmi_uim_svc_client_ptr;
-  int                                   qmi_msg_lib_handle;
-} wpa_uim_struct_type;
-
-
-struct eap_proxy_sm {
-   qmi_client_type qmi_auth_svc_client_ptr[MAX_NO_OF_SIM_SUPPORTED];
-   qmi_state_e qmi_state;
-   eap_proxy_qmi_srv_result srvc_result;
-   qmi_eap_sync_rsp_data_type qmi_resp_data;
-   eap_proxy_state  proxy_state;
-   Boolean iskey_valid;
-   u8 *key;
-   Boolean is_state_changed;
-   void *ctx;
-   void *msg_ctx;
-   struct eapol_callbacks *eapol_cb;
-   u8 *eapReqData;
-   size_t eapReqDataLen;
-   Boolean isEap;
-   int eap_type;
-   int user_selected_sim;
-   int eap_auth_session_flag[MAX_NO_OF_SIM_SUPPORTED];
-   pthread_t thread_id;
-   wpa_uim_struct_type   wpa_uim[MAX_NO_OF_SIM_SUPPORTED];
-   Boolean qmi_uim_svc_client_initialized[MAX_NO_OF_SIM_SUPPORTED];
-};
-
-int eap_proxy_allowed_method(struct eap_peer_config *config, int vendor,
-                              u32 method);
-
-#endif /* EAP_PROXY_QMI_H */
diff --git a/src/eap_peer/eap_pwd.c b/src/eap_peer/eap_pwd.c
index 92bafee..5a60b3f 100644
--- a/src/eap_peer/eap_pwd.c
+++ b/src/eap_peer/eap_pwd.c
@@ -767,8 +767,7 @@ eap_pwd_perform_confirm_exchange(struct eap_sm *sm, struct eap_pwd_data *data,
 	wpabuf_put_data(data->outbuf, conf, SHA256_MAC_LEN);
 
 fin:
-	if (data->grp)
-		bin_clear_free(cruft, BN_num_bytes(data->grp->prime));
+	bin_clear_free(cruft, BN_num_bytes(data->grp->prime));
 	BN_clear_free(x);
 	BN_clear_free(y);
 	if (data->outbuf == NULL) {
@@ -897,7 +896,7 @@ eap_pwd_process(struct eap_sm *sm, void *priv, struct eap_method_ret *ret,
 	/*
 	 * buffer and ACK the fragment
 	 */
-	if (EAP_PWD_GET_MORE_BIT(lm_exch) || data->in_frag_pos) {
+	if (EAP_PWD_GET_MORE_BIT(lm_exch)) {
 		data->in_frag_pos += len;
 		if (data->in_frag_pos > wpabuf_size(data->inbuf)) {
 			wpa_printf(MSG_INFO, "EAP-pwd: Buffer overflow attack "
@@ -910,8 +909,7 @@ eap_pwd_process(struct eap_sm *sm, void *priv, struct eap_method_ret *ret,
 			return NULL;
 		}
 		wpabuf_put_data(data->inbuf, pos, len);
-	}
-	if (EAP_PWD_GET_MORE_BIT(lm_exch)) {
+
 		resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_PWD,
 				     EAP_PWD_HDR_SIZE,
 				     EAP_CODE_RESPONSE, eap_get_id(reqData));
@@ -925,8 +923,10 @@ eap_pwd_process(struct eap_sm *sm, void *priv, struct eap_method_ret *ret,
 	 * we're buffering and this is the last fragment
 	 */
 	if (data->in_frag_pos) {
+		wpabuf_put_data(data->inbuf, pos, len);
 		wpa_printf(MSG_DEBUG, "EAP-pwd: Last fragment, %d bytes",
 			   (int) len);
+		data->in_frag_pos += len;
 		pos = wpabuf_head_u8(data->inbuf);
 		len = data->in_frag_pos;
 	}
diff --git a/src/eap_peer/eap_sim.c b/src/eap_peer/eap_sim.c
index 99a2816..8f289bf 100644
--- a/src/eap_peer/eap_sim.c
+++ b/src/eap_peer/eap_sim.c
@@ -242,6 +242,21 @@ static int eap_sim_gsm_auth(struct eap_sm *sm, struct eap_sim_data *data)
 	if (conf == NULL)
 		return -1;
 
+#ifdef CONFIG_ATCI
+		if (scard_gsm_auth(eap_sm_get_sim_slot(sm), data->rand[0],
+				   data->sres[0], data->kc[0]) ||
+			scard_gsm_auth(eap_sm_get_sim_slot(sm), data->rand[1],
+				   data->sres[1], data->kc[1]) ||
+			(data->num_chal > 2 &&
+			 scard_gsm_auth(eap_sm_get_sim_slot(sm), data->rand[2],
+					data->sres[2], data->kc[2]))) {
+			wpa_printf(MSG_DEBUG, "EAP-SIM: GSM SIM "
+				   "authentication could not be completed");
+			return -1;
+		}
+		return 0;
+#endif
+
 	if (sm->external_sim) {
 		if (conf->external_sim_resp)
 			return eap_sim_ext_sim_result(sm, data, conf);
diff --git a/src/eap_server/eap_server_pwd.c b/src/eap_server/eap_server_pwd.c
index 9f787ab..cb83ff7 100644
--- a/src/eap_server/eap_server_pwd.c
+++ b/src/eap_server/eap_server_pwd.c
@@ -970,7 +970,7 @@ static void eap_pwd_process(struct eap_sm *sm, void *priv,
 	/*
 	 * the first and all intermediate fragments have the M bit set
 	 */
-	if (EAP_PWD_GET_MORE_BIT(lm_exch) || data->in_frag_pos) {
+	if (EAP_PWD_GET_MORE_BIT(lm_exch)) {
 		if ((data->in_frag_pos + len) > wpabuf_size(data->inbuf)) {
 			wpa_printf(MSG_DEBUG, "EAP-pwd: Buffer overflow "
 				   "attack detected! (%d+%d > %d)",
@@ -981,8 +981,6 @@ static void eap_pwd_process(struct eap_sm *sm, void *priv,
 		}
 		wpabuf_put_data(data->inbuf, pos, len);
 		data->in_frag_pos += len;
-	}
-	if (EAP_PWD_GET_MORE_BIT(lm_exch)) {
 		wpa_printf(MSG_DEBUG, "EAP-pwd: Got a %d byte fragment",
 			   (int) len);
 		return;
@@ -992,6 +990,8 @@ static void eap_pwd_process(struct eap_sm *sm, void *priv,
 	 * buffering fragments so that's how we know it's the last)
 	 */
 	if (data->in_frag_pos) {
+		wpabuf_put_data(data->inbuf, pos, len);
+		data->in_frag_pos += len;
 		pos = wpabuf_head_u8(data->inbuf);
 		len = data->in_frag_pos;
 		wpa_printf(MSG_DEBUG, "EAP-pwd: Last fragment, %d bytes",
diff --git a/src/fst/Makefile b/src/fst/Makefile
deleted file mode 100644
index 9c41962..0000000
--- a/src/fst/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-all:
-	@echo Nothing to be made.
-
-clean:
-	rm -f *~ *.o *.d
-
-install:
-	@echo Nothing to be made.
diff --git a/src/fst/fst.c b/src/fst/fst.c
deleted file mode 100644
index 40430e2..0000000
--- a/src/fst/fst.c
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * FST module implementation
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "utils/includes.h"
-
-#include "utils/common.h"
-#include "utils/eloop.h"
-#include "fst/fst.h"
-#include "fst/fst_internal.h"
-#include "fst/fst_defs.h"
-#include "fst/fst_ctrl_iface.h"
-
-struct dl_list fst_global_ctrls_list;
-
-
-static void fst_ctrl_iface_notify_peer_state_change(struct fst_iface *iface,
-						    Boolean connected,
-						    const u8 *peer_addr)
-{
-	union fst_event_extra extra;
-
-	extra.peer_state.connected = connected;
-	os_strlcpy(extra.peer_state.ifname, fst_iface_get_name(iface),
-		   sizeof(extra.peer_state.ifname));
-	os_memcpy(extra.peer_state.addr, peer_addr, ETH_ALEN);
-
-	foreach_fst_ctrl_call(on_event, EVENT_PEER_STATE_CHANGED,
-			      iface, NULL, &extra);
-}
-
-
-struct fst_iface * fst_attach(const char *ifname, const u8 *own_addr,
-			      const struct fst_wpa_obj *iface_obj,
-			      const struct fst_iface_cfg *cfg)
-{
-	struct fst_group *g;
-	struct fst_group *group = NULL;
-	struct fst_iface *iface = NULL;
-	Boolean new_group = FALSE;
-
-	WPA_ASSERT(ifname != NULL);
-	WPA_ASSERT(iface_obj != NULL);
-	WPA_ASSERT(cfg != NULL);
-
-	foreach_fst_group(g) {
-		if (os_strcmp(cfg->group_id, fst_group_get_id(g)) == 0) {
-			group = g;
-			break;
-		}
-	}
-
-	if (!group) {
-		group = fst_group_create(cfg->group_id);
-		if (!group) {
-			fst_printf(MSG_ERROR, "%s: FST group cannot be created",
-				   cfg->group_id);
-			return NULL;
-		}
-		new_group = TRUE;
-	}
-
-	iface = fst_iface_create(group, ifname, own_addr, iface_obj, cfg);
-	if (!iface) {
-		fst_printf_group(group, MSG_ERROR, "cannot create iface for %s",
-				 ifname);
-		if (new_group)
-			fst_group_delete(group);
-		return NULL;
-	}
-
-	fst_group_attach_iface(group, iface);
-	fst_group_update_ie(group);
-
-	foreach_fst_ctrl_call(on_iface_added, iface);
-
-	fst_printf_iface(iface, MSG_DEBUG,
-			 "iface attached to group %s (prio=%d, llt=%d)",
-			 cfg->group_id, cfg->priority, cfg->llt);
-
-	return iface;
-}
-
-
-void fst_detach(struct fst_iface *iface)
-{
-	struct fst_group *group = fst_iface_get_group(iface);
-
-	fst_printf_iface(iface, MSG_DEBUG, "iface detached from group %s",
-			 fst_group_get_id(group));
-	fst_session_global_on_iface_detached(iface);
-	foreach_fst_ctrl_call(on_iface_removed, iface);
-	fst_group_detach_iface(group, iface);
-	fst_iface_delete(iface);
-	fst_group_update_ie(group);
-	fst_group_delete_if_empty(group);
-}
-
-
-int fst_global_init(void)
-{
-	dl_list_init(&fst_global_groups_list);
-	dl_list_init(&fst_global_ctrls_list);
-	fst_session_global_init();
-	return 0;
-}
-
-
-void fst_global_deinit(void)
-{
-	struct fst_group *group;
-	struct fst_ctrl_handle *h;
-
-	fst_session_global_deinit();
-	while ((group = fst_first_group()) != NULL)
-		fst_group_delete(group);
-	while ((h = dl_list_first(&fst_global_ctrls_list,
-				  struct fst_ctrl_handle,
-				  global_ctrls_lentry)))
-		fst_global_del_ctrl(h);
-}
-
-
-struct fst_ctrl_handle * fst_global_add_ctrl(const struct fst_ctrl *ctrl)
-{
-	struct fst_ctrl_handle *h;
-
-	if (!ctrl)
-		return NULL;
-
-	h = os_zalloc(sizeof(*h));
-	if (!h)
-		return NULL;
-
-	if (ctrl->init && ctrl->init()) {
-		os_free(h);
-		return NULL;
-	}
-
-	h->ctrl = *ctrl;
-	dl_list_add_tail(&fst_global_ctrls_list, &h->global_ctrls_lentry);
-
-	return h;
-}
-
-
-void fst_global_del_ctrl(struct fst_ctrl_handle *h)
-{
-	dl_list_del(&h->global_ctrls_lentry);
-	if (h->ctrl.deinit)
-		h->ctrl.deinit();
-	os_free(h);
-}
-
-
-void fst_rx_action(struct fst_iface *iface, const struct ieee80211_mgmt *mgmt,
-		   size_t len)
-{
-	if (fst_iface_is_connected(iface, mgmt->sa, FALSE))
-		fst_session_on_action_rx(iface, mgmt, len);
-	else
-		wpa_printf(MSG_DEBUG,
-			   "FST: Ignore FST Action frame - no FST connection with "
-			   MACSTR, MAC2STR(mgmt->sa));
-}
-
-
-void fst_notify_peer_connected(struct fst_iface *iface, const u8 *addr)
-{
-	if (is_zero_ether_addr(addr))
-		return;
-
-#ifndef HOSTAPD
-	fst_group_update_ie(fst_iface_get_group(iface));
-#endif /* HOSTAPD */
-
-	fst_printf_iface(iface, MSG_DEBUG, MACSTR " became connected",
-			 MAC2STR(addr));
-
-	fst_ctrl_iface_notify_peer_state_change(iface, TRUE, addr);
-}
-
-
-void fst_notify_peer_disconnected(struct fst_iface *iface, const u8 *addr)
-{
-	if (is_zero_ether_addr(addr))
-		return;
-
-#ifndef HOSTAPD
-	fst_group_update_ie(fst_iface_get_group(iface));
-#endif /* HOSTAPD */
-
-	fst_printf_iface(iface, MSG_DEBUG, MACSTR " became disconnected",
-			 MAC2STR(addr));
-
-	fst_ctrl_iface_notify_peer_state_change(iface, FALSE, addr);
-}
-
-
-Boolean fst_are_ifaces_aggregated(struct fst_iface *iface1,
-				  struct fst_iface *iface2)
-{
-	return fst_iface_get_group(iface1) == fst_iface_get_group(iface2);
-}
-
-
-enum mb_band_id fst_hw_mode_to_band(enum hostapd_hw_mode mode)
-{
-	switch (mode) {
-	case HOSTAPD_MODE_IEEE80211B:
-	case HOSTAPD_MODE_IEEE80211G:
-		return MB_BAND_ID_WIFI_2_4GHZ;
-	case HOSTAPD_MODE_IEEE80211A:
-		return MB_BAND_ID_WIFI_5GHZ;
-	case HOSTAPD_MODE_IEEE80211AD:
-		return MB_BAND_ID_WIFI_60GHZ;
-	default:
-		WPA_ASSERT(0);
-		return MB_BAND_ID_WIFI_2_4GHZ;
-	}
-}
diff --git a/src/fst/fst.h b/src/fst/fst.h
deleted file mode 100644
index 0c0e435..0000000
--- a/src/fst/fst.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * FST module - interface definitions
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef FST_H
-#define FST_H
-
-#ifdef CONFIG_FST
-
-#include "common/defs.h"
-#include "fst/fst_ctrl_iface.h"
-
-/* FST module hostap integration API */
-
-#define US_IN_MS           1000
-#define LLT_UNIT_US        32 /* See 10.32.2.2  Transitioning between states */
-
-#define FST_LLT_MS_TO_VAL(m) (((u32) (m)) * US_IN_MS / LLT_UNIT_US)
-#define FST_LLT_VAL_TO_MS(v) (((u32) (v)) * LLT_UNIT_US / US_IN_MS)
-
-#define FST_MAX_LLT_MS       FST_LLT_VAL_TO_MS(-1)
-#define FST_MAX_PRIO_VALUE   ((u8) -1)
-#define FST_MAX_GROUP_ID_LEN IFNAMSIZ
-
-#define FST_DEFAULT_LLT_CFG_VALUE 50
-
-struct hostapd_hw_modes;
-struct ieee80211_mgmt;
-struct fst_iface;
-struct fst_group;
-struct fst_session;
-struct fst_get_peer_ctx;
-struct fst_ctrl_handle;
-
-struct fst_wpa_obj {
-	void *ctx;
-
-	/**
-	 * get_bssid - Get BSSID of the interface
-	 * @ctx: User context %ctx
-	 * Returns: BSSID for success, %NULL for failure.
-	 *
-	 * NOTE: For AP it returns the own BSSID, while for STA - the BSSID of
-	 * the associated AP.
-	 */
-	const u8 * (*get_bssid)(void *ctx);
-
-	/**
-	 * get_channel_info - Get current channel info
-	 * @ctx: User context %ctx
-	 * @hw_mode: OUT, current HW mode
-	 * @channel: OUT, current channel
-	 */
-	void (*get_channel_info)(void *ctx, enum hostapd_hw_mode *hw_mode,
-				 u8 *channel);
-
-	/**
-	 * get_hw_modes - Get hardware modes
-	 * @ctx: User context %ctx
-	 * @modes: OUT, pointer on array of hw modes
-	 *
-	 * Returns: Number of hw modes available.
-	 */
-	int (*get_hw_modes)(void *ctx, struct hostapd_hw_modes **modes);
-
-	/**
-	 * set_ies - Set interface's MB IE
-	 * @ctx: User context %ctx
-	 * @fst_ies: MB IE buffer (owned by FST module)
-	 */
-	void (*set_ies)(void *ctx, const struct wpabuf *fst_ies);
-
-	/**
-	 * send_action - Send FST Action frame via the interface
-	 * @ctx: User context %ctx
-	 * @addr: Address of the destination STA
-	 * @data: Action frame buffer
-	 * Returns: 0 for success, negative error code for failure.
-	 */
-	int (*send_action)(void *ctx, const u8 *addr, struct wpabuf *data);
-
-	/**
-	 * get_mb_ie - Get last MB IE received from STA
-	 * @ctx: User context %ctx
-	 * @addr: Address of the STA
-	 * Returns: MB IE buffer, %NULL if no MB IE received from the STA
-	 */
-	const struct wpabuf * (*get_mb_ie)(void *ctx, const u8 *addr);
-
-	/**
-	 * update_mb_ie - Update last MB IE received from STA
-	 * @ctx: User context %ctx
-	 * @addr: Address of the STA
-	 * @buf: Buffer that contains the MB IEs data
-	 * @size: Size of data in %buf
-	 */
-	void (*update_mb_ie)(void *ctx, const u8 *addr,
-			     const u8 *buf, size_t size);
-
-	/**
-	 * get_peer_first - Get MAC address of the 1st connected STA
-	 * @ctx: User context %ctx
-	 * @get_ctx: Context to be used for %get_peer_next call
-	 * @mb_only: %TRUE if only multi-band capable peer should be reported
-	 * Returns: Address of the 1st connected STA, %NULL if no STAs connected
-	 */
-	const u8 * (*get_peer_first)(void *ctx,
-				     struct fst_get_peer_ctx **get_ctx,
-				     Boolean mb_only);
-	/**
-	 * get_peer_next - Get MAC address of the next connected STA
-	 * @ctx: User context %ctx
-	 * @get_ctx: Context received from %get_peer_first or previous
-	 *           %get_peer_next call
-	 * @mb_only: %TRUE if only multi-band capable peer should be reported
-	 * Returns: Address of the next connected STA, %NULL if no more STAs
-	 *          connected
-	 */
-	const u8 * (*get_peer_next)(void *ctx,
-				    struct fst_get_peer_ctx **get_ctx,
-				    Boolean mb_only);
-};
-
-/**
- * fst_global_init - Global FST module initiator
- * Returns: 0 for success, negative error code for failure.
- * Note: The purpose of this function is to allocate and initiate global
- *       FST module data structures (linked lists, static data etc.)
- *       This function should be called prior to the 1st %fst_attach call.
- */
-int fst_global_init(void);
-
-/**
- * fst_global_deinit - Global FST module de-initiator
- * Note: The purpose of this function is to deallocate and de-initiate global
- *       FST module data structures (linked lists, static data etc.)
- */
-void fst_global_deinit(void);
-
-/**
- * struct fst_ctrl - Notification interface for FST module
- */
-struct fst_ctrl {
-	/**
-	 * init - Initialize the notification interface
-	 * Returns: 0 for success, negative error code for failure.
-	 */
-	int (*init)(void);
-
-	/**
-	 * deinit - Deinitialize the notification interface
-	 */
-	void (*deinit)(void);
-
-	/**
-	 * on_group_created - Notify about FST group creation
-	 * Returns: 0 for success, negative error code for failure.
-	 */
-	int (*on_group_created)(struct fst_group *g);
-
-	/**
-	 * on_group_deleted - Notify about FST group deletion
-	 */
-	void (*on_group_deleted)(struct fst_group *g);
-
-	/**
-	 * on_iface_added - Notify about interface addition
-	 * Returns: 0 for success, negative error code for failure.
-	 */
-	int (*on_iface_added)(struct fst_iface *i);
-
-	/**
-	 * on_iface_removed - Notify about interface removal
-	 */
-	void (*on_iface_removed)(struct fst_iface *i);
-
-	/**
-	 * on_session_added - Notify about FST session addition
-	 * Returns: 0 for success, negative error code for failure.
-	 */
-	int (*on_session_added)(struct fst_session *s);
-
-	/**
-	 * on_session_removed - Notify about FST session removal
-	 */
-	void (*on_session_removed)(struct fst_session *s);
-
-	/**
-	 * on_event - Notify about FST event
-	 * @event_type: Event type
-	 * @i: Interface object that relates to the event or NULL
-	 * @g: Group object that relates to the event or NULL
-	 * @extra - Event specific data (see fst_ctrl_iface.h for more info)
-	 */
-	void (*on_event)(enum fst_event_type event_type, struct fst_iface *i,
-			 struct fst_session *s,
-			 const union fst_event_extra *extra);
-};
-
-struct fst_ctrl_handle * fst_global_add_ctrl(const struct fst_ctrl *ctrl);
-void fst_global_del_ctrl(struct fst_ctrl_handle *h);
-
-/**
- * NOTE: These values have to be read from configuration file
- */
-struct fst_iface_cfg {
-	char group_id[FST_MAX_GROUP_ID_LEN + 1];
-	u8 priority;
-	u32 llt;
-};
-
-/**
- * fst_attach - Attach interface to an FST group according to configuration read
- * @ifname: Interface name
- * @own_addr: Own interface MAC address
- * @iface_obj: Callbacks to be used by FST module to communicate with
- *             hostapd/wpa_supplicant
- * @cfg: FST-related interface configuration read from the configuration file
- * Returns: FST interface object for success, %NULL for failure.
- */
-struct fst_iface * fst_attach(const char *ifname,
-			      const u8 *own_addr,
-			      const struct fst_wpa_obj *iface_obj,
-			      const struct fst_iface_cfg *cfg);
-
-/**
- * fst_detach - Detach an interface
- * @iface: FST interface object
- */
-void fst_detach(struct fst_iface *iface);
-
-/* FST module inputs */
-/**
- * fst_rx_action - FST Action frames handler
- * @iface: FST interface object
- * @mgmt: Action frame arrived
- * @len: Action frame length
- */
-void fst_rx_action(struct fst_iface *iface, const struct ieee80211_mgmt *mgmt,
-		   size_t len);
-
-/**
- * fst_notify_peer_connected - FST STA connect handler
- * @iface: FST interface object
- * @addr: Address of the connected STA
- */
-void fst_notify_peer_connected(struct fst_iface *iface, const u8 *addr);
-
-/**
- * fst_notify_peer_disconnected - FST STA disconnect handler
- * @iface: FST interface object
- * @addr: Address of the disconnected STA
- */
-void fst_notify_peer_disconnected(struct fst_iface *iface, const u8 *addr);
-
-/* FST module auxiliary routines */
-
-/**
- * fst_are_ifaces_aggregated - Determines whether 2 interfaces belong to the
- *                             same FST group
- * @iface1: 1st FST interface object
- * @iface1: 2nd FST interface object
- *
- * Returns: %TRUE if the interfaces belong to the same FST group,
- *          %FALSE otherwise
- */
-Boolean fst_are_ifaces_aggregated(struct fst_iface *iface1,
-				  struct fst_iface *iface2);
-
-#else /* CONFIG_FST */
-
-static inline int fst_global_init(void)
-{
-	return 0;
-}
-
-static inline int fst_global_start(void)
-{
-	return 0;
-}
-
-static inline void fst_global_stop(void)
-{
-}
-
-static inline void fst_global_deinit(void)
-{
-}
-
-#endif /* CONFIG_FST */
-
-#endif /* FST_H */
diff --git a/src/fst/fst_ctrl_aux.c b/src/fst/fst_ctrl_aux.c
deleted file mode 100644
index dc7b2a7..0000000
--- a/src/fst/fst_ctrl_aux.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * FST module implementation
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "utils/includes.h"
-#include "utils/common.h"
-#include "common/defs.h"
-#include "fst_ctrl_defs.h"
-#include "fst_ctrl_aux.h"
-
-
-static const char *session_event_names[] = {
-	[EVENT_FST_ESTABLISHED] FST_PVAL_EVT_TYPE_ESTABLISHED,
-	[EVENT_FST_SETUP] FST_PVAL_EVT_TYPE_SETUP,
-	[EVENT_FST_SESSION_STATE_CHANGED] FST_PVAL_EVT_TYPE_SESSION_STATE,
-};
-
-static const char *reason_names[] = {
-	[REASON_TEARDOWN] FST_CS_PVAL_REASON_TEARDOWN,
-	[REASON_SETUP] FST_CS_PVAL_REASON_SETUP,
-	[REASON_SWITCH] FST_CS_PVAL_REASON_SWITCH,
-	[REASON_STT] FST_CS_PVAL_REASON_STT,
-	[REASON_REJECT] FST_CS_PVAL_REASON_REJECT,
-	[REASON_ERROR_PARAMS] FST_CS_PVAL_REASON_ERROR_PARAMS,
-	[REASON_RESET] FST_CS_PVAL_REASON_RESET,
-	[REASON_DETACH_IFACE] FST_CS_PVAL_REASON_DETACH_IFACE,
-};
-
-static const char *session_state_names[] = {
-	[FST_SESSION_STATE_INITIAL] FST_CS_PVAL_STATE_INITIAL,
-	[FST_SESSION_STATE_SETUP_COMPLETION] FST_CS_PVAL_STATE_SETUP_COMPLETION,
-	[FST_SESSION_STATE_TRANSITION_DONE] FST_CS_PVAL_STATE_TRANSITION_DONE,
-	[FST_SESSION_STATE_TRANSITION_CONFIRMED]
-	FST_CS_PVAL_STATE_TRANSITION_CONFIRMED,
-};
-
-
-/* helpers */
-const char * fst_get_str_name(unsigned index, const char *names[],
-			      size_t names_size)
-{
-	if (index >= names_size || !names[index])
-		return FST_NAME_UNKNOWN;
-	return names[index];
-}
-
-
-const char * fst_session_event_type_name(enum fst_event_type event)
-{
-	return fst_get_str_name(event, session_event_names,
-				ARRAY_SIZE(session_event_names));
-}
-
-
-const char * fst_reason_name(enum fst_reason reason)
-{
-	return fst_get_str_name(reason, reason_names, ARRAY_SIZE(reason_names));
-}
-
-
-const char * fst_session_state_name(enum fst_session_state state)
-{
-	return fst_get_str_name(state, session_state_names,
-				ARRAY_SIZE(session_state_names));
-}
diff --git a/src/fst/fst_ctrl_aux.h b/src/fst/fst_ctrl_aux.h
deleted file mode 100644
index e2133f5..0000000
--- a/src/fst/fst_ctrl_aux.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * FST module - miscellaneous definitions
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef FST_CTRL_AUX_H
-#define FST_CTRL_AUX_H
-
-#include "common/defs.h"
-
-/* FST module control interface API */
-#define FST_INVALID_SESSION_ID ((u32) -1)
-#define FST_MAX_GROUP_ID_SIZE   32
-#define FST_MAX_INTERFACE_SIZE  32
-
-enum fst_session_state {
-	FST_SESSION_STATE_INITIAL,
-	FST_SESSION_STATE_SETUP_COMPLETION,
-	FST_SESSION_STATE_TRANSITION_DONE,
-	FST_SESSION_STATE_TRANSITION_CONFIRMED,
-	FST_SESSION_STATE_LAST
-};
-
-enum fst_event_type {
-	EVENT_FST_IFACE_STATE_CHANGED,  /* An interface has been either attached
-					 * to or detached from an FST group */
-	EVENT_FST_ESTABLISHED,          /* FST Session has been established */
-	EVENT_FST_SETUP,                /* FST Session request received */
-	EVENT_FST_SESSION_STATE_CHANGED,/* FST Session state has been changed */
-	EVENT_PEER_STATE_CHANGED        /* FST related generic event occurred,
-					 * see struct fst_hostap_event_data for
-					 *  more info */
-};
-
-enum fst_initiator {
-	FST_INITIATOR_UNDEFINED,
-	FST_INITIATOR_LOCAL,
-	FST_INITIATOR_REMOTE,
-};
-
-union fst_event_extra {
-	struct fst_event_extra_iface_state {
-		Boolean attached;
-		char ifname[FST_MAX_INTERFACE_SIZE];
-		char group_id[FST_MAX_GROUP_ID_SIZE];
-	} iface_state; /* for EVENT_FST_IFACE_STATE_CHANGED */
-	struct fst_event_extra_peer_state {
-		Boolean connected;
-		char ifname[FST_MAX_INTERFACE_SIZE];
-		u8 addr[ETH_ALEN];
-	} peer_state; /* for EVENT_PEER_STATE_CHANGED */
-	struct fst_event_extra_session_state {
-		enum fst_session_state old_state;
-		enum fst_session_state new_state;
-		union fst_session_state_switch_extra {
-			struct {
-				enum fst_reason {
-					REASON_TEARDOWN,
-					REASON_SETUP,
-					REASON_SWITCH,
-					REASON_STT,
-					REASON_REJECT,
-					REASON_ERROR_PARAMS,
-					REASON_RESET,
-					REASON_DETACH_IFACE,
-				} reason;
-				u8 reject_code; /* REASON_REJECT */
-				/* REASON_SWITCH,
-				 * REASON_TEARDOWN,
-				 * REASON_REJECT
-				 */
-				enum fst_initiator initiator;
-			} to_initial;
-		} extra;
-	} session_state; /* for EVENT_FST_SESSION_STATE_CHANGED */
-};
-
-/* helpers - prints enum in string form */
-#define FST_NAME_UNKNOWN "UNKNOWN"
-
-const char * fst_get_str_name(unsigned index, const char *names[],
-			      size_t names_size);
-
-const char * fst_session_event_type_name(enum fst_event_type);
-const char * fst_reason_name(enum fst_reason reason);
-const char * fst_session_state_name(enum fst_session_state state);
-
-#endif /* FST_CTRL_AUX_H */
diff --git a/src/fst/fst_ctrl_defs.h b/src/fst/fst_ctrl_defs.h
deleted file mode 100644
index 6735389..0000000
--- a/src/fst/fst_ctrl_defs.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * FST module - shared Control interface definitions
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef FST_CTRL_DEFS_H
-#define FST_CTRL_DEFS_H
-
-/* Undefined value */
-#define FST_CTRL_PVAL_NONE                     "NONE"
-
-/* FST-ATTACH parameters */
-#define FST_ATTACH_CMD_PNAME_LLT      "llt"      /* pval = desired LLT */
-#define FST_ATTACH_CMD_PNAME_PRIORITY "priority" /* pval = desired priority */
-
-/* FST-MANAGER parameters */
-/* FST Session states */
-#define FST_CS_PVAL_STATE_INITIAL              "INITIAL"
-#define FST_CS_PVAL_STATE_SETUP_COMPLETION     "SETUP_COMPLETION"
-#define FST_CS_PVAL_STATE_TRANSITION_DONE      "TRANSITION_DONE"
-#define FST_CS_PVAL_STATE_TRANSITION_CONFIRMED "TRANSITION_CONFIRMED"
-
-/* FST Session reset reasons */
-#define FST_CS_PVAL_REASON_TEARDOWN     "REASON_TEARDOWN"
-#define FST_CS_PVAL_REASON_SETUP        "REASON_SETUP"
-#define FST_CS_PVAL_REASON_SWITCH       "REASON_SWITCH"
-#define FST_CS_PVAL_REASON_STT          "REASON_STT"
-#define FST_CS_PVAL_REASON_REJECT       "REASON_REJECT"
-#define FST_CS_PVAL_REASON_ERROR_PARAMS "REASON_ERROR_PARAMS"
-#define FST_CS_PVAL_REASON_RESET        "REASON_RESET"
-#define FST_CS_PVAL_REASON_DETACH_IFACE "REASON_DETACH_IFACE"
-
-/* FST Session responses */
-#define FST_CS_PVAL_RESPONSE_ACCEPT "ACCEPT"
-#define FST_CS_PVAL_RESPONSE_REJECT "REJECT"
-
-/* FST Session action initiator */
-#define FST_CS_PVAL_INITIATOR_LOCAL  "LOCAL"
-#define FST_CS_PVAL_INITIATOR_REMOTE "REMOTE"
-
-/* FST-CLI subcommands and parameter names */
-#define FST_CMD_LIST_GROUPS      "list_groups"
-#define FST_CMD_LIST_IFACES      "list_ifaces"
-#define FST_CMD_IFACE_PEERS      "iface_peers"
-#define FST_CMD_GET_PEER_MBIES   "get_peer_mbies"
-#define FST_CMD_LIST_SESSIONS    "list_sessions"
-#define FST_CMD_SESSION_ADD      "session_add"
-#define FST_CMD_SESSION_REMOVE   "session_remove"
-#define FST_CMD_SESSION_GET      "session_get"
-#define FST_CSG_PNAME_OLD_PEER_ADDR  "old_peer_addr" /* pval = address string */
-#define FST_CSG_PNAME_NEW_PEER_ADDR  "new_peer_addr" /* pval = address string */
-#define FST_CSG_PNAME_OLD_IFNAME "old_ifname" /* pval = ifname */
-#define FST_CSG_PNAME_NEW_IFNAME "new_ifname" /* pval = ifname */
-#define FST_CSG_PNAME_LLT        "llt"        /* pval = numeric llt value */
-#define FST_CSG_PNAME_STATE      "state"      /* pval = FST_CS_PVAL_STATE_... */
-#define FST_CMD_SESSION_SET      "session_set"
-#define FST_CSS_PNAME_OLD_PEER_ADDR  FST_CSG_PNAME_OLD_PEER_ADDR
-#define FST_CSS_PNAME_NEW_PEER_ADDR  FST_CSG_PNAME_NEW_PEER_ADDR
-#define FST_CSS_PNAME_OLD_IFNAME     FST_CSG_PNAME_OLD_IFNAME
-#define FST_CSS_PNAME_NEW_IFNAME     FST_CSG_PNAME_NEW_IFNAME
-#define FST_CSS_PNAME_LLT            FST_CSG_PNAME_LLT
-#define FST_CMD_SESSION_INITIATE "session_initiate"
-#define FST_CMD_SESSION_RESPOND  "session_respond"
-#define FST_CMD_SESSION_TRANSFER "session_transfer"
-#define FST_CMD_SESSION_TEARDOWN "session_teardown"
-
-#ifdef CONFIG_FST_TEST
-#define FST_CTR_PVAL_BAD_NEW_BAND        "bad_new_band"
-
-#define FST_CMD_TEST_REQUEST    "test_request"
-#define FST_CTR_IS_SUPPORTED        "is_supported"
-#define FST_CTR_SEND_SETUP_REQUEST  "send_setup_request"
-#define FST_CTR_SEND_SETUP_RESPONSE "send_setup_response"
-#define FST_CTR_SEND_ACK_REQUEST    "send_ack_request"
-#define FST_CTR_SEND_ACK_RESPONSE   "send_ack_response"
-#define FST_CTR_SEND_TEAR_DOWN      "send_tear_down"
-#define FST_CTR_GET_FSTS_ID         "get_fsts_id"
-#define FST_CTR_GET_LOCAL_MBIES     "get_local_mbies"
-#endif /* CONFIG_FST_TEST */
-
-/* Events */
-#define FST_CTRL_EVENT_IFACE "FST-EVENT-IFACE"
-#define FST_CEI_PNAME_IFNAME       "ifname"
-#define FST_CEI_PNAME_GROUP        "group"
-#define FST_CEI_PNAME_ATTACHED     "attached"
-#define FST_CEI_PNAME_DETACHED     "detached"
-#define FST_CTRL_EVENT_PEER "FST-EVENT-PEER"
-#define FST_CEP_PNAME_IFNAME       "ifname"
-#define FST_CEP_PNAME_ADDR         "peer_addr"
-#define FST_CEP_PNAME_CONNECTED    "connected"
-#define FST_CEP_PNAME_DISCONNECTED "disconnected"
-#define FST_CTRL_EVENT_SESSION "FST-EVENT-SESSION"
-#define FST_CES_PNAME_SESSION_ID "session_id"
-#define FST_CES_PNAME_EVT_TYPE   "event_type"
-#define FST_PVAL_EVT_TYPE_SESSION_STATE "EVENT_FST_SESSION_STATE"
-/* old_state/new_state: pval = FST_CS_PVAL_STATE_... */
-#define FST_CES_PNAME_OLD_STATE   "old_state"
-#define FST_CES_PNAME_NEW_STATE   "new_state"
-#define FST_CES_PNAME_REASON      "reason" /* pval = FST_CS_PVAL_REASON_... */
-#define FST_CES_PNAME_REJECT_CODE "reject_code" /* pval = u8 code */
-/* pval = FST_CS_PVAL_INITIATOR_... */
-#define FST_CES_PNAME_INITIATOR   "initiator"
-#define FST_PVAL_EVT_TYPE_ESTABLISHED "EVENT_FST_ESTABLISHED"
-#define FST_PVAL_EVT_TYPE_SETUP "EVENT_FST_SETUP"
-
-#endif /* FST_CTRL_DEFS_H */
diff --git a/src/fst/fst_ctrl_iface.c b/src/fst/fst_ctrl_iface.c
deleted file mode 100644
index 98ece9f..0000000
--- a/src/fst/fst_ctrl_iface.c
+++ /dev/null
@@ -1,948 +0,0 @@
-/*
- * FST module - Control Interface implementation
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "utils/includes.h"
-#include "utils/common.h"
-#include "common/defs.h"
-#include "list.h"
-#include "fst/fst.h"
-#include "fst/fst_internal.h"
-#include "fst_ctrl_defs.h"
-#include "fst_ctrl_iface.h"
-
-
-static struct fst_group * get_fst_group_by_id(const char *id)
-{
-	struct fst_group *g;
-
-	foreach_fst_group(g) {
-		const char *group_id = fst_group_get_id(g);
-
-		if (os_strncmp(group_id, id, os_strlen(group_id)) == 0)
-			return g;
-	}
-
-	return NULL;
-}
-
-
-/* notifications */
-static Boolean format_session_state_extra(const union fst_event_extra *extra,
-					  char *buffer, size_t size)
-{
-	int len;
-	char reject_str[32] = FST_CTRL_PVAL_NONE;
-	const char *initiator = FST_CTRL_PVAL_NONE;
-	const struct fst_event_extra_session_state *ss;
-
-	ss = &extra->session_state;
-	if (ss->new_state != FST_SESSION_STATE_INITIAL)
-		return TRUE;
-
-	switch (ss->extra.to_initial.reason) {
-	case REASON_REJECT:
-		if (ss->extra.to_initial.reject_code != WLAN_STATUS_SUCCESS)
-			os_snprintf(reject_str, sizeof(reject_str), "%u",
-				    ss->extra.to_initial.reject_code);
-		/* no break */
-	case REASON_TEARDOWN:
-	case REASON_SWITCH:
-		switch (ss->extra.to_initial.initiator) {
-		case FST_INITIATOR_LOCAL:
-			initiator = FST_CS_PVAL_INITIATOR_LOCAL;
-			break;
-		case FST_INITIATOR_REMOTE:
-			initiator = FST_CS_PVAL_INITIATOR_REMOTE;
-			break;
-		default:
-			break;
-		}
-		break;
-	default:
-		break;
-	}
-
-	len = os_snprintf(buffer, size,
-			  FST_CES_PNAME_REASON "=%s "
-			  FST_CES_PNAME_REJECT_CODE "=%s "
-			  FST_CES_PNAME_INITIATOR "=%s",
-			  fst_reason_name(ss->extra.to_initial.reason),
-			  reject_str, initiator);
-
-	return !os_snprintf_error(size, len);
-}
-
-
-static void fst_ctrl_iface_notify(struct fst_iface *f, u32 session_id,
-				  enum fst_event_type event_type,
-				  const union fst_event_extra *extra)
-{
-	struct fst_group *g;
-	char extra_str[128] = "";
-	const struct fst_event_extra_session_state *ss;
-	const struct fst_event_extra_iface_state *is;
-	const struct fst_event_extra_peer_state *ps;
-
-	/*
-	 * FST can use any of interface objects as it only sends messages
-	 * on global Control Interface, so we just pick the 1st one.
-	 */
-
-	if (!f) {
-		foreach_fst_group(g) {
-			f = fst_group_first_iface(g);
-			if (f)
-				break;
-		}
-		if (!f)
-			return;
-	}
-
-	WPA_ASSERT(f->iface_obj.ctx);
-
-	switch (event_type) {
-	case EVENT_FST_IFACE_STATE_CHANGED:
-		if (!extra)
-			return;
-		is = &extra->iface_state;
-		wpa_msg_global_only(f->iface_obj.ctx, MSG_INFO,
-				    FST_CTRL_EVENT_IFACE " %s "
-				    FST_CEI_PNAME_IFNAME "=%s "
-				    FST_CEI_PNAME_GROUP "=%s",
-				    is->attached ? FST_CEI_PNAME_ATTACHED :
-				    FST_CEI_PNAME_DETACHED,
-				    is->ifname, is->group_id);
-		break;
-	case EVENT_PEER_STATE_CHANGED:
-		if (!extra)
-			return;
-		ps = &extra->peer_state;
-		wpa_msg_global_only(fst_iface_get_wpa_obj_ctx(f), MSG_INFO,
-				    FST_CTRL_EVENT_PEER " %s "
-				    FST_CEP_PNAME_IFNAME "=%s "
-				    FST_CEP_PNAME_ADDR "=" MACSTR,
-				    ps->connected ? FST_CEP_PNAME_CONNECTED :
-				    FST_CEP_PNAME_DISCONNECTED,
-				    ps->ifname, MAC2STR(ps->addr));
-		break;
-	case EVENT_FST_SESSION_STATE_CHANGED:
-		if (!extra)
-			return;
-		if (!format_session_state_extra(extra, extra_str,
-						sizeof(extra_str))) {
-			fst_printf(MSG_ERROR,
-				   "CTRL: Cannot format STATE_CHANGE extra");
-			extra_str[0] = 0;
-		}
-		ss = &extra->session_state;
-		wpa_msg_global_only(fst_iface_get_wpa_obj_ctx(f), MSG_INFO,
-				    FST_CTRL_EVENT_SESSION " "
-				    FST_CES_PNAME_SESSION_ID "=%u "
-				    FST_CES_PNAME_EVT_TYPE "=%s "
-				    FST_CES_PNAME_OLD_STATE "=%s "
-				    FST_CES_PNAME_NEW_STATE "=%s %s",
-				    session_id,
-				    fst_session_event_type_name(event_type),
-				    fst_session_state_name(ss->old_state),
-				    fst_session_state_name(ss->new_state),
-				    extra_str);
-		break;
-	case EVENT_FST_ESTABLISHED:
-	case EVENT_FST_SETUP:
-		wpa_msg_global_only(fst_iface_get_wpa_obj_ctx(f), MSG_INFO,
-				    FST_CTRL_EVENT_SESSION " "
-				    FST_CES_PNAME_SESSION_ID "=%u "
-				    FST_CES_PNAME_EVT_TYPE "=%s",
-				    session_id,
-				    fst_session_event_type_name(event_type));
-		break;
-	}
-}
-
-
-/* command processors */
-
-/* fst session_get */
-static int session_get(const char *session_id, char *buf, size_t buflen)
-{
-	struct fst_session *s;
-	struct fst_iface *new_iface, *old_iface;
-	const u8 *old_peer_addr, *new_peer_addr;
-	u32 id;
-
-	id = strtoul(session_id, NULL, 0);
-
-	s = fst_session_get_by_id(id);
-	if (!s) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find session %u", id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	old_peer_addr = fst_session_get_peer_addr(s, TRUE);
-	new_peer_addr = fst_session_get_peer_addr(s, FALSE);
-	new_iface = fst_session_get_iface(s, FALSE);
-	old_iface = fst_session_get_iface(s, TRUE);
-
-	return os_snprintf(buf, buflen,
-			   FST_CSG_PNAME_OLD_PEER_ADDR "=" MACSTR "\n"
-			   FST_CSG_PNAME_NEW_PEER_ADDR "=" MACSTR "\n"
-			   FST_CSG_PNAME_NEW_IFNAME "=%s\n"
-			   FST_CSG_PNAME_OLD_IFNAME "=%s\n"
-			   FST_CSG_PNAME_LLT "=%u\n"
-			   FST_CSG_PNAME_STATE "=%s\n",
-			   MAC2STR(old_peer_addr),
-			   MAC2STR(new_peer_addr),
-			   new_iface ? fst_iface_get_name(new_iface) :
-			   FST_CTRL_PVAL_NONE,
-			   old_iface ? fst_iface_get_name(old_iface) :
-			   FST_CTRL_PVAL_NONE,
-			   fst_session_get_llt(s),
-			   fst_session_state_name(fst_session_get_state(s)));
-}
-
-
-/* fst session_set */
-static int session_set(const char *session_id, char *buf, size_t buflen)
-{
-	struct fst_session *s;
-	char *p, *q;
-	u32 id;
-	int ret;
-
-	id = strtoul(session_id, &p, 0);
-
-	s = fst_session_get_by_id(id);
-	if (!s) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find session %u", id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	if (*p != ' ' || !(q = os_strchr(p + 1, '=')))
-		return os_snprintf(buf, buflen, "FAIL\n");
-	p++;
-
-	if (os_strncasecmp(p, FST_CSS_PNAME_OLD_IFNAME, q - p) == 0) {
-		ret = fst_session_set_str_ifname(s, q + 1, TRUE);
-	} else if (os_strncasecmp(p, FST_CSS_PNAME_NEW_IFNAME, q - p) == 0) {
-		ret = fst_session_set_str_ifname(s, q + 1, FALSE);
-	} else if (os_strncasecmp(p, FST_CSS_PNAME_OLD_PEER_ADDR, q - p) == 0) {
-		ret = fst_session_set_str_peer_addr(s, q + 1, TRUE);
-	} else if (os_strncasecmp(p, FST_CSS_PNAME_NEW_PEER_ADDR, q - p) == 0) {
-		ret = fst_session_set_str_peer_addr(s, q + 1, FALSE);
-	} else if (os_strncasecmp(p, FST_CSS_PNAME_LLT, q - p) == 0) {
-		ret = fst_session_set_str_llt(s, q + 1);
-	} else {
-		fst_printf(MSG_ERROR, "CTRL: Unknown parameter: %s", p);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	return os_snprintf(buf, buflen, "%s\n", ret ? "FAIL" : "OK");
-}
-
-
-/* fst session_add/remove */
-static int session_add(const char *group_id, char *buf, size_t buflen)
-{
-	struct fst_group *g;
-	struct fst_session *s;
-
-	g = get_fst_group_by_id(group_id);
-	if (!g) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find group '%s'",
-			   group_id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	s = fst_session_create(g);
-	if (!s) {
-		fst_printf(MSG_ERROR,
-			   "CTRL: Cannot create session for group '%s'",
-			   group_id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	return os_snprintf(buf, buflen, "%u\n", fst_session_get_id(s));
-}
-
-
-static int session_remove(const char *session_id, char *buf, size_t buflen)
-{
-	struct fst_session *s;
-	struct fst_group *g;
-	u32 id;
-
-	id = strtoul(session_id, NULL, 0);
-
-	s = fst_session_get_by_id(id);
-	if (!s) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find session %u", id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	g = fst_session_get_group(s);
-	fst_session_reset(s);
-	fst_session_delete(s);
-	fst_group_delete_if_empty(g);
-
-	return os_snprintf(buf, buflen, "OK\n");
-}
-
-
-/* fst session_initiate */
-static int session_initiate(const char *session_id, char *buf, size_t buflen)
-{
-	struct fst_session *s;
-	u32 id;
-
-	id = strtoul(session_id, NULL, 0);
-
-	s = fst_session_get_by_id(id);
-	if (!s) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find session %u", id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	if (fst_session_initiate_setup(s)) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot initiate session %u", id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	return os_snprintf(buf, buflen, "OK\n");
-}
-
-
-/* fst session_respond */
-static int session_respond(const char *session_id, char *buf, size_t buflen)
-{
-	struct fst_session *s;
-	char *p;
-	u32 id;
-	u8 status_code;
-
-	id = strtoul(session_id, &p, 0);
-
-	s = fst_session_get_by_id(id);
-	if (!s) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find session %u", id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	if (*p != ' ')
-		return os_snprintf(buf, buflen, "FAIL\n");
-	p++;
-
-	if (!os_strcasecmp(p, FST_CS_PVAL_RESPONSE_ACCEPT)) {
-		status_code = WLAN_STATUS_SUCCESS;
-	} else if (!os_strcasecmp(p, FST_CS_PVAL_RESPONSE_REJECT)) {
-		status_code = WLAN_STATUS_PENDING_ADMITTING_FST_SESSION;
-	} else {
-		fst_printf(MSG_WARNING,
-			   "CTRL: session %u: unknown response status: %s",
-			   id, p);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	if (fst_session_respond(s, status_code)) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot respond to session %u",
-			   id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	fst_printf(MSG_INFO, "CTRL: session %u responded", id);
-
-	return os_snprintf(buf, buflen, "OK\n");
-}
-
-
-/* fst session_transfer */
-static int session_transfer(const char *session_id, char *buf, size_t buflen)
-{
-	struct fst_session *s;
-	u32 id;
-
-	id = strtoul(session_id, NULL, 0);
-
-	s = fst_session_get_by_id(id);
-	if (!s) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find session %u", id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	if (fst_session_initiate_switch(s)) {
-		fst_printf(MSG_WARNING,
-			   "CTRL: Cannot initiate ST for session %u", id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	return os_snprintf(buf, buflen, "OK\n");
-}
-
-
-/* fst session_teardown */
-static int session_teardown(const char *session_id, char *buf, size_t buflen)
-{
-	struct fst_session *s;
-	u32 id;
-
-	id = strtoul(session_id, NULL, 0);
-
-	s = fst_session_get_by_id(id);
-	if (!s) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find session %u", id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	if (fst_session_tear_down_setup(s)) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot tear down session %u",
-			   id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	return os_snprintf(buf, buflen, "OK\n");
-}
-
-
-#ifdef CONFIG_FST_TEST
-/* fst test_request */
-static int test_request(const char *request, char *buf, size_t buflen)
-{
-	const char *p = request;
-	int ret;
-
-	if (!os_strncasecmp(p, FST_CTR_SEND_SETUP_REQUEST,
-			    os_strlen(FST_CTR_SEND_SETUP_REQUEST))) {
-		ret = fst_test_req_send_fst_request(
-			p + os_strlen(FST_CTR_SEND_SETUP_REQUEST));
-	} else if (!os_strncasecmp(p, FST_CTR_SEND_SETUP_RESPONSE,
-				   os_strlen(FST_CTR_SEND_SETUP_RESPONSE))) {
-		ret = fst_test_req_send_fst_response(
-			p + os_strlen(FST_CTR_SEND_SETUP_RESPONSE));
-	} else if (!os_strncasecmp(p, FST_CTR_SEND_ACK_REQUEST,
-				   os_strlen(FST_CTR_SEND_ACK_REQUEST))) {
-		ret = fst_test_req_send_ack_request(
-			p + os_strlen(FST_CTR_SEND_ACK_REQUEST));
-	} else if (!os_strncasecmp(p, FST_CTR_SEND_ACK_RESPONSE,
-				   os_strlen(FST_CTR_SEND_ACK_RESPONSE))) {
-		ret = fst_test_req_send_ack_response(
-			p + os_strlen(FST_CTR_SEND_ACK_RESPONSE));
-	} else if (!os_strncasecmp(p, FST_CTR_SEND_TEAR_DOWN,
-				   os_strlen(FST_CTR_SEND_TEAR_DOWN))) {
-		ret = fst_test_req_send_tear_down(
-			p + os_strlen(FST_CTR_SEND_TEAR_DOWN));
-	} else if (!os_strncasecmp(p, FST_CTR_GET_FSTS_ID,
-				   os_strlen(FST_CTR_GET_FSTS_ID))) {
-		u32 fsts_id = fst_test_req_get_fsts_id(
-			p + os_strlen(FST_CTR_GET_FSTS_ID));
-		if (fsts_id != FST_FSTS_ID_NOT_FOUND)
-			return os_snprintf(buf, buflen, "%u\n", fsts_id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	} else if (!os_strncasecmp(p, FST_CTR_GET_LOCAL_MBIES,
-				   os_strlen(FST_CTR_GET_LOCAL_MBIES))) {
-		return fst_test_req_get_local_mbies(
-			p + os_strlen(FST_CTR_GET_LOCAL_MBIES), buf, buflen);
-	} else if (!os_strncasecmp(p, FST_CTR_IS_SUPPORTED,
-				   os_strlen(FST_CTR_IS_SUPPORTED))) {
-		ret = 0;
-	} else {
-		fst_printf(MSG_ERROR, "CTRL: Unknown parameter: %s", p);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	return os_snprintf(buf, buflen, "%s\n", ret ? "FAIL" : "OK");
-}
-#endif /* CONFIG_FST_TEST */
-
-
-/* fst list_sessions */
-struct list_sessions_cb_ctx {
-	char *buf;
-	size_t buflen;
-	size_t reply_len;
-};
-
-
-static void list_session_enum_cb(struct fst_group *g, struct fst_session *s,
-				 void *ctx)
-{
-	struct list_sessions_cb_ctx *c = ctx;
-	int ret;
-
-	ret = os_snprintf(c->buf, c->buflen, " %u", fst_session_get_id(s));
-
-	c->buf += ret;
-	c->buflen -= ret;
-	c->reply_len += ret;
-}
-
-
-static int list_sessions(const char *group_id, char *buf, size_t buflen)
-{
-	struct list_sessions_cb_ctx ctx;
-	struct fst_group *g;
-
-	g = get_fst_group_by_id(group_id);
-	if (!g) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find group '%s'",
-			   group_id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	ctx.buf = buf;
-	ctx.buflen = buflen;
-	ctx.reply_len = 0;
-
-	fst_session_enum(g, list_session_enum_cb, &ctx);
-
-	ctx.reply_len += os_snprintf(buf + ctx.reply_len, ctx.buflen, "\n");
-
-	return ctx.reply_len;
-}
-
-
-/* fst iface_peers */
-static int iface_peers(const char *group_id, char *buf, size_t buflen)
-{
-	const char *ifname;
-	struct fst_group *g;
-	struct fst_iface *f;
-	struct fst_get_peer_ctx *ctx;
-	const u8 *addr;
-	unsigned found = 0;
-	int ret = 0;
-
-	g = get_fst_group_by_id(group_id);
-	if (!g) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find group '%s'",
-			   group_id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	ifname = os_strchr(group_id, ' ');
-	if (!ifname)
-		return os_snprintf(buf, buflen, "FAIL\n");
-	ifname++;
-
-	foreach_fst_group_iface(g, f) {
-		const char *in = fst_iface_get_name(f);
-
-		if (os_strncmp(ifname, in, os_strlen(in)) == 0) {
-			found = 1;
-			break;
-		}
-	}
-
-	if (!found)
-		return os_snprintf(buf, buflen, "FAIL\n");
-
-	addr = fst_iface_get_peer_first(f, &ctx, FALSE);
-	for (; addr != NULL; addr = fst_iface_get_peer_next(f, &ctx, FALSE)) {
-		int res;
-
-		res = os_snprintf(buf + ret, buflen - ret, MACSTR "\n",
-				  MAC2STR(addr));
-		if (os_snprintf_error(buflen - ret, res))
-			break;
-		ret += res;
-	}
-
-	return ret;
-}
-
-
-static int get_peer_mbies(const char *params, char *buf, size_t buflen)
-{
-	char *endp;
-	char ifname[FST_MAX_INTERFACE_SIZE];
-	u8 peer_addr[ETH_ALEN];
-	struct fst_group *g;
-	struct fst_iface *iface = NULL;
-	const struct wpabuf *mbies;
-
-	if (fst_read_next_text_param(params, ifname, sizeof(ifname), &endp) ||
-	    !*ifname)
-		goto problem;
-
-	while (isspace(*endp))
-		endp++;
-	if (fst_read_peer_addr(endp, peer_addr))
-		goto problem;
-
-	foreach_fst_group(g) {
-		iface = fst_group_get_iface_by_name(g, ifname);
-		if (iface)
-			break;
-	}
-	if (!iface)
-		goto problem;
-
-	mbies = fst_iface_get_peer_mb_ie(iface, peer_addr);
-	if (!mbies)
-		goto problem;
-
-	return wpa_snprintf_hex(buf, buflen, wpabuf_head(mbies),
-				wpabuf_len(mbies));
-
-problem:
-	return os_snprintf(buf, buflen, "FAIL\n");
-}
-
-
-/* fst list_ifaces */
-static int list_ifaces(const char *group_id, char *buf, size_t buflen)
-{
-	struct fst_group *g;
-	struct fst_iface *f;
-	int ret = 0;
-
-	g = get_fst_group_by_id(group_id);
-	if (!g) {
-		fst_printf(MSG_WARNING, "CTRL: Cannot find group '%s'",
-			   group_id);
-		return os_snprintf(buf, buflen, "FAIL\n");
-	}
-
-	foreach_fst_group_iface(g, f) {
-		int res;
-		const u8 *iface_addr = fst_iface_get_addr(f);
-
-		res = os_snprintf(buf + ret, buflen - ret,
-				  "%s|" MACSTR "|%u|%u\n",
-				  fst_iface_get_name(f),
-				  MAC2STR(iface_addr),
-				  fst_iface_get_priority(f),
-				  fst_iface_get_llt(f));
-		if (os_snprintf_error(buflen - ret, res))
-			break;
-		ret += res;
-	}
-
-	return ret;
-}
-
-
-/* fst list_groups */
-static int list_groups(const char *cmd, char *buf, size_t buflen)
-{
-	struct fst_group *g;
-	int ret = 0;
-
-	foreach_fst_group(g) {
-		int res;
-
-		res = os_snprintf(buf + ret, buflen - ret, "%s\n",
-				  fst_group_get_id(g));
-		if (os_snprintf_error(buflen - ret, res))
-			break;
-		ret += res;
-	}
-
-	return ret;
-}
-
-
-static const char * band_freq(enum mb_band_id band)
-{
-	static const char *band_names[] = {
-		[MB_BAND_ID_WIFI_2_4GHZ] "2.4GHZ",
-		[MB_BAND_ID_WIFI_5GHZ] "5GHZ",
-		[MB_BAND_ID_WIFI_60GHZ] "60GHZ",
-	};
-
-	return fst_get_str_name(band, band_names, ARRAY_SIZE(band_names));
-}
-
-
-static int print_band(unsigned num, struct fst_iface *iface, const u8 *addr,
-		      char *buf, size_t buflen)
-{
-	const struct wpabuf *wpabuf;
-	enum hostapd_hw_mode hw_mode;
-	u8 channel;
-	int ret = 0;
-
-	fst_iface_get_channel_info(iface, &hw_mode, &channel);
-
-	ret += os_snprintf(buf + ret, buflen - ret, "band%u_frequency=%s\n",
-			   num, band_freq(fst_hw_mode_to_band(hw_mode)));
-	ret += os_snprintf(buf + ret, buflen - ret, "band%u_iface=%s\n",
-			   num, fst_iface_get_name(iface));
-	wpabuf = fst_iface_get_peer_mb_ie(iface, addr);
-	if (wpabuf) {
-		ret += os_snprintf(buf + ret, buflen - ret, "band%u_mb_ies=",
-				   num);
-		ret += wpa_snprintf_hex(buf + ret, buflen - ret,
-					wpabuf_head(wpabuf),
-					wpabuf_len(wpabuf));
-		ret += os_snprintf(buf + ret, buflen - ret, "\n");
-	}
-	ret += os_snprintf(buf + ret, buflen - ret, "band%u_fst_group_id=%s\n",
-			   num, fst_iface_get_group_id(iface));
-	ret += os_snprintf(buf + ret, buflen - ret, "band%u_fst_priority=%u\n",
-			   num, fst_iface_get_priority(iface));
-	ret += os_snprintf(buf + ret, buflen - ret, "band%u_fst_llt=%u\n",
-			   num, fst_iface_get_llt(iface));
-
-	return ret;
-}
-
-
-static void fst_ctrl_iface_on_iface_state_changed(struct fst_iface *i,
-						  Boolean attached)
-{
-	union fst_event_extra extra;
-
-	os_memset(&extra, 0, sizeof(extra));
-	extra.iface_state.attached = attached;
-	os_strlcpy(extra.iface_state.ifname, fst_iface_get_name(i),
-		   sizeof(extra.iface_state.ifname));
-	os_strlcpy(extra.iface_state.group_id, fst_iface_get_group_id(i),
-		   sizeof(extra.iface_state.group_id));
-
-	fst_ctrl_iface_notify(i, FST_INVALID_SESSION_ID,
-			      EVENT_FST_IFACE_STATE_CHANGED, &extra);
-}
-
-
-static int fst_ctrl_iface_on_iface_added(struct fst_iface *i)
-{
-	fst_ctrl_iface_on_iface_state_changed(i, TRUE);
-	return 0;
-}
-
-
-static void fst_ctrl_iface_on_iface_removed(struct fst_iface *i)
-{
-	fst_ctrl_iface_on_iface_state_changed(i, FALSE);
-}
-
-
-static void fst_ctrl_iface_on_event(enum fst_event_type event_type,
-				    struct fst_iface *i, struct fst_session *s,
-				    const union fst_event_extra *extra)
-{
-	u32 session_id = s ? fst_session_get_id(s) : FST_INVALID_SESSION_ID;
-
-	fst_ctrl_iface_notify(i, session_id, event_type, extra);
-}
-
-
-static const struct fst_ctrl ctrl_cli = {
-	.on_iface_added = fst_ctrl_iface_on_iface_added,
-	.on_iface_removed =  fst_ctrl_iface_on_iface_removed,
-	.on_event = fst_ctrl_iface_on_event,
-};
-
-const struct fst_ctrl *fst_ctrl_cli = &ctrl_cli;
-
-
-int fst_ctrl_iface_mb_info(const u8 *addr, char *buf, size_t buflen)
-{
-	struct fst_group *g;
-	struct fst_iface *f;
-	unsigned num = 0;
-	int ret = 0;
-
-	foreach_fst_group(g) {
-		foreach_fst_group_iface(g, f) {
-			if (fst_iface_is_connected(f, addr, TRUE)) {
-				ret += print_band(num++, f, addr,
-						  buf + ret, buflen - ret);
-			}
-		}
-	}
-
-	return ret;
-}
-
-
-/* fst ctrl processor */
-int fst_ctrl_iface_receive(const char *cmd, char *reply, size_t reply_size)
-{
-	static const struct fst_command {
-		const char *name;
-		unsigned has_param;
-		int (*process)(const char *group_id, char *buf, size_t buflen);
-	} commands[] = {
-		{ FST_CMD_LIST_GROUPS, 0, list_groups},
-		{ FST_CMD_LIST_IFACES, 1, list_ifaces},
-		{ FST_CMD_IFACE_PEERS, 1, iface_peers},
-		{ FST_CMD_GET_PEER_MBIES, 1, get_peer_mbies},
-		{ FST_CMD_LIST_SESSIONS, 1, list_sessions},
-		{ FST_CMD_SESSION_ADD, 1, session_add},
-		{ FST_CMD_SESSION_REMOVE, 1, session_remove},
-		{ FST_CMD_SESSION_GET, 1, session_get},
-		{ FST_CMD_SESSION_SET, 1, session_set},
-		{ FST_CMD_SESSION_INITIATE, 1, session_initiate},
-		{ FST_CMD_SESSION_RESPOND, 1, session_respond},
-		{ FST_CMD_SESSION_TRANSFER, 1, session_transfer},
-		{ FST_CMD_SESSION_TEARDOWN, 1, session_teardown},
-#ifdef CONFIG_FST_TEST
-		{ FST_CMD_TEST_REQUEST, 1, test_request },
-#endif /* CONFIG_FST_TEST */
-		{ NULL, 0, NULL }
-	};
-	const struct fst_command *c;
-	const char *p;
-	const char *temp;
-	Boolean non_spaces_found;
-
-	for (c = commands; c->name; c++) {
-		if (os_strncasecmp(cmd, c->name, os_strlen(c->name)) != 0)
-			continue;
-		p = cmd + os_strlen(c->name);
-		if (c->has_param) {
-			if (!isspace(p[0]))
-				return os_snprintf(reply, reply_size, "FAIL\n");
-			p++;
-			temp = p;
-			non_spaces_found = FALSE;
-			while (*temp) {
-				if (!isspace(*temp)) {
-					non_spaces_found = TRUE;
-					break;
-				}
-				temp++;
-			}
-			if (!non_spaces_found)
-				return os_snprintf(reply, reply_size, "FAIL\n");
-		}
-		return c->process(p, reply, reply_size);
-	}
-
-	return os_snprintf(reply, reply_size, "UNKNOWN FST COMMAND\n");
-}
-
-
-int fst_read_next_int_param(const char *params, Boolean *valid, char **endp)
-{
-	int ret = -1;
-	const char *curp;
-
-	*valid = FALSE;
-	*endp = (char *) params;
-	curp = params;
-	if (*curp) {
-		ret = (int) strtol(curp, endp, 0);
-		if (!**endp || isspace(**endp))
-			*valid = TRUE;
-	}
-
-	return ret;
-}
-
-
-int fst_read_next_text_param(const char *params, char *buf, size_t buflen,
-			     char **endp)
-{
-	size_t max_chars_to_copy;
-	char *cur_dest;
-
-	*endp = (char *) params;
-	while (isspace(**endp))
-		(*endp)++;
-	if (!**endp || buflen <= 1)
-		return -EINVAL;
-
-	max_chars_to_copy = buflen - 1;
-	/* We need 1 byte for the terminating zero */
-	cur_dest = buf;
-	while (**endp && !isspace(**endp) && max_chars_to_copy > 0) {
-		*cur_dest = **endp;
-		(*endp)++;
-		cur_dest++;
-		max_chars_to_copy--;
-	}
-	*cur_dest = 0;
-
-	return 0;
-}
-
-
-int fst_read_peer_addr(const char *mac, u8 *peer_addr)
-{
-	if (hwaddr_aton(mac, peer_addr)) {
-		fst_printf(MSG_WARNING, "Bad peer_mac %s: invalid addr string",
-			   mac);
-		return -1;
-	}
-
-	if (is_zero_ether_addr(peer_addr) ||
-	    is_multicast_ether_addr(peer_addr)) {
-		fst_printf(MSG_WARNING, "Bad peer_mac %s: not a unicast addr",
-			   mac);
-		return -1;
-	}
-
-	return 0;
-}
-
-
-int fst_parse_attach_command(const char *cmd, char *ifname, size_t ifname_size,
-			     struct fst_iface_cfg *cfg)
-{
-	char *pos;
-	char *endp;
-	Boolean is_valid;
-	int val;
-
-	if (fst_read_next_text_param(cmd, ifname, ifname_size, &endp) ||
-	    fst_read_next_text_param(endp, cfg->group_id, sizeof(cfg->group_id),
-				     &endp))
-		return -EINVAL;
-
-	cfg->llt = FST_DEFAULT_LLT_CFG_VALUE;
-	cfg->priority = 0;
-	pos = os_strstr(endp, FST_ATTACH_CMD_PNAME_LLT);
-	if (pos) {
-		pos += os_strlen(FST_ATTACH_CMD_PNAME_LLT);
-		if (*pos == '=') {
-			val = fst_read_next_int_param(pos + 1, &is_valid,
-						      &endp);
-			if (is_valid)
-				cfg->llt = val;
-		}
-	}
-	pos = os_strstr(endp, FST_ATTACH_CMD_PNAME_PRIORITY);
-	if (pos) {
-		pos += os_strlen(FST_ATTACH_CMD_PNAME_PRIORITY);
-		if (*pos == '=') {
-			val = fst_read_next_int_param(pos + 1, &is_valid,
-						      &endp);
-			if (is_valid)
-				cfg->priority = (u8) val;
-		}
-	}
-
-	return 0;
-}
-
-
-int fst_parse_detach_command(const char *cmd, char *ifname, size_t ifname_size)
-{
-	char *endp;
-
-	return fst_read_next_text_param(cmd, ifname, ifname_size, &endp);
-}
-
-
-int fst_iface_detach(const char *ifname)
-{
-	struct fst_group *g;
-
-	foreach_fst_group(g) {
-		struct fst_iface *f;
-
-		f = fst_group_get_iface_by_name(g, ifname);
-		if (f) {
-			fst_detach(f);
-			return 0;
-		}
-	}
-
-	return -EINVAL;
-}
diff --git a/src/fst/fst_ctrl_iface.h b/src/fst/fst_ctrl_iface.h
deleted file mode 100644
index 4d0cd9f..0000000
--- a/src/fst/fst_ctrl_iface.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * FST module - internal Control interface definitions
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef FST_CTRL_IFACE_H
-#define FST_CTRL_IFACE_H
-
-#include "fst/fst_ctrl_aux.h"
-
-#ifdef CONFIG_FST
-
-/* receiver */
-int fst_ctrl_iface_mb_info(const u8 *addr, char *buf, size_t buflen);
-
-int fst_ctrl_iface_receive(const char *txtaddr, char *buf, size_t buflen);
-
-extern const struct fst_ctrl *fst_ctrl_cli;
-
-#else /* CONFIG_FST */
-
-static inline int
-fst_ctrl_iface_mb_info(const u8 *addr, char *buf, size_t buflen)
-{
-	return 0;
-}
-
-#endif /* CONFIG_FST */
-
-int fst_read_next_int_param(const char *params, Boolean *valid, char **endp);
-int fst_read_next_text_param(const char *params, char *buf, size_t buflen,
-			     char **endp);
-int fst_read_peer_addr(const char *mac, u8 *peer_addr);
-
-struct fst_iface_cfg;
-
-int fst_parse_attach_command(const char *cmd, char *ifname, size_t ifname_size,
-			     struct fst_iface_cfg *cfg);
-int fst_parse_detach_command(const char *cmd, char *ifname, size_t ifname_size);
-int fst_iface_detach(const char *ifname);
-
-#endif /* CTRL_IFACE_FST_H */
diff --git a/src/fst/fst_defs.h b/src/fst/fst_defs.h
deleted file mode 100644
index 8ddcc61..0000000
--- a/src/fst/fst_defs.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * FST module - FST related definitions
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef IEEE_80211_FST_DEFS_H
-#define IEEE_80211_FST_DEFS_H
-
-/* IEEE Std 802.11ad */
-
-#define MB_STA_CHANNEL_ALL 0
-
-enum session_type {
-	SESSION_TYPE_BSS = 0, /*  Infrastructure BSS */
-	SESSION_TYPE_IBSS = 1,
-	SESSION_TYPE_DLS = 2,
-	SESSION_TYPE_TDLS = 3,
-	SESSION_TYPE_PBSS = 4
-};
-
-#define SESSION_CONTROL(session_type, switch_intent) \
-	(((u8) ((session_type) & 0x7)) | ((switch_intent) ? 0x10 : 0x00))
-
-#define GET_SESSION_CONTROL_TYPE(session_control) \
-	((u8) ((session_control) & 0x7))
-
-#define GET_SESSION_CONTROL_SWITCH_INTENT(session_control) \
-	(((session_control) & 0x10) >> 4)
-
-/* 8.4.2.147  Session Transition element */
-struct session_transition_ie {
-	u8 element_id;
-	u8 length;
-	u32 fsts_id;
-	u8 session_control;
-	u8 new_band_id;
-	u8 new_band_setup;
-	u8 new_band_op;
-	u8 old_band_id;
-	u8 old_band_setup;
-	u8 old_band_op;
-} STRUCT_PACKED;
-
-struct fst_setup_req {
-	u8 action;
-	u8 dialog_token;
-	u32 llt;
-	struct session_transition_ie stie;
-	/* Multi-band (optional) */
-	/* Wakeup Schedule (optional) */
-	/* Awake Window (optional) */
-	/* Switching Stream (optional) */
-} STRUCT_PACKED;
-
-struct fst_setup_res {
-	u8 action;
-	u8 dialog_token;
-	u8 status_code;
-	struct session_transition_ie stie;
-	/* Multi-band (optional) */
-	/* Wakeup Schedule (optional) */
-	/* Awake Window (optional) */
-	/* Switching Stream (optional) */
-	/* Timeout Interval (optional) */
-} STRUCT_PACKED;
-
-struct fst_ack_req {
-	u8 action;
-	u8 dialog_token;
-	u32 fsts_id;
-} STRUCT_PACKED;
-
-struct fst_ack_res {
-	u8 action;
-	u8 dialog_token;
-	u32 fsts_id;
-} STRUCT_PACKED;
-
-struct fst_tear_down {
-	u8 action;
-	u32 fsts_id;
-} STRUCT_PACKED;
-
-#endif /* IEEE_80211_FST_DEFS_H */
diff --git a/src/fst/fst_group.c b/src/fst/fst_group.c
deleted file mode 100644
index d6157b1..0000000
--- a/src/fst/fst_group.c
+++ /dev/null
@@ -1,437 +0,0 @@
-/*
- * FST module - FST group object implementation
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "utils/includes.h"
-#include "utils/common.h"
-#include "common/defs.h"
-#include "common/ieee802_11_defs.h"
-#include "common/ieee802_11_common.h"
-#include "drivers/driver.h"
-#include "fst/fst_internal.h"
-#include "fst/fst_defs.h"
-
-
-struct dl_list fst_global_groups_list;
-
-
-static void fst_dump_mb_ies(const char *group_id, const char *ifname,
-			    struct wpabuf *mbies)
-{
-	const u8 *p = wpabuf_head(mbies);
-	size_t s = wpabuf_len(mbies);
-
-	while (s >= 2) {
-		const struct multi_band_ie *mbie =
-			(const struct multi_band_ie *) p;
-		WPA_ASSERT(mbie->eid == WLAN_EID_MULTI_BAND);
-		WPA_ASSERT(2 + mbie->len >= sizeof(*mbie));
-
-		fst_printf(MSG_WARNING,
-			   "%s: %s: mb_ctrl=%u band_id=%u op_class=%u chan=%u bssid="
-			   MACSTR
-			   " beacon_int=%u tsf_offs=[%u %u %u %u %u %u %u %u] mb_cc=0x%02x tmout=%u",
-			   group_id, ifname,
-			   mbie->mb_ctrl, mbie->band_id, mbie->op_class,
-			   mbie->chan, MAC2STR(mbie->bssid), mbie->beacon_int,
-			   mbie->tsf_offs[0], mbie->tsf_offs[1],
-			   mbie->tsf_offs[2], mbie->tsf_offs[3],
-			   mbie->tsf_offs[4], mbie->tsf_offs[5],
-			   mbie->tsf_offs[6], mbie->tsf_offs[7],
-			   mbie->mb_connection_capability,
-			   mbie->fst_session_tmout);
-
-		p += 2 + mbie->len;
-		s -= 2 + mbie->len;
-	}
-}
-
-
-static void fst_fill_mb_ie(struct wpabuf *buf, const u8 *bssid,
-			   const u8 *own_addr, enum mb_band_id band, u8 channel)
-{
-	struct multi_band_ie *mbie;
-	size_t len = sizeof(*mbie);
-
-	if (own_addr)
-		len += ETH_ALEN;
-
-	mbie = wpabuf_put(buf, len);
-
-	os_memset(mbie, 0, len);
-
-	mbie->eid = WLAN_EID_MULTI_BAND;
-	mbie->len = len - 2;
-#ifdef HOSTAPD
-	mbie->mb_ctrl = MB_STA_ROLE_AP;
-	mbie->mb_connection_capability = MB_CONNECTION_CAPABILITY_AP;
-#else /* HOSTAPD */
-	mbie->mb_ctrl = MB_STA_ROLE_NON_PCP_NON_AP;
-	mbie->mb_connection_capability = 0;
-#endif /* HOSTAPD */
-	if (bssid)
-		os_memcpy(mbie->bssid, bssid, ETH_ALEN);
-	mbie->band_id = band;
-	mbie->op_class = 0;  /* means all */
-	mbie->chan = channel;
-	mbie->fst_session_tmout = FST_DEFAULT_SESSION_TIMEOUT_TU;
-
-	if (own_addr) {
-		mbie->mb_ctrl |= MB_CTRL_STA_MAC_PRESENT;
-		os_memcpy(&mbie[1], own_addr, ETH_ALEN);
-	}
-}
-
-
-static unsigned fst_fill_iface_mb_ies(struct fst_iface *f, struct wpabuf *buf)
-{
-	const  u8 *bssid;
-
-	bssid = fst_iface_get_bssid(f);
-	if (bssid) {
-		enum hostapd_hw_mode hw_mode;
-		u8 channel;
-
-		if (buf) {
-			fst_iface_get_channel_info(f, &hw_mode, &channel);
-			fst_fill_mb_ie(buf, bssid, fst_iface_get_addr(f),
-				       fst_hw_mode_to_band(hw_mode), channel);
-		}
-		return 1;
-	} else {
-		unsigned bands[MB_BAND_ID_WIFI_60GHZ + 1] = {};
-		struct hostapd_hw_modes *modes;
-		enum mb_band_id b;
-		int num_modes = fst_iface_get_hw_modes(f, &modes);
-		int ret = 0;
-
-		while (num_modes--) {
-			b = fst_hw_mode_to_band(modes->mode);
-			modes++;
-			if (b >= ARRAY_SIZE(bands) || bands[b]++)
-				continue;
-			ret++;
-			if (buf)
-				fst_fill_mb_ie(buf, NULL, fst_iface_get_addr(f),
-					       b, MB_STA_CHANNEL_ALL);
-		}
-		return ret;
-	}
-}
-
-
-static struct wpabuf * fst_group_create_mb_ie(struct fst_group *g,
-					      struct fst_iface *i)
-{
-	struct wpabuf *buf;
-	struct fst_iface *f;
-	unsigned int nof_mbies = 0;
-	unsigned int nof_ifaces_added = 0;
-
-	foreach_fst_group_iface(g, f) {
-		if (f == i)
-			continue;
-		nof_mbies += fst_fill_iface_mb_ies(f, NULL);
-	}
-
-	buf = wpabuf_alloc(nof_mbies *
-			   (sizeof(struct multi_band_ie) + ETH_ALEN));
-	if (!buf) {
-		fst_printf_iface(i, MSG_ERROR,
-				 "cannot allocate mem for %u MB IEs",
-				 nof_mbies);
-		return NULL;
-	}
-
-	/* The list is sorted in descending order by priorities, so MB IEs will
-	 * be arranged in the same order, as required by spec (see corresponding
-	 * comment in.fst_attach().
-	 */
-	foreach_fst_group_iface(g, f) {
-		if (f == i)
-			continue;
-
-		fst_fill_iface_mb_ies(f, buf);
-		++nof_ifaces_added;
-
-		fst_printf_iface(i, MSG_DEBUG, "added to MB IE");
-	}
-
-	if (!nof_ifaces_added) {
-		wpabuf_free(buf);
-		buf = NULL;
-		fst_printf_iface(i, MSG_INFO,
-				 "cannot add MB IE: no backup ifaces");
-	} else {
-		fst_dump_mb_ies(fst_group_get_id(g), fst_iface_get_name(i),
-				buf);
-	}
-
-	return buf;
-}
-
-
-static const u8 * fst_mbie_get_peer_addr(const struct multi_band_ie *mbie)
-{
-	const u8 *peer_addr = NULL;
-
-	switch (MB_CTRL_ROLE(mbie->mb_ctrl)) {
-	case MB_STA_ROLE_AP:
-		peer_addr = mbie->bssid;
-		break;
-	case MB_STA_ROLE_NON_PCP_NON_AP:
-		if (mbie->mb_ctrl & MB_CTRL_STA_MAC_PRESENT &&
-		    (size_t) 2 + mbie->len >= sizeof(*mbie) + ETH_ALEN)
-			peer_addr = (const u8 *) &mbie[1];
-		break;
-	default:
-		break;
-	}
-
-	return peer_addr;
-}
-
-
-static struct fst_iface *
-fst_group_get_new_iface_by_mbie_and_band_id(struct fst_group *g,
-					    const u8 *mb_ies_buff,
-					    size_t mb_ies_size,
-					    u8 band_id,
-					    u8 *iface_peer_addr)
-{
-	while (mb_ies_size >= 2) {
-		const struct multi_band_ie *mbie =
-			(const struct multi_band_ie *) mb_ies_buff;
-
-		if (mbie->eid != WLAN_EID_MULTI_BAND ||
-		    (size_t) 2 + mbie->len < sizeof(*mbie))
-			break;
-
-		if (mbie->band_id == band_id) {
-			struct fst_iface *iface;
-
-			foreach_fst_group_iface(g, iface) {
-				const u8 *peer_addr =
-					fst_mbie_get_peer_addr(mbie);
-
-				if (peer_addr &&
-				    fst_iface_is_connected(iface, peer_addr,
-							   FALSE) &&
-				    band_id == fst_iface_get_band_id(iface)) {
-					os_memcpy(iface_peer_addr, peer_addr,
-						  ETH_ALEN);
-					return iface;
-				}
-			}
-			break;
-		}
-
-		mb_ies_buff += 2 + mbie->len;
-		mb_ies_size -= 2 + mbie->len;
-	}
-
-	return NULL;
-}
-
-
-struct fst_iface * fst_group_get_iface_by_name(struct fst_group *g,
-					       const char *ifname)
-{
-	struct fst_iface *f;
-
-	foreach_fst_group_iface(g, f) {
-		const char *in = fst_iface_get_name(f);
-
-		if (os_strncmp(in, ifname, os_strlen(in)) == 0)
-			return f;
-	}
-
-	return NULL;
-}
-
-
-u8 fst_group_assign_dialog_token(struct fst_group *g)
-{
-	g->dialog_token++;
-	if (g->dialog_token == 0)
-		g->dialog_token++;
-	return g->dialog_token;
-}
-
-
-u32 fst_group_assign_fsts_id(struct fst_group *g)
-{
-	g->fsts_id++;
-	return g->fsts_id;
-}
-
-
-static Boolean
-fst_group_does_iface_appear_in_other_mbies(struct fst_group *g,
-					   struct fst_iface *iface,
-					   struct fst_iface *other,
-					   u8 *peer_addr)
-{
-	struct fst_get_peer_ctx *ctx;
-	const u8 *addr;
-	const u8 *iface_addr;
-	enum mb_band_id  iface_band_id;
-
-	WPA_ASSERT(g == fst_iface_get_group(iface));
-	WPA_ASSERT(g == fst_iface_get_group(other));
-
-	iface_addr = fst_iface_get_addr(iface);
-	iface_band_id = fst_iface_get_band_id(iface);
-
-	addr = fst_iface_get_peer_first(other, &ctx, TRUE);
-	for (; addr; addr = fst_iface_get_peer_next(other, &ctx, TRUE)) {
-		const struct wpabuf *mbies;
-		u8 other_iface_peer_addr[ETH_ALEN];
-		struct fst_iface *other_new_iface;
-
-		mbies = fst_iface_get_peer_mb_ie(other, addr);
-		if (!mbies)
-			continue;
-
-		other_new_iface = fst_group_get_new_iface_by_mbie_and_band_id(
-			g, wpabuf_head(mbies), wpabuf_len(mbies),
-			iface_band_id, other_iface_peer_addr);
-		if (other_new_iface == iface &&
-		    os_memcmp(iface_addr, other_iface_peer_addr,
-			      ETH_ALEN) != 0) {
-			os_memcpy(peer_addr, addr, ETH_ALEN);
-			return TRUE;
-		}
-	}
-
-	return FALSE;
-}
-
-
-struct fst_iface *
-fst_group_find_new_iface_by_stie(struct fst_group *g,
-				 struct fst_iface *iface,
-				 const u8 *peer_addr,
-				 const struct session_transition_ie *stie,
-				 u8 *iface_peer_addr)
-{
-	struct fst_iface *i;
-
-	foreach_fst_group_iface(g, i) {
-		if (i == iface ||
-		    stie->new_band_id != fst_iface_get_band_id(i))
-			continue;
-		if (fst_group_does_iface_appear_in_other_mbies(g, iface, i,
-			iface_peer_addr))
-			return i;
-		break;
-	}
-	return NULL;
-}
-
-
-struct fst_iface *
-fst_group_get_new_iface_by_stie_and_mbie(
-	struct fst_group *g, const u8 *mb_ies_buff, size_t mb_ies_size,
-	const struct session_transition_ie *stie, u8 *iface_peer_addr)
-{
-	return fst_group_get_new_iface_by_mbie_and_band_id(
-		g, mb_ies_buff, mb_ies_size, stie->new_band_id,
-		iface_peer_addr);
-}
-
-
-struct fst_group * fst_group_create(const char *group_id)
-{
-	struct fst_group *g;
-
-	g = os_zalloc(sizeof(*g));
-	if (g == NULL) {
-		fst_printf(MSG_ERROR, "%s: Cannot alloc group", group_id);
-		return NULL;
-	}
-
-	dl_list_init(&g->ifaces);
-	os_strlcpy(g->group_id, group_id, sizeof(g->group_id));
-
-	dl_list_add_tail(&fst_global_groups_list, &g->global_groups_lentry);
-	fst_printf_group(g, MSG_DEBUG, "instance created");
-
-	foreach_fst_ctrl_call(on_group_created, g);
-
-	return g;
-}
-
-
-void fst_group_attach_iface(struct fst_group *g, struct fst_iface *i)
-{
-	struct dl_list *list = &g->ifaces;
-	struct fst_iface *f;
-
-	/*
-	 * Add new interface to the list.
-	 * The list is sorted in descending order by priority to allow
-	 * multiple MB IEs creation according to the spec (see 10.32 Multi-band
-	 * operation, 10.32.1 General), as they should be ordered according to
-	 * priorities.
-	 */
-	foreach_fst_group_iface(g, f) {
-		if (fst_iface_get_priority(f) < fst_iface_get_priority(i))
-			break;
-		list = &f->group_lentry;
-	}
-	dl_list_add(list, &i->group_lentry);
-}
-
-
-void fst_group_detach_iface(struct fst_group *g, struct fst_iface *i)
-{
-	dl_list_del(&i->group_lentry);
-}
-
-
-void fst_group_delete(struct fst_group *group)
-{
-	struct fst_session *s;
-
-	dl_list_del(&group->global_groups_lentry);
-	WPA_ASSERT(dl_list_empty(&group->ifaces));
-	foreach_fst_ctrl_call(on_group_deleted, group);
-	fst_printf_group(group, MSG_DEBUG, "instance deleted");
-	while ((s = fst_session_global_get_first_by_group(group)) != NULL)
-		fst_session_delete(s);
-	os_free(group);
-}
-
-
-Boolean fst_group_delete_if_empty(struct fst_group *group)
-{
-	Boolean is_empty = !fst_group_has_ifaces(group) &&
-		!fst_session_global_get_first_by_group(group);
-
-	if (is_empty)
-		fst_group_delete(group);
-
-	return is_empty;
-}
-
-
-void fst_group_update_ie(struct fst_group *g)
-{
-	struct fst_iface *i;
-
-	foreach_fst_group_iface(g, i) {
-		struct wpabuf *mbie = fst_group_create_mb_ie(g, i);
-
-		if (!mbie)
-			fst_printf_iface(i, MSG_WARNING, "cannot create MB IE");
-
-		fst_iface_attach_mbie(i, mbie);
-		fst_iface_set_ies(i, mbie);
-		fst_printf_iface(i, MSG_DEBUG, "multi-band IE set to %p", mbie);
-	}
-}
diff --git a/src/fst/fst_group.h b/src/fst/fst_group.h
deleted file mode 100644
index 3a87c0b..0000000
--- a/src/fst/fst_group.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * FST module - FST group object definitions
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef FST_GROUP_H
-#define FST_GROUP_H
-
-struct fst_group {
-	char group_id[IFNAMSIZ + 1];
-	struct dl_list ifaces;
-	u8 dialog_token;
-	u32 fsts_id;
-	struct dl_list global_groups_lentry;
-};
-
-struct session_transition_ie;
-
-#define foreach_fst_group_iface(g, i) \
-	dl_list_for_each((i), &(g)->ifaces, struct fst_iface, group_lentry)
-
-struct fst_group * fst_group_create(const char *group_id);
-void fst_group_attach_iface(struct fst_group *g, struct fst_iface *i);
-void fst_group_detach_iface(struct fst_group *g, struct fst_iface *i);
-void fst_group_delete(struct fst_group *g);
-
-void fst_group_update_ie(struct fst_group *g);
-
-static inline Boolean fst_group_has_ifaces(struct fst_group *g)
-{
-	return !dl_list_empty(&g->ifaces);
-}
-
-static inline struct fst_iface * fst_group_first_iface(struct fst_group *g)
-{
-	return dl_list_first(&g->ifaces, struct fst_iface, group_lentry);
-}
-
-static inline const char * fst_group_get_id(struct fst_group *g)
-{
-	return g->group_id;
-}
-
-Boolean fst_group_delete_if_empty(struct fst_group *group);
-struct fst_iface * fst_group_get_iface_by_name(struct fst_group *g,
-					       const char *ifname);
-struct fst_iface *
-fst_group_find_new_iface_by_stie(struct fst_group *g,
-				 struct fst_iface *iface,
-				 const u8 *peer_addr,
-				 const struct session_transition_ie *stie,
-				 u8 *iface_peer_addr);
-struct fst_iface *
-fst_group_get_new_iface_by_stie_and_mbie(
-	struct fst_group *g, const u8 *mb_ies_buff, size_t mb_ies_size,
-	const struct session_transition_ie *stie, u8 *iface_peer_addr);
-u8  fst_group_assign_dialog_token(struct fst_group *g);
-u32 fst_group_assign_fsts_id(struct fst_group *g);
-
-extern struct dl_list fst_global_groups_list;
-
-#define foreach_fst_group(g) \
-	dl_list_for_each((g), &fst_global_groups_list, \
-			 struct fst_group, global_groups_lentry)
-
-static inline struct fst_group * fst_first_group(void)
-{
-	return dl_list_first(&fst_global_groups_list, struct fst_group,
-			     global_groups_lentry);
-}
-
-#endif /* FST_GROUP_H */
diff --git a/src/fst/fst_iface.c b/src/fst/fst_iface.c
deleted file mode 100644
index 35e83cb..0000000
--- a/src/fst/fst_iface.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * FST module - FST interface object implementation
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "utils/includes.h"
-#include "utils/common.h"
-#include "fst/fst_internal.h"
-#include "fst/fst_defs.h"
-
-
-struct fst_iface * fst_iface_create(struct fst_group *g, const char *ifname,
-				    const u8 *own_addr,
-				    const struct fst_wpa_obj *iface_obj,
-				    const struct fst_iface_cfg *cfg)
-{
-	struct fst_iface *i;
-
-	i = os_zalloc(sizeof(*i));
-	if (!i) {
-		fst_printf_group(g, MSG_ERROR, "cannot allocate iface for %s",
-				ifname);
-		return NULL;
-	}
-
-	i->cfg = *cfg;
-	i->iface_obj = *iface_obj;
-	i->group = g;
-	os_strlcpy(i->ifname, ifname, sizeof(i->ifname));
-	os_memcpy(i->own_addr, own_addr, sizeof(i->own_addr));
-
-	if (!i->cfg.llt) {
-		fst_printf_iface(i, MSG_WARNING, "Zero llt adjusted");
-		i->cfg.llt = FST_DEFAULT_LLT_CFG_VALUE;
-	}
-
-	return i;
-}
-
-
-void fst_iface_delete(struct fst_iface *i)
-{
-	fst_iface_set_ies(i, NULL);
-	wpabuf_free(i->mb_ie);
-	os_free(i);
-}
-
-
-Boolean fst_iface_is_connected(struct fst_iface *iface, const u8 *addr,
-			       Boolean mb_only)
-{
-	struct fst_get_peer_ctx *ctx;
-	const u8 *a = fst_iface_get_peer_first(iface, &ctx, mb_only);
-
-	for (; a != NULL; a = fst_iface_get_peer_next(iface, &ctx, mb_only))
-		if (os_memcmp(addr, a, ETH_ALEN) == 0)
-			return TRUE;
-
-	return FALSE;
-}
-
-
-void fst_iface_attach_mbie(struct fst_iface *i, struct wpabuf *mbie)
-{
-	wpabuf_free(i->mb_ie);
-	i->mb_ie = mbie;
-}
-
-
-enum mb_band_id fst_iface_get_band_id(struct fst_iface *i)
-{
-	enum hostapd_hw_mode hw_mode;
-	u8 channel;
-
-	fst_iface_get_channel_info(i, &hw_mode, &channel);
-	return fst_hw_mode_to_band(hw_mode);
-}
diff --git a/src/fst/fst_iface.h b/src/fst/fst_iface.h
deleted file mode 100644
index 0eb2732..0000000
--- a/src/fst/fst_iface.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * FST module - FST interface object definitions
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-
-#ifndef FST_IFACE_H
-#define FST_IFACE_H
-
-#include "utils/includes.h"
-#include "utils/common.h"
-#include "list.h"
-#include "fst.h"
-
-struct fst_iface {
-	struct fst_group *group;
-	struct fst_wpa_obj iface_obj;
-	u8 own_addr[ETH_ALEN];
-	struct wpabuf *mb_ie;
-	char ifname[IFNAMSIZ + 1];
-	struct fst_iface_cfg cfg;
-	struct dl_list group_lentry;
-};
-
-struct fst_iface * fst_iface_create(struct fst_group *g, const char *ifname,
-				    const u8 *own_addr,
-				    const struct fst_wpa_obj *iface_obj,
-				    const struct fst_iface_cfg *cfg);
-void fst_iface_delete(struct fst_iface *i);
-
-static inline struct fst_group * fst_iface_get_group(struct fst_iface *i)
-{
-	return i->group;
-}
-
-static inline const char * fst_iface_get_name(struct fst_iface *i)
-{
-	return i->ifname;
-}
-
-static inline const u8 * fst_iface_get_addr(struct fst_iface *i)
-{
-	return i->own_addr;
-}
-
-static inline const char * fst_iface_get_group_id(struct fst_iface *i)
-{
-	return i->cfg.group_id;
-}
-
-static inline u8 fst_iface_get_priority(struct fst_iface *i)
-{
-	return i->cfg.priority;
-}
-
-static inline u32 fst_iface_get_llt(struct fst_iface *i)
-{
-	return i->cfg.llt;
-}
-
-static inline const struct wpabuf * fst_iface_get_mbie(struct fst_iface *i)
-{
-	return i->mb_ie;
-}
-
-static inline const u8 * fst_iface_get_bssid(struct fst_iface *i)
-{
-	return i->iface_obj.get_bssid(i->iface_obj.ctx);
-}
-
-static inline void fst_iface_get_channel_info(struct fst_iface *i,
-					      enum hostapd_hw_mode *hw_mode,
-					      u8 *channel)
-{
-	i->iface_obj.get_channel_info(i->iface_obj.ctx, hw_mode, channel);
-}
-
-static inline int fst_iface_get_hw_modes(struct fst_iface *i,
-					 struct hostapd_hw_modes **modes)
-{
-	return i->iface_obj.get_hw_modes(i->iface_obj.ctx, modes);
-}
-
-static inline void fst_iface_set_ies(struct fst_iface *i,
-				     const struct wpabuf *fst_ies)
-{
-	i->iface_obj.set_ies(i->iface_obj.ctx, fst_ies);
-}
-
-static inline int fst_iface_send_action(struct fst_iface *i,
-					const u8 *addr, struct wpabuf *data)
-{
-	return i->iface_obj.send_action(i->iface_obj.ctx, addr, data);
-}
-
-static inline const struct wpabuf *
-fst_iface_get_peer_mb_ie(struct fst_iface *i, const u8 *addr)
-{
-	return i->iface_obj.get_mb_ie(i->iface_obj.ctx, addr);
-}
-
-static inline void fst_iface_update_mb_ie(struct fst_iface *i,
-					  const u8 *addr,
-					  const u8 *buf, size_t size)
-{
-	return i->iface_obj.update_mb_ie(i->iface_obj.ctx, addr, buf, size);
-}
-
-static inline const u8 * fst_iface_get_peer_first(struct fst_iface *i,
-						  struct fst_get_peer_ctx **ctx,
-						  Boolean mb_only)
-{
-	return i->iface_obj.get_peer_first(i->iface_obj.ctx, ctx, mb_only);
-}
-
-static inline const u8 * fst_iface_get_peer_next(struct fst_iface *i,
-						 struct fst_get_peer_ctx **ctx,
-						 Boolean mb_only)
-{
-	return i->iface_obj.get_peer_next(i->iface_obj.ctx, ctx, mb_only);
-}
-
-Boolean fst_iface_is_connected(struct fst_iface *iface, const u8 *addr,
-			       Boolean mb_only);
-void fst_iface_attach_mbie(struct fst_iface *i, struct wpabuf *mbie);
-enum mb_band_id fst_iface_get_band_id(struct fst_iface *i);
-
-static inline void * fst_iface_get_wpa_obj_ctx(struct fst_iface *i)
-{
-	return i->iface_obj.ctx;
-}
-
-#endif /* FST_IFACE_H */
diff --git a/src/fst/fst_internal.h b/src/fst/fst_internal.h
deleted file mode 100644
index 9fe32b8..0000000
--- a/src/fst/fst_internal.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * FST module - auxiliary definitions
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef FST_INTERNAL_H
-#define FST_INTERNAL_H
-
-#include "utils/includes.h"
-#include "utils/common.h"
-#include "common/defs.h"
-#include "common/ieee802_11_defs.h"
-#include "fst/fst_iface.h"
-#include "fst/fst_group.h"
-#include "fst/fst_session.h"
-
-#define fst_printf(level, format, ...) \
-	wpa_printf((level), "FST: " format, ##__VA_ARGS__)
-
-#define fst_printf_group(group, level, format, ...) \
-	wpa_printf((level), "FST: %s: " format, \
-		   fst_group_get_id(group), ##__VA_ARGS__)
-
-#define fst_printf_iface(iface, level, format, ...) \
-	fst_printf_group(fst_iface_get_group(iface), (level), "%s: " format, \
-			 fst_iface_get_name(iface), ##__VA_ARGS__)
-
-enum mb_band_id fst_hw_mode_to_band(enum hostapd_hw_mode mode);
-
-struct fst_ctrl_handle {
-	struct fst_ctrl ctrl;
-	struct dl_list global_ctrls_lentry;
-};
-
-extern struct dl_list fst_global_ctrls_list;
-
-#define foreach_fst_ctrl_call(clb, ...) \
-	do { \
-		struct fst_ctrl_handle *__fst_ctrl_h; \
-		dl_list_for_each(__fst_ctrl_h, &fst_global_ctrls_list, \
-			struct fst_ctrl_handle, global_ctrls_lentry) \
-			if (__fst_ctrl_h->ctrl.clb) \
-				__fst_ctrl_h->ctrl.clb(__VA_ARGS__);\
-	} while (0)
-
-#endif /* FST_INTERNAL_H */
diff --git a/src/fst/fst_session.c b/src/fst/fst_session.c
deleted file mode 100644
index a6f116c..0000000
--- a/src/fst/fst_session.c
+++ /dev/null
@@ -1,1624 +0,0 @@
-/*
- * FST module - FST Session implementation
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "utils/includes.h"
-
-#include "utils/common.h"
-#include "utils/eloop.h"
-#include "common/defs.h"
-#include "fst/fst_internal.h"
-#include "fst/fst_defs.h"
-#include "fst/fst_ctrl_iface.h"
-#ifdef CONFIG_FST_TEST
-#include "fst/fst_ctrl_defs.h"
-#endif /* CONFIG_FST_TEST */
-
-#define US_80211_TU 1024
-
-#define US_TO_TU(m) ((m) * / US_80211_TU)
-#define TU_TO_US(m) ((m) * US_80211_TU)
-
-#define FST_LLT_SWITCH_IMMEDIATELY 0
-
-#define fst_printf_session(s, level, format, ...) \
-	fst_printf((level), "%u (0x%08x): [" MACSTR "," MACSTR "] :" format, \
-		   (s)->id, (s)->data.fsts_id, \
-		   MAC2STR((s)->data.old_peer_addr), \
-		   MAC2STR((s)->data.new_peer_addr), \
-		   ##__VA_ARGS__)
-
-#define fst_printf_siface(s, iface, level, format, ...) \
-	fst_printf_session((s), (level), "%s: " format, \
-			   fst_iface_get_name(iface), ##__VA_ARGS__)
-
-#define fst_printf_sframe(s, is_old, level, format, ...) \
-	fst_printf_siface((s), \
-		(is_old) ? (s)->data.old_iface : (s)->data.new_iface, \
-		(level), format, ##__VA_ARGS__)
-
-#define FST_LLT_MS_DEFAULT 50
-#define FST_ACTION_MAX_SUPPORTED   FST_ACTION_ON_CHANNEL_TUNNEL
-
-const char * const fst_action_names[] = {
-	[FST_ACTION_SETUP_REQUEST]     = "Setup Request",
-	[FST_ACTION_SETUP_RESPONSE]    = "Setup Response",
-	[FST_ACTION_TEAR_DOWN]         = "Tear Down",
-	[FST_ACTION_ACK_REQUEST]       = "Ack Request",
-	[FST_ACTION_ACK_RESPONSE]      = "Ack Response",
-	[FST_ACTION_ON_CHANNEL_TUNNEL] = "On Channel Tunnel",
-};
-
-struct fst_session {
-	struct {
-		/* Session configuration that can be zeroed on reset */
-		u8 old_peer_addr[ETH_ALEN];
-		u8 new_peer_addr[ETH_ALEN];
-		struct fst_iface *new_iface;
-		struct fst_iface *old_iface;
-		u32 llt_ms;
-		u8 pending_setup_req_dlgt;
-		u32 fsts_id; /* FSTS ID, see spec, 8.4.2.147
-			      * Session Transition element */
-	} data;
-	/* Session object internal fields which won't be zeroed on reset */
-	struct dl_list global_sessions_lentry;
-	u32 id; /* Session object ID used to identify
-		 * specific session object */
-	struct fst_group *group;
-	enum fst_session_state state;
-	Boolean stt_armed;
-};
-
-static struct dl_list global_sessions_list;
-static u32 global_session_id = 0;
-
-#define foreach_fst_session(s) \
-	dl_list_for_each((s), &global_sessions_list, \
-			 struct fst_session, global_sessions_lentry)
-
-#define foreach_fst_session_safe(s, temp) \
-	dl_list_for_each_safe((s), (temp), &global_sessions_list, \
-			      struct fst_session, global_sessions_lentry)
-
-
-static void fst_session_global_inc_id(void)
-{
-	global_session_id++;
-	if (global_session_id == FST_INVALID_SESSION_ID)
-		global_session_id++;
-}
-
-
-int fst_session_global_init(void)
-{
-	dl_list_init(&global_sessions_list);
-	return 0;
-}
-
-
-void fst_session_global_deinit(void)
-{
-	WPA_ASSERT(dl_list_empty(&global_sessions_list));
-}
-
-
-static inline void fst_session_notify_ctrl(struct fst_session *s,
-					   enum fst_event_type event_type,
-					   union fst_event_extra *extra)
-{
-	foreach_fst_ctrl_call(on_event, event_type, NULL, s, extra);
-}
-
-
-static void fst_session_set_state(struct fst_session *s,
-				  enum fst_session_state state,
-				  union fst_session_state_switch_extra *extra)
-{
-	if (s->state != state) {
-		union fst_event_extra evext = {
-			.session_state = {
-				.old_state = s->state,
-				.new_state = state,
-			},
-		};
-
-		if (extra)
-			evext.session_state.extra = *extra;
-		fst_session_notify_ctrl(s, EVENT_FST_SESSION_STATE_CHANGED,
-					&evext);
-		fst_printf_session(s, MSG_INFO, "State: %s => %s",
-				   fst_session_state_name(s->state),
-				   fst_session_state_name(state));
-		s->state = state;
-	}
-}
-
-
-static u32 fst_find_free_session_id(void)
-{
-	u32 i, id = FST_INVALID_SESSION_ID;
-	struct fst_session *s;
-
-	for (i = 0; i < (u32) -1; i++) {
-		Boolean in_use = FALSE;
-
-		foreach_fst_session(s) {
-			if (s->id == global_session_id) {
-				fst_session_global_inc_id();
-				in_use = TRUE;
-				break;
-			}
-		}
-		if (!in_use) {
-			id = global_session_id;
-			fst_session_global_inc_id();
-			break;
-		}
-	}
-
-	return id;
-}
-
-
-static void fst_session_timeout_handler(void *eloop_data, void *user_ctx)
-{
-	struct fst_session *s = user_ctx;
-	union fst_session_state_switch_extra extra = {
-		.to_initial = {
-			.reason = REASON_STT,
-		},
-	};
-
-	fst_printf_session(s, MSG_WARNING, "Session State Timeout");
-	fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &extra);
-}
-
-
-static void fst_session_stt_arm(struct fst_session *s)
-{
-	/* Action frames sometimes get delayed. Use relaxed timeout (2*) */
-	eloop_register_timeout(0, 2 * TU_TO_US(FST_DEFAULT_SESSION_TIMEOUT_TU),
-			       fst_session_timeout_handler, NULL, s);
-	s->stt_armed = TRUE;
-}
-
-
-static void fst_session_stt_disarm(struct fst_session *s)
-{
-	if (s->stt_armed) {
-		eloop_cancel_timeout(fst_session_timeout_handler, NULL, s);
-		s->stt_armed = FALSE;
-	}
-}
-
-
-static Boolean fst_session_is_in_transition(struct fst_session *s)
-{
-	/* See spec, 10.32.2.2  Transitioning between states */
-	return s->stt_armed;
-}
-
-
-static int fst_session_is_in_progress(struct fst_session *s)
-{
-	return s->state != FST_SESSION_STATE_INITIAL;
-}
-
-
-static int fst_session_is_ready_pending(struct fst_session *s)
-{
-	return s->state == FST_SESSION_STATE_SETUP_COMPLETION &&
-		fst_session_is_in_transition(s);
-}
-
-
-static int fst_session_is_ready(struct fst_session *s)
-{
-	return s->state == FST_SESSION_STATE_SETUP_COMPLETION &&
-		!fst_session_is_in_transition(s);
-}
-
-
-static int fst_session_is_switch_requested(struct fst_session *s)
-{
-	return s->state == FST_SESSION_STATE_TRANSITION_DONE &&
-		fst_session_is_in_transition(s);
-}
-
-
-static struct fst_session *
-fst_find_session_in_progress(const u8 *peer_addr, struct fst_group *g)
-{
-	struct fst_session *s;
-
-	foreach_fst_session(s) {
-		if (s->group == g &&
-		    (os_memcmp(s->data.old_peer_addr, peer_addr,
-			       ETH_ALEN) == 0 ||
-		     os_memcmp(s->data.new_peer_addr, peer_addr,
-			       ETH_ALEN) == 0) &&
-		    fst_session_is_in_progress(s))
-			return s;
-	}
-
-	return NULL;
-}
-
-
-static void fst_session_reset_ex(struct fst_session *s, enum fst_reason reason)
-{
-	union fst_session_state_switch_extra evext = {
-		.to_initial = {
-			.reason = reason,
-		},
-	};
-
-	if (s->state == FST_SESSION_STATE_SETUP_COMPLETION ||
-	    s->state == FST_SESSION_STATE_TRANSITION_DONE)
-		fst_session_tear_down_setup(s);
-	fst_session_stt_disarm(s);
-	os_memset(&s->data, 0, sizeof(s->data));
-	fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &evext);
-}
-
-
-static int fst_session_send_action(struct fst_session *s, Boolean old_iface,
-				   const void *payload, size_t size,
-				   const struct wpabuf *extra_buf)
-{
-	size_t len;
-	int res;
-	struct wpabuf *buf;
-	u8 action;
-	struct fst_iface *iface =
-		old_iface ? s->data.old_iface : s->data.new_iface;
-
-	WPA_ASSERT(payload != NULL);
-	WPA_ASSERT(size != 0);
-
-	action = *(const u8 *) payload;
-
-	WPA_ASSERT(action <= FST_ACTION_MAX_SUPPORTED);
-
-	if (!iface) {
-		fst_printf_session(s, MSG_ERROR,
-				   "no %s interface for FST Action '%s' sending",
-				   old_iface ? "old" : "new",
-				   fst_action_names[action]);
-		return -1;
-	}
-
-	len = sizeof(u8) /* category */ + size;
-	if (extra_buf)
-		len += wpabuf_size(extra_buf);
-
-	buf = wpabuf_alloc(len);
-	if (!buf) {
-		fst_printf_session(s, MSG_ERROR,
-				   "cannot allocate buffer of %zu bytes for FST Action '%s' sending",
-				   len, fst_action_names[action]);
-		return -1;
-	}
-
-	wpabuf_put_u8(buf, WLAN_ACTION_FST);
-	wpabuf_put_data(buf, payload, size);
-	if (extra_buf)
-		wpabuf_put_buf(buf, extra_buf);
-
-	res = fst_iface_send_action(iface,
-				    old_iface ? s->data.old_peer_addr :
-				    s->data.new_peer_addr, buf);
-	if (res < 0)
-		fst_printf_siface(s, iface, MSG_ERROR,
-				  "failed to send FST Action '%s'",
-				  fst_action_names[action]);
-	else
-		fst_printf_siface(s, iface, MSG_DEBUG, "FST Action '%s' sent",
-				  fst_action_names[action]);
-	wpabuf_free(buf);
-
-	return res;
-}
-
-
-static int fst_session_send_tear_down(struct fst_session *s)
-{
-	struct fst_tear_down td;
-	int res;
-
-	if (!fst_session_is_in_progress(s)) {
-		fst_printf_session(s, MSG_ERROR, "No FST setup to tear down");
-		return -1;
-	}
-
-	WPA_ASSERT(s->data.old_iface != NULL);
-	WPA_ASSERT(s->data.new_iface != NULL);
-
-	os_memset(&td, 0, sizeof(td));
-
-	td.action = FST_ACTION_TEAR_DOWN;
-	td.fsts_id = host_to_le32(s->data.fsts_id);
-
-	res = fst_session_send_action(s, TRUE, &td, sizeof(td), NULL);
-	if (!res)
-		fst_printf_sframe(s, TRUE, MSG_INFO, "FST TearDown sent");
-	else
-		fst_printf_sframe(s, TRUE, MSG_ERROR,
-				  "failed to send FST TearDown");
-
-	return res;
-}
-
-
-static void fst_session_handle_setup_request(struct fst_iface *iface,
-					     const struct ieee80211_mgmt *mgmt,
-					     size_t frame_len)
-{
-	struct fst_session *s;
-	const struct fst_setup_req *req;
-	struct fst_iface *new_iface = NULL;
-	struct fst_group *g;
-	u8 new_iface_peer_addr[ETH_ALEN];
-	const struct wpabuf *peer_mbies;
-	size_t plen;
-
-	if (frame_len < IEEE80211_HDRLEN + 1 + sizeof(*req))  {
-		fst_printf_iface(iface, MSG_WARNING,
-				 "FST Request dropped: too short (%zu < %zu)",
-				 frame_len,
-				 IEEE80211_HDRLEN + 1 + sizeof(*req));
-		return;
-	}
-	plen = frame_len - IEEE80211_HDRLEN - 1;
-	req = (const struct fst_setup_req *)
-		(((const u8 *) mgmt) + IEEE80211_HDRLEN + 1);
-	if (req->stie.element_id != WLAN_EID_SESSION_TRANSITION ||
-	    req->stie.length < 11) {
-		fst_printf_iface(iface, MSG_WARNING,
-				 "FST Request dropped: invalid STIE");
-		return;
-	}
-
-	if (req->stie.new_band_id == req->stie.old_band_id) {
-		fst_printf_iface(iface, MSG_WARNING,
-				 "FST Request dropped: new and old band IDs are the same");
-		return;
-	}
-
-	g = fst_iface_get_group(iface);
-
-	if (plen > sizeof(*req)) {
-		fst_iface_update_mb_ie(iface, mgmt->sa, (const u8 *) (req + 1),
-				       plen - sizeof(*req));
-		fst_printf_iface(iface, MSG_INFO,
-				 "FST Request: MB IEs updated for " MACSTR,
-				 MAC2STR(mgmt->sa));
-	}
-
-	peer_mbies = fst_iface_get_peer_mb_ie(iface, mgmt->sa);
-	if (peer_mbies) {
-		new_iface = fst_group_get_new_iface_by_stie_and_mbie(
-			g, wpabuf_head(peer_mbies), wpabuf_len(peer_mbies),
-			&req->stie, new_iface_peer_addr);
-		if (new_iface)
-			fst_printf_iface(iface, MSG_INFO,
-					 "FST Request: new iface (%s:" MACSTR
-					 ") found by MB IEs",
-					 fst_iface_get_name(new_iface),
-					 MAC2STR(new_iface_peer_addr));
-	}
-
-	if (!new_iface) {
-		new_iface = fst_group_find_new_iface_by_stie(
-			g, iface, mgmt->sa, &req->stie,
-			new_iface_peer_addr);
-		if (new_iface)
-			fst_printf_iface(iface, MSG_INFO,
-					 "FST Request: new iface (%s:" MACSTR
-					 ") found by others",
-					 fst_iface_get_name(new_iface),
-					 MAC2STR(new_iface_peer_addr));
-	}
-
-	if (!new_iface) {
-		fst_printf_iface(iface, MSG_WARNING,
-				 "FST Request dropped: new iface not found");
-		return;
-	}
-
-	s = fst_find_session_in_progress(mgmt->sa, g);
-	if (s) {
-		union fst_session_state_switch_extra evext = {
-			.to_initial = {
-				.reason = REASON_SETUP,
-			},
-		};
-
-		/*
-		 * 10.32.2.2  Transitioning between states:
-		 * Upon receipt of an FST Setup Request frame, the responder
-		 * shall respond with an FST Setup Response frame unless it has
-		 * a pending FST Setup Request frame addressed to the initiator
-		 * and the responder has a numerically larger MAC address than
-		 * the initiators MAC address, in which case, the responder
-		 * shall delete the received FST Setup Request.
-		 */
-		if (os_memcmp(mgmt->da, mgmt->sa, ETH_ALEN) > 0) {
-			fst_printf_session(s, MSG_WARNING,
-					   "FST Request dropped due to MAC comparison (our MAC is "
-					   MACSTR ")",
-					   MAC2STR(mgmt->da));
-			return;
-		}
-
-		if (!fst_session_is_ready_pending(s)) {
-			fst_printf_session(s, MSG_WARNING,
-					   "FST Request from " MACSTR
-					   " dropped due to inappropriate state %s",
-					   MAC2STR(mgmt->da),
-					   fst_session_state_name(s->state));
-			return;
-		}
-
-
-		/*
-		 * If FST Setup Request arrived with the same FSTS ID as one we
-		 * initialized before, it means the other side either didn't
-		 * receive our FST Request or skipped it for some reason (for
-		 * example, due to numerical MAC comparison).
-		 *
-		 * In this case, there's no need to tear down the session.
-		 * Moreover, as FSTS ID is the same, the other side will
-		 * associate this tear down with the session it initiated that
-		 * will break the sync.
-		 */
-		if (le_to_host32(req->stie.fsts_id) != s->data.fsts_id)
-			fst_session_send_tear_down(s);
-		else
-			fst_printf_session(s, MSG_WARNING,
-					   "Skipping TearDown as the FST request has the same FSTS ID as initiated");
-		fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &evext);
-		fst_session_stt_disarm(s);
-		fst_printf_session(s, MSG_WARNING, "reset due to FST request");
-	}
-
-	s = fst_session_create(g);
-	if (!s) {
-		fst_printf(MSG_WARNING,
-			   "FST Request dropped: cannot create session for %s and %s",
-			   fst_iface_get_name(iface),
-			   fst_iface_get_name(new_iface));
-		return;
-	}
-
-	fst_session_set_iface(s, iface, TRUE);
-	fst_session_set_peer_addr(s, mgmt->sa, TRUE);
-	fst_session_set_iface(s, new_iface, FALSE);
-	fst_session_set_peer_addr(s, new_iface_peer_addr, FALSE);
-	fst_session_set_llt(s, FST_LLT_VAL_TO_MS(le_to_host32(req->llt)));
-	s->data.pending_setup_req_dlgt = req->dialog_token;
-	s->data.fsts_id = le_to_host32(req->stie.fsts_id);
-
-	fst_session_stt_arm(s);
-
-	fst_session_notify_ctrl(s, EVENT_FST_SETUP, NULL);
-
-	fst_session_set_state(s, FST_SESSION_STATE_SETUP_COMPLETION, NULL);
-}
-
-
-static void fst_session_handle_setup_response(struct fst_session *s,
-					      struct fst_iface *iface,
-					      const struct ieee80211_mgmt *mgmt,
-					      size_t frame_len)
-{
-	const struct fst_setup_res *res;
-	size_t plen = frame_len - IEEE80211_HDRLEN - 1;
-	enum hostapd_hw_mode hw_mode;
-	u8 channel;
-	union fst_session_state_switch_extra evext = {
-		.to_initial = {0},
-	};
-
-	if (iface != s->data.old_iface) {
-		fst_printf_session(s, MSG_WARNING,
-				   "FST Response dropped: %s is not the old iface",
-				   fst_iface_get_name(iface));
-		return;
-	}
-
-	if (!fst_session_is_ready_pending(s)) {
-		fst_printf_session(s, MSG_WARNING,
-				   "FST Response dropped due to wrong state: %s",
-				   fst_session_state_name(s->state));
-		return;
-	}
-
-	if (plen < sizeof(*res)) {
-		fst_printf_session(s, MSG_WARNING,
-				   "Too short FST Response dropped");
-		return;
-	}
-	res = (const struct fst_setup_res *)
-		(((const u8 *) mgmt) + IEEE80211_HDRLEN + 1);
-	if (res->stie.element_id != WLAN_EID_SESSION_TRANSITION ||
-	    res->stie.length < 11) {
-		fst_printf_iface(iface, MSG_WARNING,
-				 "FST Response dropped: invalid STIE");
-		return;
-	}
-
-	if (res->dialog_token != s->data.pending_setup_req_dlgt)  {
-		fst_printf_session(s, MSG_WARNING,
-				   "FST Response dropped due to wrong dialog token (%u != %u)",
-				   s->data.pending_setup_req_dlgt,
-				   res->dialog_token);
-		return;
-	}
-
-	if (res->status_code == WLAN_STATUS_SUCCESS &&
-	    le_to_host32(res->stie.fsts_id) != s->data.fsts_id) {
-		fst_printf_session(s, MSG_WARNING,
-				   "FST Response dropped due to wrong FST Session ID (%u)",
-				   le_to_host32(res->stie.fsts_id));
-		return;
-	}
-
-	fst_session_stt_disarm(s);
-
-	if (res->status_code != WLAN_STATUS_SUCCESS) {
-		/*
-		 * 10.32.2.2  Transitioning between states
-		 * The initiator shall set the STT to the value of the
-		 * FSTSessionTimeOut field at ... and at each ACK frame sent in
-		 * response to a received FST Setup Response with the Status
-		 * Code field equal to PENDING_ADMITTING_FST_SESSION or
-		 * PENDING_GAP_IN_BA_WINDOW.
-		 */
-		evext.to_initial.reason = REASON_REJECT;
-		evext.to_initial.reject_code = res->status_code;
-		evext.to_initial.initiator = FST_INITIATOR_REMOTE;
-		fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &evext);
-		fst_printf_session(s, MSG_WARNING,
-				   "FST Setup rejected by remote side with status %u",
-				   res->status_code);
-		return;
-	}
-
-	fst_iface_get_channel_info(s->data.new_iface, &hw_mode, &channel);
-
-	if (fst_hw_mode_to_band(hw_mode) != res->stie.new_band_id) {
-		evext.to_initial.reason = REASON_ERROR_PARAMS;
-		fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &evext);
-		fst_printf_session(s, MSG_WARNING,
-				   "invalid FST Setup parameters");
-		fst_session_tear_down_setup(s);
-		return;
-	}
-
-	fst_printf_session(s, MSG_INFO,
-			   "%s: FST Setup established for %s (llt=%u)",
-			   fst_iface_get_name(s->data.old_iface),
-			   fst_iface_get_name(s->data.new_iface),
-			   s->data.llt_ms);
-
-	fst_session_notify_ctrl(s, EVENT_FST_ESTABLISHED, NULL);
-
-	if (s->data.llt_ms == FST_LLT_SWITCH_IMMEDIATELY)
-		fst_session_initiate_switch(s);
-}
-
-
-static void fst_session_handle_tear_down(struct fst_session *s,
-					 struct fst_iface *iface,
-					 const struct ieee80211_mgmt *mgmt,
-					 size_t frame_len)
-{
-	const struct fst_tear_down *td;
-	size_t plen = frame_len - IEEE80211_HDRLEN - 1;
-	union fst_session_state_switch_extra evext = {
-		.to_initial = {
-			.reason = REASON_TEARDOWN,
-			.initiator = FST_INITIATOR_REMOTE,
-		},
-	};
-
-	if (plen < sizeof(*td)) {
-		fst_printf_session(s, MSG_WARNING,
-				   "Too short FST Tear Down dropped");
-		return;
-	}
-	td = (const struct fst_tear_down *)
-		(((const u8 *) mgmt) + IEEE80211_HDRLEN + 1);
-
-	if (le_to_host32(td->fsts_id) != s->data.fsts_id) {
-		fst_printf_siface(s, iface, MSG_WARNING,
-				  "tear down for wrong FST Setup ID (%u)",
-				  le_to_host32(td->fsts_id));
-		return;
-	}
-
-	fst_session_stt_disarm(s);
-
-	fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &evext);
-}
-
-
-static void fst_session_handle_ack_request(struct fst_session *s,
-					   struct fst_iface *iface,
-					   const struct ieee80211_mgmt *mgmt,
-					   size_t frame_len)
-{
-	const struct fst_ack_req *req;
-	size_t plen = frame_len - IEEE80211_HDRLEN - 1;
-	struct fst_ack_res res;
-	union fst_session_state_switch_extra evext = {
-		.to_initial = {
-			.reason = REASON_SWITCH,
-			.initiator = FST_INITIATOR_REMOTE,
-		},
-	};
-
-	if (!fst_session_is_ready(s) && !fst_session_is_switch_requested(s)) {
-		fst_printf_siface(s, iface, MSG_ERROR,
-				  "cannot initiate switch due to wrong session state (%s)",
-				  fst_session_state_name(s->state));
-		return;
-	}
-
-	WPA_ASSERT(s->data.new_iface != NULL);
-
-	if (iface != s->data.new_iface) {
-		fst_printf_siface(s, iface, MSG_ERROR,
-				  "Ack received on wrong interface");
-		return;
-	}
-
-	if (plen < sizeof(*req)) {
-		fst_printf_session(s, MSG_WARNING,
-				   "Too short FST Ack Request dropped");
-		return;
-	}
-	req = (const struct fst_ack_req *)
-		(((const u8 *) mgmt) + IEEE80211_HDRLEN + 1);
-
-	if (le_to_host32(req->fsts_id) != s->data.fsts_id) {
-		fst_printf_siface(s, iface, MSG_WARNING,
-				  "Ack for wrong FST Setup ID (%u)",
-				  le_to_host32(req->fsts_id));
-		return;
-	}
-
-	os_memset(&res, 0, sizeof(res));
-
-	res.action = FST_ACTION_ACK_RESPONSE;
-	res.dialog_token = req->dialog_token;
-	res.fsts_id = req->fsts_id;
-
-	if (!fst_session_send_action(s, FALSE, &res, sizeof(res), NULL)) {
-		fst_printf_sframe(s, FALSE, MSG_INFO, "FST Ack Response sent");
-		fst_session_stt_disarm(s);
-		fst_session_set_state(s, FST_SESSION_STATE_TRANSITION_DONE,
-				      NULL);
-		fst_session_set_state(s, FST_SESSION_STATE_TRANSITION_CONFIRMED,
-				      NULL);
-		fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &evext);
-	}
-}
-
-
-static void
-fst_session_handle_ack_response(struct fst_session *s,
-				struct fst_iface *iface,
-				const struct ieee80211_mgmt *mgmt,
-				size_t frame_len)
-{
-	const struct fst_ack_res *res;
-	size_t plen = frame_len - IEEE80211_HDRLEN - 1;
-	union fst_session_state_switch_extra evext = {
-		.to_initial = {
-			.reason = REASON_SWITCH,
-			.initiator = FST_INITIATOR_LOCAL,
-		},
-	};
-
-	if (!fst_session_is_switch_requested(s)) {
-		fst_printf_siface(s, iface, MSG_ERROR,
-				  "Ack Response in inappropriate session state (%s)",
-				  fst_session_state_name(s->state));
-		return;
-	}
-
-	WPA_ASSERT(s->data.new_iface != NULL);
-
-	if (iface != s->data.new_iface) {
-		fst_printf_siface(s, iface, MSG_ERROR,
-				  "Ack response received on wrong interface");
-		return;
-	}
-
-	if (plen < sizeof(*res)) {
-		fst_printf_session(s, MSG_WARNING,
-				   "Too short FST Ack Response dropped");
-		return;
-	}
-	res = (const struct fst_ack_res *)
-		(((const u8 *) mgmt) + IEEE80211_HDRLEN + 1);
-
-	if (le_to_host32(res->fsts_id) != s->data.fsts_id) {
-		fst_printf_siface(s, iface, MSG_ERROR,
-				  "Ack response for wrong FST Setup ID (%u)",
-				  le_to_host32(res->fsts_id));
-		return;
-	}
-
-	fst_session_set_state(s, FST_SESSION_STATE_TRANSITION_CONFIRMED, NULL);
-	fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &evext);
-
-	fst_session_stt_disarm(s);
-}
-
-
-struct fst_session * fst_session_create(struct fst_group *g)
-{
-	struct fst_session *s;
-	u32 id;
-
-	WPA_ASSERT(!is_zero_ether_addr(own_addr));
-
-	id = fst_find_free_session_id();
-	if (id == FST_INVALID_SESSION_ID) {
-		fst_printf(MSG_ERROR, "Cannot assign new session ID");
-		return NULL;
-	}
-
-	s = os_zalloc(sizeof(*s));
-	if (!s) {
-		fst_printf(MSG_ERROR, "Cannot allocate new session object");
-		return NULL;
-	}
-
-	s->id = id;
-	s->group = g;
-	s->state = FST_SESSION_STATE_INITIAL;
-
-	s->data.llt_ms = FST_LLT_MS_DEFAULT;
-
-	fst_printf(MSG_INFO, "Session %u created", s->id);
-
-	dl_list_add_tail(&global_sessions_list, &s->global_sessions_lentry);
-
-	foreach_fst_ctrl_call(on_session_added, s);
-
-	return s;
-}
-
-
-void fst_session_set_iface(struct fst_session *s, struct fst_iface *iface,
-			   Boolean is_old)
-{
-	if (is_old)
-		s->data.old_iface = iface;
-	else
-		s->data.new_iface = iface;
-
-}
-
-
-void fst_session_set_llt(struct fst_session *s, u32 llt)
-{
-	s->data.llt_ms = llt;
-}
-
-
-void fst_session_set_peer_addr(struct fst_session *s, const u8 *addr,
-			       Boolean is_old)
-{
-	u8 *a = is_old ? s->data.old_peer_addr : s->data.new_peer_addr;
-
-	os_memcpy(a, addr, ETH_ALEN);
-}
-
-
-int fst_session_initiate_setup(struct fst_session *s)
-{
-	struct fst_setup_req req;
-	int res;
-	u32 fsts_id;
-	u8 dialog_token;
-	struct fst_session *_s;
-
-	if (fst_session_is_in_progress(s)) {
-		fst_printf_session(s, MSG_ERROR, "Session in progress");
-		return -EINVAL;
-	}
-
-	if (is_zero_ether_addr(s->data.old_peer_addr)) {
-		fst_printf_session(s, MSG_ERROR, "No old peer MAC address");
-		return -EINVAL;
-	}
-
-	if (is_zero_ether_addr(s->data.new_peer_addr)) {
-		fst_printf_session(s, MSG_ERROR, "No new peer MAC address");
-		return -EINVAL;
-	}
-
-	if (!s->data.old_iface) {
-		fst_printf_session(s, MSG_ERROR, "No old interface defined");
-		return -EINVAL;
-	}
-
-	if (!s->data.new_iface) {
-		fst_printf_session(s, MSG_ERROR, "No new interface defined");
-		return -EINVAL;
-	}
-
-	if (s->data.new_iface == s->data.old_iface) {
-		fst_printf_session(s, MSG_ERROR,
-				   "Same interface set as old and new");
-		return -EINVAL;
-	}
-
-	if (!fst_iface_is_connected(s->data.old_iface, s->data.old_peer_addr,
-				    FALSE)) {
-		fst_printf_session(s, MSG_ERROR,
-				   "The preset old peer address is not connected");
-		return -EINVAL;
-	}
-
-	if (!fst_iface_is_connected(s->data.new_iface, s->data.new_peer_addr,
-				    FALSE)) {
-		fst_printf_session(s, MSG_ERROR,
-				   "The preset new peer address is not connected");
-		return -EINVAL;
-	}
-
-	_s = fst_find_session_in_progress(s->data.old_peer_addr, s->group);
-	if (_s) {
-		fst_printf_session(s, MSG_ERROR,
-				   "There is another session in progress (old): %u",
-				   _s->id);
-		return -EINVAL;
-	}
-
-	_s = fst_find_session_in_progress(s->data.new_peer_addr, s->group);
-	if (_s) {
-		fst_printf_session(s, MSG_ERROR,
-				   "There is another session in progress (new): %u",
-				   _s->id);
-		return -EINVAL;
-	}
-
-	dialog_token = fst_group_assign_dialog_token(s->group);
-	fsts_id = fst_group_assign_fsts_id(s->group);
-
-	os_memset(&req, 0, sizeof(req));
-
-	fst_printf_siface(s, s->data.old_iface, MSG_INFO,
-		"initiating FST setup for %s (llt=%u ms)",
-		fst_iface_get_name(s->data.new_iface), s->data.llt_ms);
-
-	req.action = FST_ACTION_SETUP_REQUEST;
-	req.dialog_token = dialog_token;
-	req.llt = host_to_le32(FST_LLT_MS_TO_VAL(s->data.llt_ms));
-	/* 8.4.2.147 Session Transition element */
-	req.stie.element_id = WLAN_EID_SESSION_TRANSITION;
-	req.stie.length = sizeof(req.stie) - 2;
-	req.stie.fsts_id = host_to_le32(fsts_id);
-	req.stie.session_control = SESSION_CONTROL(SESSION_TYPE_BSS, 0);
-
-	req.stie.new_band_id = fst_iface_get_band_id(s->data.new_iface);
-	req.stie.new_band_op = 1;
-	req.stie.new_band_setup = 0;
-
-	req.stie.old_band_id = fst_iface_get_band_id(s->data.old_iface);
-	req.stie.old_band_op = 1;
-	req.stie.old_band_setup = 0;
-
-	res = fst_session_send_action(s, TRUE, &req, sizeof(req),
-				      fst_iface_get_mbie(s->data.old_iface));
-	if (!res) {
-		s->data.fsts_id = fsts_id;
-		s->data.pending_setup_req_dlgt = dialog_token;
-		fst_printf_sframe(s, TRUE, MSG_INFO, "FST Setup Request sent");
-		fst_session_set_state(s, FST_SESSION_STATE_SETUP_COMPLETION,
-				      NULL);
-
-		fst_session_stt_arm(s);
-	}
-
-	return res;
-}
-
-
-int fst_session_respond(struct fst_session *s, u8 status_code)
-{
-	struct fst_setup_res res;
-	enum hostapd_hw_mode hw_mode;
-	u8 channel;
-
-	if (!fst_session_is_ready_pending(s)) {
-		fst_printf_session(s, MSG_ERROR, "incorrect state: %s",
-				   fst_session_state_name(s->state));
-		return -EINVAL;
-	}
-
-	if (is_zero_ether_addr(s->data.old_peer_addr)) {
-		fst_printf_session(s, MSG_ERROR, "No peer MAC address");
-		return -EINVAL;
-	}
-
-	if (!s->data.old_iface) {
-		fst_printf_session(s, MSG_ERROR, "No old interface defined");
-		return -EINVAL;
-	}
-
-	if (!s->data.new_iface) {
-		fst_printf_session(s, MSG_ERROR, "No new interface defined");
-		return -EINVAL;
-	}
-
-	if (s->data.new_iface == s->data.old_iface) {
-		fst_printf_session(s, MSG_ERROR,
-				   "Same interface set as old and new");
-		return -EINVAL;
-	}
-
-	if (!fst_iface_is_connected(s->data.old_iface,
-				    s->data.old_peer_addr, FALSE)) {
-		fst_printf_session(s, MSG_ERROR,
-				   "The preset peer address is not in the peer list");
-		return -EINVAL;
-	}
-
-	fst_session_stt_disarm(s);
-
-	os_memset(&res, 0, sizeof(res));
-
-	res.action = FST_ACTION_SETUP_RESPONSE;
-	res.dialog_token = s->data.pending_setup_req_dlgt;
-	res.status_code = status_code;
-
-	res.stie.element_id = WLAN_EID_SESSION_TRANSITION;
-	res.stie.length = sizeof(res.stie) - 2;
-
-	if (status_code == WLAN_STATUS_SUCCESS) {
-		res.stie.fsts_id = s->data.fsts_id;
-		res.stie.session_control = SESSION_CONTROL(SESSION_TYPE_BSS, 0);
-
-		fst_iface_get_channel_info(s->data.new_iface, &hw_mode,
-					   &channel);
-		res.stie.new_band_id = fst_hw_mode_to_band(hw_mode);
-		res.stie.new_band_op = 1;
-		res.stie.new_band_setup = 0;
-
-		fst_iface_get_channel_info(s->data.old_iface, &hw_mode,
-					   &channel);
-		res.stie.old_band_id = fst_hw_mode_to_band(hw_mode);
-		res.stie.old_band_op = 1;
-		res.stie.old_band_setup = 0;
-
-		fst_printf_session(s, MSG_INFO,
-				   "%s: FST Setup Request accepted for %s (llt=%u)",
-				   fst_iface_get_name(s->data.old_iface),
-				   fst_iface_get_name(s->data.new_iface),
-				   s->data.llt_ms);
-	} else {
-		fst_printf_session(s, MSG_WARNING,
-				   "%s: FST Setup Request rejected with code %d",
-				   fst_iface_get_name(s->data.old_iface),
-				   status_code);
-	}
-
-	if (fst_session_send_action(s, TRUE, &res, sizeof(res),
-				    fst_iface_get_mbie(s->data.old_iface))) {
-		fst_printf_sframe(s, TRUE, MSG_ERROR,
-				  "cannot send FST Setup Response with code %d",
-				  status_code);
-		return -EINVAL;
-	}
-
-	fst_printf_sframe(s, TRUE, MSG_INFO, "FST Setup Response sent");
-
-	if (status_code != WLAN_STATUS_SUCCESS) {
-		union fst_session_state_switch_extra evext = {
-			.to_initial = {
-				.reason = REASON_REJECT,
-				.reject_code = status_code,
-				.initiator = FST_INITIATOR_LOCAL,
-			},
-		};
-		fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &evext);
-	}
-
-	return 0;
-}
-
-
-int fst_session_initiate_switch(struct fst_session *s)
-{
-	struct fst_ack_req req;
-	int res;
-	u8 dialog_token;
-
-	if (!fst_session_is_ready(s)) {
-		fst_printf_session(s, MSG_ERROR,
-				   "cannot initiate switch due to wrong setup state (%d)",
-				   s->state);
-		return -1;
-	}
-
-	dialog_token = fst_group_assign_dialog_token(s->group);
-
-	WPA_ASSERT(s->data.new_iface != NULL);
-	WPA_ASSERT(s->data.old_iface != NULL);
-
-	fst_printf_session(s, MSG_INFO, "initiating FST switch: %s => %s",
-			   fst_iface_get_name(s->data.old_iface),
-			   fst_iface_get_name(s->data.new_iface));
-
-	os_memset(&req, 0, sizeof(req));
-
-	req.action = FST_ACTION_ACK_REQUEST;
-	req.dialog_token = dialog_token;
-	req.fsts_id = host_to_le32(s->data.fsts_id);
-
-	res = fst_session_send_action(s, FALSE, &req, sizeof(req), NULL);
-	if (!res) {
-		fst_printf_sframe(s, FALSE, MSG_INFO, "FST Ack Request sent");
-		fst_session_set_state(s, FST_SESSION_STATE_TRANSITION_DONE,
-				      NULL);
-		fst_session_stt_arm(s);
-	} else {
-		fst_printf_sframe(s, FALSE, MSG_ERROR,
-				  "Cannot send FST Ack Request");
-	}
-
-	return res;
-}
-
-
-void fst_session_handle_action(struct fst_session *s,
-			       struct fst_iface *iface,
-			       const struct ieee80211_mgmt *mgmt,
-			       size_t frame_len)
-{
-	switch (mgmt->u.action.u.fst_action.action) {
-	case FST_ACTION_SETUP_REQUEST:
-		WPA_ASSERT(0);
-		break;
-	case FST_ACTION_SETUP_RESPONSE:
-		fst_session_handle_setup_response(s, iface, mgmt, frame_len);
-		break;
-	case FST_ACTION_TEAR_DOWN:
-		fst_session_handle_tear_down(s, iface, mgmt, frame_len);
-		break;
-	case FST_ACTION_ACK_REQUEST:
-		fst_session_handle_ack_request(s, iface, mgmt, frame_len);
-		break;
-	case FST_ACTION_ACK_RESPONSE:
-		fst_session_handle_ack_response(s, iface, mgmt, frame_len);
-		break;
-	case FST_ACTION_ON_CHANNEL_TUNNEL:
-	default:
-		fst_printf_sframe(s, FALSE, MSG_ERROR,
-				  "Unsupported FST Action frame");
-		break;
-	}
-}
-
-
-int fst_session_tear_down_setup(struct fst_session *s)
-{
-	int res;
-	union fst_session_state_switch_extra evext = {
-		.to_initial = {
-			.reason = REASON_TEARDOWN,
-			.initiator = FST_INITIATOR_LOCAL,
-		},
-	};
-
-	res = fst_session_send_tear_down(s);
-
-	fst_session_set_state(s, FST_SESSION_STATE_INITIAL, &evext);
-
-	return res;
-}
-
-
-void fst_session_reset(struct fst_session *s)
-{
-	fst_session_reset_ex(s, REASON_RESET);
-}
-
-
-void fst_session_delete(struct fst_session *s)
-{
-	fst_printf(MSG_INFO, "Session %u deleted", s->id);
-	dl_list_del(&s->global_sessions_lentry);
-	foreach_fst_ctrl_call(on_session_removed, s);
-	os_free(s);
-}
-
-
-struct fst_group * fst_session_get_group(struct fst_session *s)
-{
-	return s->group;
-}
-
-
-struct fst_iface * fst_session_get_iface(struct fst_session *s, Boolean is_old)
-{
-	return is_old ? s->data.old_iface : s->data.new_iface;
-}
-
-
-u32 fst_session_get_id(struct fst_session *s)
-{
-	return s->id;
-}
-
-
-const u8 * fst_session_get_peer_addr(struct fst_session *s, Boolean is_old)
-{
-	return is_old ? s->data.old_peer_addr : s->data.new_peer_addr;
-}
-
-
-u32 fst_session_get_llt(struct fst_session *s)
-{
-	return s->data.llt_ms;
-}
-
-
-enum fst_session_state fst_session_get_state(struct fst_session *s)
-{
-	return s->state;
-}
-
-
-struct fst_session * fst_session_get_by_id(u32 id)
-{
-	struct fst_session *s;
-
-	foreach_fst_session(s) {
-		if (id == s->id)
-			return s;
-	}
-
-	return NULL;
-}
-
-
-void fst_session_enum(struct fst_group *g, fst_session_enum_clb clb, void *ctx)
-{
-	struct fst_session *s;
-
-	foreach_fst_session(s) {
-		if (!g || s->group == g)
-			clb(s->group, s, ctx);
-	}
-}
-
-
-void fst_session_on_action_rx(struct fst_iface *iface,
-			      const struct ieee80211_mgmt *mgmt,
-			      size_t len)
-{
-	struct fst_session *s;
-
-	if (len < IEEE80211_HDRLEN + 2 ||
-	    mgmt->u.action.category != WLAN_ACTION_FST) {
-		fst_printf_iface(iface, MSG_ERROR,
-				 "invalid Action frame received");
-		return;
-	}
-
-	if (mgmt->u.action.u.fst_action.action <= FST_ACTION_MAX_SUPPORTED) {
-		fst_printf_iface(iface, MSG_DEBUG,
-				 "FST Action '%s' received!",
-				 fst_action_names[mgmt->u.action.u.fst_action.action]);
-	} else {
-		fst_printf_iface(iface, MSG_WARNING,
-				 "unknown FST Action (%u) received!",
-				 mgmt->u.action.u.fst_action.action);
-		return;
-	}
-
-	if (mgmt->u.action.u.fst_action.action == FST_ACTION_SETUP_REQUEST) {
-		fst_session_handle_setup_request(iface, mgmt, len);
-		return;
-	}
-
-	s = fst_find_session_in_progress(mgmt->sa, fst_iface_get_group(iface));
-	if (s) {
-		fst_session_handle_action(s, iface, mgmt, len);
-	} else {
-		fst_printf_iface(iface, MSG_WARNING,
-				 "FST Action '%s' dropped: no session in progress found",
-				 fst_action_names[mgmt->u.action.u.fst_action.action]);
-	}
-}
-
-
-int fst_session_set_str_ifname(struct fst_session *s, const char *ifname,
-			       Boolean is_old)
-{
-	struct fst_group *g = fst_session_get_group(s);
-	struct fst_iface *i;
-
-	i = fst_group_get_iface_by_name(g, ifname);
-	if (!i) {
-		fst_printf_session(s, MSG_WARNING,
-				   "Cannot set iface %s: no such iface within group '%s'",
-				   ifname, fst_group_get_id(g));
-		return -1;
-	}
-
-	fst_session_set_iface(s, i, is_old);
-
-	return 0;
-}
-
-
-int fst_session_set_str_peer_addr(struct fst_session *s, const char *mac,
-				  Boolean is_old)
-{
-	u8 peer_addr[ETH_ALEN];
-	int res = fst_read_peer_addr(mac, peer_addr);
-
-	if (res)
-		return res;
-
-	fst_session_set_peer_addr(s, peer_addr, is_old);
-
-	return 0;
-}
-
-
-int fst_session_set_str_llt(struct fst_session *s, const char *llt_str)
-{
-	char *endp;
-	long int llt = strtol(llt_str, &endp, 0);
-
-	if (*endp || llt < 0 || (unsigned long int) llt > FST_MAX_LLT_MS) {
-		fst_printf_session(s, MSG_WARNING,
-				   "Cannot set llt %s: Invalid llt value (1..%u expected)",
-				   llt_str, FST_MAX_LLT_MS);
-		return -1;
-	}
-	fst_session_set_llt(s, (u32) llt);
-
-	return 0;
-}
-
-
-void fst_session_global_on_iface_detached(struct fst_iface *iface)
-{
-	struct fst_session *s;
-
-	foreach_fst_session(s) {
-		if (fst_session_is_in_progress(s) &&
-		    (s->data.new_iface == iface ||
-		     s->data.old_iface == iface))
-			fst_session_reset_ex(s, REASON_DETACH_IFACE);
-	}
-}
-
-
-struct fst_session * fst_session_global_get_first_by_group(struct fst_group *g)
-{
-	struct fst_session *s;
-
-	foreach_fst_session(s) {
-		if (s->group == g)
-			return s;
-	}
-
-	return NULL;
-}
-
-
-#ifdef CONFIG_FST_TEST
-
-static int get_group_fill_session(struct fst_group **g, struct fst_session *s)
-{
-	const u8 *old_addr, *new_addr;
-	struct fst_get_peer_ctx *ctx;
-
-	os_memset(s, 0, sizeof(*s));
-	foreach_fst_group(*g) {
-		s->data.new_iface = fst_group_first_iface(*g);
-		if (s->data.new_iface)
-			break;
-	}
-	if (!s->data.new_iface)
-		return -EINVAL;
-
-	s->data.old_iface = dl_list_entry(s->data.new_iface->group_lentry.next,
-					  struct fst_iface, group_lentry);
-	if (!s->data.old_iface)
-		return -EINVAL;
-
-	old_addr = fst_iface_get_peer_first(s->data.old_iface, &ctx, TRUE);
-	if (!old_addr)
-		return -EINVAL;
-
-	new_addr = fst_iface_get_peer_first(s->data.new_iface, &ctx, TRUE);
-	if (!new_addr)
-		return -EINVAL;
-
-	os_memcpy(s->data.old_peer_addr, old_addr, ETH_ALEN);
-	os_memcpy(s->data.new_peer_addr, new_addr, ETH_ALEN);
-
-	return 0;
-}
-
-
-#define FST_MAX_COMMAND_WORD_NAME_LENGTH 16
-
-int fst_test_req_send_fst_request(const char *params)
-{
-	int fsts_id;
-	Boolean is_valid;
-	char *endp;
-	struct fst_setup_req req;
-	struct fst_session s;
-	struct fst_group *g;
-	enum hostapd_hw_mode hw_mode;
-	u8 channel;
-	char additional_param[FST_MAX_COMMAND_WORD_NAME_LENGTH];
-
-	if (params[0] != ' ')
-		return -EINVAL;
-	params++;
-	fsts_id = fst_read_next_int_param(params, &is_valid, &endp);
-	if (!is_valid)
-		return -EINVAL;
-
-	if (get_group_fill_session(&g, &s))
-		return -EINVAL;
-
-	req.action = FST_ACTION_SETUP_REQUEST;
-	req.dialog_token = g->dialog_token;
-	req.llt = host_to_le32(FST_LLT_MS_DEFAULT);
-	/* 8.4.2.147 Session Transition element */
-	req.stie.element_id = WLAN_EID_SESSION_TRANSITION;
-	req.stie.length = sizeof(req.stie) - 2;
-	req.stie.fsts_id = host_to_le32(fsts_id);
-	req.stie.session_control = SESSION_CONTROL(SESSION_TYPE_BSS, 0);
-
-	fst_iface_get_channel_info(s.data.new_iface, &hw_mode, &channel);
-	req.stie.new_band_id = fst_hw_mode_to_band(hw_mode);
-	req.stie.new_band_op = 1;
-	req.stie.new_band_setup = 0;
-
-	fst_iface_get_channel_info(s.data.old_iface, &hw_mode, &channel);
-	req.stie.old_band_id = fst_hw_mode_to_band(hw_mode);
-	req.stie.old_band_op = 1;
-	req.stie.old_band_setup = 0;
-
-	if (!fst_read_next_text_param(endp, additional_param,
-				       sizeof(additional_param), &endp)) {
-		if (!os_strcasecmp(additional_param, FST_CTR_PVAL_BAD_NEW_BAND))
-			req.stie.new_band_id = req.stie.old_band_id;
-	}
-
-	return fst_session_send_action(&s, TRUE, &req, sizeof(req),
-				       s.data.old_iface->mb_ie);
-}
-
-
-int fst_test_req_send_fst_response(const char *params)
-{
-	int fsts_id;
-	Boolean is_valid;
-	char *endp;
-	struct fst_setup_res res;
-	struct fst_session s;
-	struct fst_group *g;
-	enum hostapd_hw_mode hw_mode;
-	u8 status_code;
-	u8 channel;
-	char response[FST_MAX_COMMAND_WORD_NAME_LENGTH];
-	struct fst_session *_s;
-
-	if (params[0] != ' ')
-		return -EINVAL;
-	params++;
-	fsts_id = fst_read_next_int_param(params, &is_valid, &endp);
-	if (!is_valid)
-		return -EINVAL;
-
-	if (get_group_fill_session(&g, &s))
-		return -EINVAL;
-
-	status_code = WLAN_STATUS_SUCCESS;
-	if (!fst_read_next_text_param(endp, response, sizeof(response),
-				      &endp)) {
-		if (!os_strcasecmp(response, FST_CS_PVAL_RESPONSE_REJECT))
-			status_code = WLAN_STATUS_PENDING_ADMITTING_FST_SESSION;
-	}
-
-	os_memset(&res, 0, sizeof(res));
-
-	res.action = FST_ACTION_SETUP_RESPONSE;
-	/*
-	 * If some session has just received an FST Setup Request, then
-	 * use the correct dialog token copied from this request.
-	 */
-	_s = fst_find_session_in_progress(fst_session_get_peer_addr(&s, TRUE),
-					  g);
-	res.dialog_token = (_s && fst_session_is_ready_pending(_s)) ?
-		_s->data.pending_setup_req_dlgt : g->dialog_token;
-	res.status_code  = status_code;
-
-	res.stie.element_id = WLAN_EID_SESSION_TRANSITION;
-	res.stie.length = sizeof(res.stie) - 2;
-
-	if (res.status_code == WLAN_STATUS_SUCCESS) {
-		res.stie.fsts_id = fsts_id;
-		res.stie.session_control = SESSION_CONTROL(SESSION_TYPE_BSS, 0);
-
-		fst_iface_get_channel_info(s.data.new_iface, &hw_mode,
-					    &channel);
-		res.stie.new_band_id = fst_hw_mode_to_band(hw_mode);
-		res.stie.new_band_op = 1;
-		res.stie.new_band_setup = 0;
-
-		fst_iface_get_channel_info(s.data.old_iface, &hw_mode,
-					   &channel);
-		res.stie.old_band_id = fst_hw_mode_to_band(hw_mode);
-		res.stie.old_band_op = 1;
-		res.stie.old_band_setup = 0;
-	}
-
-	if (!fst_read_next_text_param(endp, response, sizeof(response),
-				      &endp)) {
-		if (!os_strcasecmp(response, FST_CTR_PVAL_BAD_NEW_BAND))
-			res.stie.new_band_id = res.stie.old_band_id;
-	}
-
-	return fst_session_send_action(&s, TRUE, &res, sizeof(res),
-				       s.data.old_iface->mb_ie);
-}
-
-
-int fst_test_req_send_ack_request(const char *params)
-{
-	int fsts_id;
-	Boolean is_valid;
-	char *endp;
-	struct fst_ack_req req;
-	struct fst_session s;
-	struct fst_group *g;
-
-	if (params[0] != ' ')
-		return -EINVAL;
-	params++;
-	fsts_id = fst_read_next_int_param(params, &is_valid, &endp);
-	if (!is_valid)
-		return -EINVAL;
-
-	if (get_group_fill_session(&g, &s))
-		return -EINVAL;
-
-	os_memset(&req, 0, sizeof(req));
-	req.action = FST_ACTION_ACK_REQUEST;
-	req.dialog_token = g->dialog_token;
-	req.fsts_id = fsts_id;
-
-	return fst_session_send_action(&s, FALSE, &req, sizeof(req), NULL);
-}
-
-
-int fst_test_req_send_ack_response(const char *params)
-{
-	int fsts_id;
-	Boolean is_valid;
-	char *endp;
-	struct fst_ack_res res;
-	struct fst_session s;
-	struct fst_group *g;
-
-	if (params[0] != ' ')
-		return -EINVAL;
-	params++;
-	fsts_id = fst_read_next_int_param(params, &is_valid, &endp);
-	if (!is_valid)
-		return -EINVAL;
-
-	if (get_group_fill_session(&g, &s))
-		return -EINVAL;
-
-	os_memset(&res, 0, sizeof(res));
-	res.action = FST_ACTION_ACK_RESPONSE;
-	res.dialog_token = g->dialog_token;
-	res.fsts_id = fsts_id;
-
-	return fst_session_send_action(&s, FALSE, &res, sizeof(res), NULL);
-}
-
-
-int fst_test_req_send_tear_down(const char *params)
-{
-	int fsts_id;
-	Boolean is_valid;
-	char *endp;
-	struct fst_tear_down td;
-	struct fst_session s;
-	struct fst_group *g;
-
-	if (params[0] != ' ')
-		return -EINVAL;
-	params++;
-	fsts_id = fst_read_next_int_param(params, &is_valid, &endp);
-	if (!is_valid)
-		return -EINVAL;
-
-	if (get_group_fill_session(&g, &s))
-		return -EINVAL;
-
-	os_memset(&td, 0, sizeof(td));
-	td.action = FST_ACTION_TEAR_DOWN;
-	td.fsts_id = fsts_id;
-
-	return fst_session_send_action(&s, TRUE, &td, sizeof(td), NULL);
-}
-
-
-u32 fst_test_req_get_fsts_id(const char *params)
-{
-	int sid;
-	Boolean is_valid;
-	char *endp;
-	struct fst_session *s;
-
-	if (params[0] != ' ')
-		return FST_FSTS_ID_NOT_FOUND;
-	params++;
-	sid = fst_read_next_int_param(params, &is_valid, &endp);
-	if (!is_valid)
-		return FST_FSTS_ID_NOT_FOUND;
-
-	s = fst_session_get_by_id(sid);
-	if (!s)
-		return FST_FSTS_ID_NOT_FOUND;
-
-	return s->data.fsts_id;
-}
-
-
-int fst_test_req_get_local_mbies(const char *request, char *buf, size_t buflen)
-{
-	char *endp;
-	char ifname[FST_MAX_COMMAND_WORD_NAME_LENGTH];
-	struct fst_group *g;
-	struct fst_iface *iface;
-
-	if (request[0] != ' ')
-		return -EINVAL;
-	request++;
-	if (fst_read_next_text_param(request, ifname, sizeof(ifname), &endp) ||
-	    !*ifname)
-		goto problem;
-	g = dl_list_first(&fst_global_groups_list, struct fst_group,
-			  global_groups_lentry);
-	if (!g)
-		goto problem;
-	iface = fst_group_get_iface_by_name(g, ifname);
-	if (!iface || !iface->mb_ie)
-		goto problem;
-	return wpa_snprintf_hex(buf, buflen, wpabuf_head(iface->mb_ie),
-				wpabuf_len(iface->mb_ie));
-
-problem:
-	return os_snprintf(buf, buflen, "FAIL\n");
-}
-
-#endif /* CONFIG_FST_TEST */
diff --git a/src/fst/fst_session.h b/src/fst/fst_session.h
deleted file mode 100644
index 1162de4..0000000
--- a/src/fst/fst_session.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * FST module - FST Session related definitions
- * Copyright (c) 2014, Qualcomm Atheros, Inc.
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef FST_SESSION_H
-#define FST_SESSION_H
-
-#define FST_DEFAULT_SESSION_TIMEOUT_TU 255 /* u8 */
-
-struct fst_iface;
-struct fst_group;
-struct fst_session;
-enum fst_session_state;
-
-int  fst_session_global_init(void);
-void fst_session_global_deinit(void);
-void fst_session_global_on_iface_detached(struct fst_iface *iface);
-struct fst_session *
-fst_session_global_get_first_by_group(struct fst_group *g);
-
-struct fst_session * fst_session_create(struct fst_group *g);
-void fst_session_set_iface(struct fst_session *s, struct fst_iface *iface,
-			   Boolean is_old);
-void fst_session_set_llt(struct fst_session *s, u32 llt);
-void fst_session_set_peer_addr(struct fst_session *s, const u8 *addr,
-			       Boolean is_old);
-int fst_session_initiate_setup(struct fst_session *s);
-int fst_session_respond(struct fst_session *s, u8 status_code);
-int fst_session_initiate_switch(struct fst_session *s);
-void fst_session_handle_action(struct fst_session *s, struct fst_iface *iface,
-			       const struct ieee80211_mgmt *mgmt,
-			       size_t frame_len);
-int fst_session_tear_down_setup(struct fst_session *s);
-void fst_session_reset(struct fst_session *s);
-void fst_session_delete(struct fst_session *s);
-
-struct fst_group * fst_session_get_group(struct fst_session *s);
-struct fst_iface * fst_session_get_iface(struct fst_session *s, Boolean is_old);
-const u8 * fst_session_get_peer_addr(struct fst_session *s, Boolean is_old);
-u32 fst_session_get_id(struct fst_session *s);
-u32 fst_session_get_llt(struct fst_session *s);
-enum fst_session_state fst_session_get_state(struct fst_session *s);
-
-struct fst_session *fst_session_get_by_id(u32 id);
-
-typedef void (*fst_session_enum_clb)(struct fst_group *g, struct fst_session *s,
-				     void *ctx);
-
-void fst_session_enum(struct fst_group *g, fst_session_enum_clb clb, void *ctx);
-
-void fst_session_on_action_rx(struct fst_iface *iface,
-			      const struct ieee80211_mgmt *mgmt, size_t len);
-
-
-int fst_session_set_str_ifname(struct fst_session *s, const char *ifname,
-			       Boolean is_old);
-int fst_session_set_str_peer_addr(struct fst_session *s, const char *mac,
-				  Boolean is_old);
-int fst_session_set_str_llt(struct fst_session *s, const char *llt_str);
-
-#ifdef CONFIG_FST_TEST
-
-#define FST_FSTS_ID_NOT_FOUND ((u32) -1)
-
-int fst_test_req_send_fst_request(const char *params);
-int fst_test_req_send_fst_response(const char *params);
-int fst_test_req_send_ack_request(const char *params);
-int fst_test_req_send_ack_response(const char *params);
-int fst_test_req_send_tear_down(const char *params);
-u32 fst_test_req_get_fsts_id(const char *params);
-int fst_test_req_get_local_mbies(const char *request, char *buf,
-				 size_t buflen);
-
-#endif /* CONFIG_FST_TEST */
-
-#endif /* FST_SESSION_H */
diff --git a/src/p2p/p2p.c b/src/p2p/p2p.c
index 8c55302..0b31c1e 100644
--- a/src/p2p/p2p.c
+++ b/src/p2p/p2p.c
@@ -10,7 +10,6 @@
 
 #include "common.h"
 #include "eloop.h"
-#include "common/defs.h"
 #include "common/ieee802_11_defs.h"
 #include "common/ieee802_11_common.h"
 #include "common/wpa_ctrl.h"
@@ -456,9 +455,8 @@ static struct p2p_device * p2p_create_device(struct p2p_data *p2p,
 static void p2p_copy_client_info(struct p2p_device *dev,
 				 struct p2p_client_info *cli)
 {
-	p2p_copy_filter_devname(dev->info.device_name,
-				sizeof(dev->info.device_name),
-				cli->dev_name, cli->dev_name_len);
+	os_memcpy(dev->info.device_name, cli->dev_name, cli->dev_name_len);
+	dev->info.device_name[cli->dev_name_len] = '\0';
 	dev->info.dev_capab = cli->dev_capab;
 	dev->info.config_methods = cli->config_methods;
 	os_memcpy(dev->info.pri_dev_type, cli->pri_dev_type, 8);
@@ -3434,8 +3432,7 @@ void p2p_scan_res_handled(struct p2p_data *p2p)
 }
 
 
-void p2p_scan_ie(struct p2p_data *p2p, struct wpabuf *ies, const u8 *dev_id,
-		 unsigned int bands)
+void p2p_scan_ie(struct p2p_data *p2p, struct wpabuf *ies, const u8 *dev_id)
 {
 	u8 dev_capab;
 	u8 *len;
@@ -3469,9 +3466,6 @@ void p2p_scan_ie(struct p2p_data *p2p, struct wpabuf *ies, const u8 *dev_id,
 		p2p_buf_add_ext_listen_timing(ies, p2p->ext_listen_period,
 					      p2p->ext_listen_interval);
 
-	if (bands & BAND_60_GHZ)
-		p2p_buf_add_device_info(ies, p2p, NULL);
-
 	if (p2p->p2ps_seek && p2p->p2ps_seek_count)
 		p2p_buf_add_service_hash(ies, p2p);
 
@@ -3706,8 +3700,6 @@ void p2p_send_action_cb(struct p2p_data *p2p, unsigned int freq, const u8 *dst,
 		break;
 	case P2P_PENDING_INVITATION_RESPONSE:
 		p2p_invitation_resp_cb(p2p, success);
-		if (p2p->inv_status != P2P_SC_SUCCESS)
-			p2p_check_after_scan_tx_continuation(p2p);
 		break;
 	case P2P_PENDING_DEV_DISC_REQUEST:
 		p2p_dev_disc_req_cb(p2p, success);
@@ -3809,6 +3801,10 @@ int p2p_listen_end(struct p2p_data *p2p, unsigned int freq)
 		return 1;
 	}
 
+	/* Sprd Bug#447946 20150618 Bgn */
+	p2p->pending_listen_freq = 0;
+	/* Sprd Bug#447946 20150618 End */
+
 	return 0;
 }
 
@@ -3884,6 +3880,9 @@ static void p2p_timeout_wait_peer_idle(struct p2p_data *p2p)
 
 	p2p_dbg(p2p, "Go to Listen state while waiting for the peer to become ready for GO Negotiation");
 	p2p_set_state(p2p, P2P_WAIT_PEER_CONNECT);
+	/* Sprd Bug#447946 20150618 Bgn */
+	p2p_set_timeout(p2p, 1, 0);
+	/* Sprd Bug#447946 20150618 End */
 	p2p_listen_in_find(p2p, 0);
 }
 
@@ -5397,20 +5396,3 @@ void p2p_go_neg_wait_timeout(void *eloop_ctx, void *timeout_ctx)
 		"Timeout on waiting peer to become ready for GO Negotiation");
 	p2p_go_neg_failed(p2p, -1);
 }
-
-
-void p2p_set_own_pref_freq_list(struct p2p_data *p2p,
-				const unsigned int *pref_freq_list,
-				unsigned int size)
-{
-	unsigned int i;
-
-	if (size > P2P_MAX_PREF_CHANNELS)
-		size = P2P_MAX_PREF_CHANNELS;
-	p2p->num_pref_freq = size;
-	for (i = 0; i < size; i++) {
-		p2p->pref_freq_list[i] = pref_freq_list[i];
-		p2p_dbg(p2p, "Own preferred frequency list[%u]=%u MHz",
-			i, p2p->pref_freq_list[i]);
-	}
-}
diff --git a/src/p2p/p2p.h b/src/p2p/p2p.h
index 9f26d7c..67b8bdb 100644
--- a/src/p2p/p2p.h
+++ b/src/p2p/p2p.h
@@ -23,14 +23,9 @@
 #define P2P_MAX_QUERY_HASH 6
 
 /**
- * P2P_MAX_PREF_CHANNELS - Maximum number of preferred channels
- */
-#define P2P_MAX_PREF_CHANNELS 100
-
-/**
  * P2P_MAX_REG_CLASSES - Maximum number of regulatory classes
  */
-#define P2P_MAX_REG_CLASSES 15
+#define P2P_MAX_REG_CLASSES 10
 
 /**
  * P2P_MAX_REG_CLASS_CHANNELS - Maximum number of channels per regulatory class
@@ -98,10 +93,6 @@ struct p2p_go_neg_results {
 
 	int vht;
 
-	u8 max_oper_chwidth;
-
-	unsigned int vht_center_freq2;
-
 	/**
 	 * ssid - SSID of the group
 	 */
@@ -1038,20 +1029,6 @@ struct p2p_config {
 	 * P2PS_SETUP_* bitmap is used as the parameters and return value.
 	 */
 	u8 (*p2ps_group_capability)(void *ctx, u8 incoming, u8 role);
-
-	/**
-	 * get_pref_freq_list - Get preferred frequency list for an interface
-	 * @ctx: Callback context from cb_ctx
-	 * @go: Whether the use if for GO role
-	 * @len: Length of freq_list in entries (both IN and OUT)
-	 * @freq_list: Buffer for returning the preferred frequencies (MHz)
-	 * Returns: 0 on success, -1 on failure
-	 *
-	 * This function can be used to query the preferred frequency list from
-	 * the driver specific to a particular interface type.
-	 */
-	int (*get_pref_freq_list)(void *ctx, int go,
-				  unsigned int *len, unsigned int *freq_list);
 };
 
 
@@ -1837,10 +1814,8 @@ int p2p_assoc_req_ie(struct p2p_data *p2p, const u8 *bssid, u8 *buf,
  * @p2p: P2P module context from p2p_init()
  * @ies: Buffer for writing P2P IE
  * @dev_id: Device ID to search for or %NULL for any
- * @bands: Frequency bands used in the scan (enum wpa_radio_work_band bitmap)
  */
-void p2p_scan_ie(struct p2p_data *p2p, struct wpabuf *ies, const u8 *dev_id,
-		 unsigned int bands);
+void p2p_scan_ie(struct p2p_data *p2p, struct wpabuf *ies, const u8 *dev_id);
 
 /**
  * p2p_scan_ie_buf_len - Get maximum buffer length needed for p2p_scan_ie
@@ -2278,8 +2253,4 @@ int p2p_service_del_asp(struct p2p_data *p2p, u32 adv_id);
 void p2p_service_flush_asp(struct p2p_data *p2p);
 struct p2ps_advertisement * p2p_get_p2ps_adv_list(struct p2p_data *p2p);
 
-void p2p_set_own_pref_freq_list(struct p2p_data *p2p,
-				const unsigned int *pref_freq_list,
-				unsigned int size);
-
 #endif /* P2P_H */
diff --git a/src/p2p/p2p_build.c b/src/p2p/p2p_build.c
index 793d28b..c733543 100644
--- a/src/p2p/p2p_build.c
+++ b/src/p2p/p2p_build.c
@@ -10,7 +10,6 @@
 
 #include "common.h"
 #include "common/ieee802_11_defs.h"
-#include "common/qca-vendor.h"
 #include "wps/wps_i.h"
 #include "p2p_i.h"
 
@@ -110,44 +109,6 @@ void p2p_buf_add_operating_channel(struct wpabuf *buf, const char *country,
 }
 
 
-void p2p_buf_add_pref_channel_list(struct wpabuf *buf,
-				   const u32 *preferred_freq_list,
-				   unsigned int size)
-{
-	unsigned int i, count = 0;
-	u8 op_class, op_channel;
-
-	if (!size)
-		return;
-
-	/*
-	 * First, determine the number of P2P supported channels in the
-	 * pref_freq_list returned from driver. This is needed for calculations
-	 * of the vendor IE size.
-	 */
-	for (i = 0; i < size; i++) {
-		if (p2p_freq_to_channel(preferred_freq_list[i], &op_class,
-					&op_channel) == 0)
-			count++;
-	}
-
-	wpabuf_put_u8(buf, WLAN_EID_VENDOR_SPECIFIC);
-	wpabuf_put_u8(buf, 4 + count * sizeof(u16));
-	wpabuf_put_be24(buf, OUI_QCA);
-	wpabuf_put_u8(buf, QCA_VENDOR_ELEM_P2P_PREF_CHAN_LIST);
-	for (i = 0; i < size; i++) {
-		if (p2p_freq_to_channel(preferred_freq_list[i], &op_class,
-					&op_channel) < 0) {
-			wpa_printf(MSG_DEBUG, "Unsupported frequency %u MHz",
-				   preferred_freq_list[i]);
-			continue;
-		}
-		wpabuf_put_u8(buf, op_class);
-		wpabuf_put_u8(buf, op_channel);
-	}
-}
-
-
 void p2p_buf_add_channel_list(struct wpabuf *buf, const char *country,
 			      struct p2p_channels *chan)
 {
diff --git a/src/p2p/p2p_go_neg.c b/src/p2p/p2p_go_neg.c
index 3929979..19f1daa 100644
--- a/src/p2p/p2p_go_neg.c
+++ b/src/p2p/p2p_go_neg.c
@@ -185,9 +185,6 @@ static struct wpabuf * p2p_build_go_neg_req(struct p2p_data *p2p,
 				      p2p->op_reg_class, p2p->op_channel);
 	p2p_buf_update_ie_hdr(buf, len);
 
-	p2p_buf_add_pref_channel_list(buf, p2p->pref_freq_list,
-				      p2p->num_pref_freq);
-
 	/* WPS IE with Device Password ID attribute */
 	pw_id = p2p_wps_method_pw_id(peer->wps_method);
 	if (peer->oob_pw_id)
@@ -315,7 +312,7 @@ static struct wpabuf * p2p_build_go_neg_resp(struct p2p_data *p2p,
 			       group_capab);
 	p2p_buf_add_go_intent(buf, (p2p->go_intent << 1) | tie_breaker);
 	p2p_buf_add_config_timeout(buf, p2p->go_timeout, p2p->client_timeout);
-	if (peer && peer->go_state == REMOTE_GO && !p2p->num_pref_freq) {
+	if (peer && peer->go_state == REMOTE_GO) {
 		p2p_dbg(p2p, "Omit Operating Channel attribute");
 	} else {
 		p2p_buf_add_operating_channel(buf, p2p->cfg->country,
@@ -384,7 +381,7 @@ void p2p_reselect_channel(struct p2p_data *p2p,
 	unsigned int i;
 	const int op_classes_5ghz[] = { 124, 125, 115, 0 };
 	const int op_classes_ht40[] = { 126, 127, 116, 117, 0 };
-	const int op_classes_vht[] = { 128, 129, 130, 0 };
+	const int op_classes_vht[] = { 128, 0 };
 
 	if (p2p->own_freq_preference > 0 &&
 	    p2p_freq_to_channel(p2p->own_freq_preference,
@@ -545,195 +542,6 @@ int p2p_go_select_channel(struct p2p_data *p2p, struct p2p_device *dev,
 }
 
 
-static void p2p_check_pref_chan_no_recv(struct p2p_data *p2p, int go,
-					struct p2p_device *dev,
-					struct p2p_message *msg,
-					unsigned freq_list[], unsigned int size)
-{
-	u8 op_class, op_channel;
-	unsigned int oper_freq, i, j;
-	int found = 0;
-
-	p2p_dbg(p2p,
-		"Peer didn't provide a preferred frequency list, see if any of our preferred channels are supported by peer device");
-
-	/*
-	 * Search for a common channel in our preferred frequency list which is
-	 * also supported by the peer device.
-	 */
-	for (i = 0; i < size && !found; i++) {
-		/*
-		 * Make sure that the common frequency is:
-		 * 1. Supported by peer
-		 * 2. Allowed for P2P use.
-		 */
-		oper_freq = freq_list[i];
-		if (p2p_freq_to_channel(oper_freq, &op_class,
-					&op_channel) < 0) {
-			p2p_dbg(p2p, "Unsupported frequency %u MHz", oper_freq);
-			continue;
-		}
-		if (!p2p_channels_includes(&p2p->cfg->channels,
-					   op_class, op_channel) &&
-		    (go || !p2p_channels_includes(&p2p->cfg->cli_channels,
-						  op_class, op_channel))) {
-			p2p_dbg(p2p,
-				"Freq %u MHz (oper_class %u channel %u) not allowed for P2P",
-				oper_freq, op_class, op_channel);
-			break;
-		}
-		for (j = 0; j < msg->channel_list_len; j++) {
-
-			if (op_channel != msg->channel_list[j])
-				continue;
-
-			p2p->op_reg_class = op_class;
-			p2p->op_channel = op_channel;
-			os_memcpy(&p2p->channels, &p2p->cfg->channels,
-				  sizeof(struct p2p_channels));
-			found = 1;
-			break;
-		}
-	}
-
-	if (found) {
-		p2p_dbg(p2p,
-			"Freq %d MHz is a preferred channel and is also supported by peer, use it as the operating channel",
-			oper_freq);
-	} else {
-		p2p_dbg(p2p,
-			"None of our preferred channels are supported by peer!. Use: %d MHz for oper_channel",
-			dev->oper_freq);
-	}
-}
-
-
-static void p2p_check_pref_chan_recv(struct p2p_data *p2p, int go,
-				     struct p2p_device *dev,
-				     struct p2p_message *msg,
-				     unsigned freq_list[], unsigned int size)
-{
-	u8 op_class, op_channel;
-	unsigned int oper_freq, i, j;
-	int found = 0;
-
-	/*
-	 * Peer device supports a Preferred Frequency List.
-	 * Search for a common channel in the preferred frequency lists
-	 * of both peer and local devices.
-	 */
-	for (i = 0; i < size && !found; i++) {
-		for (j = 2; j < (msg->pref_freq_list_len / 2); j++) {
-			oper_freq = p2p_channel_to_freq(
-				msg->pref_freq_list[2 * j],
-				msg->pref_freq_list[2 * j + 1]);
-			if (freq_list[i] != oper_freq)
-				continue;
-
-			/*
-			 * Make sure that the found frequency is:
-			 * 1. Supported
-			 * 2. Allowed for P2P use.
-			 */
-			if (p2p_freq_to_channel(oper_freq, &op_class,
-						&op_channel) < 0) {
-				p2p_dbg(p2p, "Unsupported frequency %u MHz",
-					oper_freq);
-				continue;
-			}
-
-			if (!p2p_channels_includes(&p2p->cfg->channels,
-						   op_class, op_channel) &&
-			    (go ||
-			     !p2p_channels_includes(&p2p->cfg->cli_channels,
-						    op_class, op_channel))) {
-				p2p_dbg(p2p,
-					"Freq %u MHz (oper_class %u channel %u) not allowed for P2P",
-					oper_freq, op_class, op_channel);
-				break;
-			}
-			p2p->op_reg_class = op_class;
-			p2p->op_channel = op_channel;
-			os_memcpy(&p2p->channels, &p2p->cfg->channels,
-				  sizeof(struct p2p_channels));
-			found = 1;
-			break;
-		}
-	}
-
-	if (found) {
-		p2p_dbg(p2p,
-			"Freq %d MHz is a common preferred channel for both peer and local, use it as operating channel",
-			oper_freq);
-	} else {
-		p2p_dbg(p2p,
-			"No common preferred channels found! Use: %d MHz for oper_channel",
-			dev->oper_freq);
-	}
-}
-
-
-void p2p_check_pref_chan(struct p2p_data *p2p, int go,
-			 struct p2p_device *dev, struct p2p_message *msg)
-{
-	unsigned int freq_list[P2P_MAX_PREF_CHANNELS], size;
-	unsigned int i;
-	u8 op_class, op_channel;
-
-	/*
-	 * Use the preferred channel list from the driver only if there is no
-	 * forced_freq, e.g., P2P_CONNECT freq=..., and no preferred operating
-	 * channel hardcoded in the configuration file.
-	 */
-	if (!p2p->cfg->get_pref_freq_list || p2p->cfg->num_pref_chan ||
-	    (dev->flags & P2P_DEV_FORCE_FREQ) || p2p->cfg->cfg_op_channel)
-		return;
-
-	/* Obtain our preferred frequency list from driver based on P2P role. */
-	size = P2P_MAX_PREF_CHANNELS;
-	if (p2p->cfg->get_pref_freq_list(p2p->cfg->cb_ctx, go, &size,
-					 freq_list))
-		return;
-
-	/*
-	 * Check if peer's preference of operating channel is in
-	 * our preferred channel list.
-	 */
-	for (i = 0; i < size; i++) {
-		if (freq_list[i] == (unsigned int) dev->oper_freq)
-			break;
-	}
-	if (i != size) {
-		/* Peer operating channel preference matches our preference */
-		if (p2p_freq_to_channel(freq_list[i], &op_class, &op_channel) <
-		    0) {
-			p2p_dbg(p2p,
-				"Peer operating channel preference is unsupported frequency %u MHz",
-				freq_list[i]);
-		} else {
-			p2p->op_reg_class = op_class;
-			p2p->op_channel = op_channel;
-			os_memcpy(&p2p->channels, &p2p->cfg->channels,
-				  sizeof(struct p2p_channels));
-			return;
-		}
-	}
-
-	p2p_dbg(p2p,
-		"Peer operating channel preference: %d MHz is not in our preferred channel list",
-		dev->oper_freq);
-
-	/*
-	  Check if peer's preferred channel list is
-	  * _not_ included in the GO Negotiation Request or Invitation Request.
-	  */
-	if (msg->pref_freq_list_len == 0)
-		p2p_check_pref_chan_no_recv(p2p, go, dev, msg, freq_list, size);
-	else
-		p2p_check_pref_chan_recv(p2p, go, dev, msg, freq_list, size);
-}
-
-
 void p2p_process_go_neg_req(struct p2p_data *p2p, const u8 *sa,
 			    const u8 *data, size_t len, int rx_freq)
 {
@@ -901,14 +709,6 @@ void p2p_process_go_neg_req(struct p2p_data *p2p, const u8 *sa,
 			return;
 		}
 
-		if (dev->go_neg_req_sent &&
-		    (dev->flags & P2P_DEV_PEER_WAITING_RESPONSE)) {
-			p2p_dbg(p2p,
-				"Do not reply since peer is waiting for us to start a new GO Negotiation and GO Neg Request already sent");
-			p2p_parse_free(&msg);
-			return;
-		}
-
 		go = p2p_go_det(p2p->go_intent, *msg.go_intent);
 		if (go < 0) {
 			p2p_dbg(p2p, "Incompatible GO Intent");
@@ -999,12 +799,6 @@ void p2p_process_go_neg_req(struct p2p_data *p2p, const u8 *sa,
 		p2p_dbg(p2p, "Peer operating channel preference: %d MHz",
 			dev->oper_freq);
 
-		/*
-		 * Use the driver preferred frequency list extension if
-		 * supported.
-		 */
-		p2p_check_pref_chan(p2p, go, dev, &msg);
-
 		if (msg.config_timeout) {
 			dev->go_timeout = msg.config_timeout[0];
 			dev->client_timeout = msg.config_timeout[1];
@@ -1356,13 +1150,6 @@ void p2p_process_go_neg_resp(struct p2p_data *p2p, const u8 *sa,
 	if (go && p2p_go_select_channel(p2p, dev, &status) < 0)
 		goto fail;
 
-	/*
-	 * Use the driver preferred frequency list extension if local device is
-	 * GO.
-	 */
-	if (go)
-		p2p_check_pref_chan(p2p, go, dev, &msg);
-
 	p2p_set_state(p2p, P2P_GO_NEG);
 	p2p_clear_timeout(p2p);
 
diff --git a/src/p2p/p2p_i.h b/src/p2p/p2p_i.h
index 4b01f86..a1042d2 100644
--- a/src/p2p/p2p_i.h
+++ b/src/p2p/p2p_i.h
@@ -535,9 +535,6 @@ struct p2p_data {
 	u16 authorized_oob_dev_pw_id;
 
 	struct wpabuf **vendor_elem;
-
-	unsigned int pref_freq_list[P2P_MAX_PREF_CHANNELS];
-	unsigned int num_pref_freq;
 };
 
 /**
@@ -640,9 +637,6 @@ struct p2p_message {
 	const u8 *persistent_dev;
 	const u8 *persistent_ssid;
 	size_t persistent_ssid_len;
-
-	const u8 *pref_freq_list;
-	size_t pref_freq_list_len;
 };
 
 
@@ -688,8 +682,6 @@ int p2p_channel_random_social(struct p2p_channels *chans, u8 *op_class,
 			      u8 *op_channel);
 
 /* p2p_parse.c */
-void p2p_copy_filter_devname(char *dst, size_t dst_len,
-			     const void *src, size_t src_len);
 int p2p_parse_p2p_ie(const struct wpabuf *buf, struct p2p_message *msg);
 int p2p_parse_ies(const u8 *data, size_t len, struct p2p_message *msg);
 int p2p_parse(const u8 *data, size_t len, struct p2p_message *msg);
@@ -771,8 +763,6 @@ void p2p_buf_add_persistent_group_info(struct wpabuf *buf, const u8 *dev_addr,
 				       const u8 *ssid, size_t ssid_len);
 int p2p_build_wps_ie(struct p2p_data *p2p, struct wpabuf *buf, int pw_id,
 		     int all_attr);
-void p2p_buf_add_pref_channel_list(struct wpabuf *buf,
-				   const u32 *preferred_freq_list, u32 size);
 
 /* p2p_sd.c */
 struct p2p_sd_query * p2p_pending_sd_req(struct p2p_data *p2p,
@@ -802,8 +792,6 @@ int p2p_connect_send(struct p2p_data *p2p, struct p2p_device *dev);
 u16 p2p_wps_method_pw_id(enum p2p_wps_method wps_method);
 void p2p_reselect_channel(struct p2p_data *p2p,
 			  struct p2p_channels *intersection);
-void p2p_check_pref_chan(struct p2p_data *p2p, int go,
-			 struct p2p_device *dev, struct p2p_message *msg);
 
 /* p2p_pd.c */
 void p2p_process_prov_disc_req(struct p2p_data *p2p, const u8 *sa,
diff --git a/src/p2p/p2p_invitation.c b/src/p2p/p2p_invitation.c
index 108e5b7..f5454f7 100644
--- a/src/p2p/p2p_invitation.c
+++ b/src/p2p/p2p_invitation.c
@@ -85,9 +85,6 @@ static struct wpabuf * p2p_build_invitation_req(struct p2p_data *p2p,
 	p2p_buf_add_device_info(buf, p2p, peer);
 	p2p_buf_update_ie_hdr(buf, len);
 
-	p2p_buf_add_pref_channel_list(buf, p2p->pref_freq_list,
-				      p2p->num_pref_freq);
-
 #ifdef CONFIG_WIFI_DISPLAY
 	if (wfd_ie)
 		wpabuf_put_buf(buf, wfd_ie);
@@ -346,12 +343,6 @@ void p2p_process_invitation_req(struct p2p_data *p2p, const u8 *sa,
 			p2p_reselect_channel(p2p, &intersection);
 		}
 
-		/*
-		 * Use the driver preferred frequency list extension if
-		 * supported.
-		 */
-		p2p_check_pref_chan(p2p, go, dev, &msg);
-
 		op_freq = p2p_channel_to_freq(p2p->op_reg_class,
 					      p2p->op_channel);
 		if (op_freq < 0) {
@@ -543,12 +534,6 @@ void p2p_process_invitation_resp(struct p2p_data *p2p, const u8 *sa,
 				peer_oper_freq = 0;
 		}
 
-		/*
-		 * Use the driver preferred frequency list extension if
-		 * supported.
-		 */
-		p2p_check_pref_chan(p2p, 0, dev, &msg);
-
 		p2p->cfg->invitation_result(p2p->cfg->cb_ctx, *msg.status,
 					    msg.group_bssid, channels, sa,
 					    freq, peer_oper_freq);
diff --git a/src/p2p/p2p_parse.c b/src/p2p/p2p_parse.c
index c902cad..980dddf 100644
--- a/src/p2p/p2p_parse.c
+++ b/src/p2p/p2p_parse.c
@@ -15,29 +15,11 @@
 #include "p2p_i.h"
 
 
-void p2p_copy_filter_devname(char *dst, size_t dst_len,
-			     const void *src, size_t src_len)
-{
-	size_t i;
-
-	if (src_len >= dst_len)
-		src_len = dst_len - 1;
-	os_memcpy(dst, src, src_len);
-	dst[src_len] = '\0';
-	for (i = 0; i < src_len; i++) {
-		if (dst[i] == '\0')
-			break;
-		if (is_ctrl_char(dst[i]))
-			dst[i] = '_';
-	}
-}
-
-
 static int p2p_parse_attribute(u8 id, const u8 *data, u16 len,
 			       struct p2p_message *msg)
 {
 	const u8 *pos;
-	size_t nlen;
+	size_t i, nlen;
 	char devtype[WPS_DEV_TYPE_BUFSIZE];
 
 	switch (id) {
@@ -174,8 +156,14 @@ static int p2p_parse_attribute(u8 id, const u8 *data, u16 len,
 				   (int) (data + len - pos));
 			return -1;
 		}
-		p2p_copy_filter_devname(msg->device_name,
-					sizeof(msg->device_name), pos, nlen);
+		os_memcpy(msg->device_name, pos, nlen);
+		msg->device_name[nlen] = '\0';
+		for (i = 0; i < nlen; i++) {
+			if (msg->device_name[i] == '\0')
+				break;
+			if (is_ctrl_char(msg->device_name[i]))
+				msg->device_name[i] = '_';
+		}
 		wpa_printf(MSG_DEBUG, "P2P: * Device Info: addr " MACSTR
 			   " primary device type %s device name '%s' "
 			   "config methods 0x%x",
@@ -560,9 +548,6 @@ int p2p_parse_ies(const u8 *data, size_t len, struct p2p_message *msg)
 	}
 #endif /* CONFIG_WIFI_DISPLAY */
 
-	msg->pref_freq_list = elems.pref_freq_list;
-	msg->pref_freq_list_len = elems.pref_freq_list_len;
-
 	return 0;
 }
 
diff --git a/src/p2p/p2p_sd.c b/src/p2p/p2p_sd.c
index 0979612..1a2af04 100644
--- a/src/p2p/p2p_sd.c
+++ b/src/p2p/p2p_sd.c
@@ -417,16 +417,9 @@ void p2p_sd_response(struct p2p_data *p2p, int freq, const u8 *dst,
 		     u8 dialog_token, const struct wpabuf *resp_tlvs)
 {
 	struct wpabuf *resp;
-	size_t max_len;
-
-	/*
-	 * In the 60 GHz, we have a smaller maximum frame length for management
-	 * frames.
-	 */
-	max_len = (freq > 56160) ? 928 : 1400;
 
 	/* TODO: fix the length limit to match with the maximum frame length */
-	if (wpabuf_len(resp_tlvs) > max_len) {
+	if (wpabuf_len(resp_tlvs) > 1400) {
 		p2p_dbg(p2p, "SD response long enough to require fragmentation");
 		if (p2p->sd_resp) {
 			/*
@@ -613,7 +606,7 @@ void p2p_rx_gas_comeback_req(struct p2p_data *p2p, const u8 *sa,
 {
 	struct wpabuf *resp;
 	u8 dialog_token;
-	size_t frag_len, max_len;
+	size_t frag_len;
 	int more = 0;
 
 	wpa_hexdump(MSG_DEBUG, "P2P: RX GAS Comeback Request", data, len);
@@ -637,14 +630,9 @@ void p2p_rx_gas_comeback_req(struct p2p_data *p2p, const u8 *sa,
 		return;
 	}
 
-	/*
-	 * In the 60 GHz, we have a smaller maximum frame length for management
-	 * frames.
-	 */
-	max_len = (rx_freq > 56160) ? 928 : 1400;
 	frag_len = wpabuf_len(p2p->sd_resp) - p2p->sd_resp_pos;
-	if (frag_len > max_len) {
-		frag_len = max_len;
+	if (frag_len > 1400) {
+		frag_len = 1400;
 		more = 1;
 	}
 	resp = p2p_build_gas_comeback_resp(dialog_token, WLAN_STATUS_SUCCESS,
diff --git a/src/rsn_supp/tdls.c b/src/rsn_supp/tdls.c
index 0ac0422..6b1df71 100644
--- a/src/rsn_supp/tdls.c
+++ b/src/rsn_supp/tdls.c
@@ -626,15 +626,9 @@ static void wpa_tdls_tpk_timeout(void *eloop_ctx, void *timeout_ctx)
 	 */
 
 	if (peer->initiator) {
-		u8 addr[ETH_ALEN];
-
 		wpa_printf(MSG_DEBUG, "TDLS: TPK lifetime expired for " MACSTR
 			   " - try to renew", MAC2STR(peer->addr));
-		/* cache the peer address before do_teardown */
-		os_memcpy(addr, peer->addr, ETH_ALEN);
-		wpa_tdls_do_teardown(sm, peer,
-				     WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED);
-		wpa_tdls_start(sm, addr);
+		wpa_tdls_start(sm, peer->addr);
 	} else {
 		wpa_printf(MSG_DEBUG, "TDLS: TPK lifetime expired for " MACSTR
 			   " - tear down", MAC2STR(peer->addr));
@@ -2391,7 +2385,7 @@ skip_rsn:
 	wpa_printf(MSG_DEBUG, "TDLS: Sending TDLS Setup Confirm / "
 		   "TPK Handshake Message 3");
 	if (wpa_tdls_send_tpk_m3(sm, src_addr, dtoken, lnkid, peer) < 0)
-		goto error_no_msg;
+		goto error;
 
 	if (!peer->tpk_success) {
 		/*
@@ -2412,7 +2406,6 @@ skip_rsn:
 error:
 	wpa_tdls_send_error(sm, src_addr, WLAN_TDLS_SETUP_CONFIRM, dtoken, 1,
 			    status);
-error_no_msg:
 	wpa_tdls_disable_peer_link(sm, peer);
 	return -1;
 }
diff --git a/src/rsn_supp/wpa.c b/src/rsn_supp/wpa.c
index 2d4d8b8..38cbce6 100644
--- a/src/rsn_supp/wpa.c
+++ b/src/rsn_supp/wpa.c
@@ -249,17 +249,6 @@ static int wpa_supplicant_get_pmk(struct wpa_sm *sm,
 					"RSN: the new PMK matches with the "
 					"PMKID");
 				abort_cached = 0;
-			} else if (sa && !sm->cur_pmksa && pmkid) {
-				/*
-				 * It looks like the authentication server
-				 * derived mismatching MSK. This should not
-				 * really happen, but bugs happen.. There is not
-				 * much we can do here without knowing what
-				 * exactly caused the server to misbehave.
-				 */
-				wpa_dbg(sm->ctx->msg_ctx, MSG_INFO,
-					"RSN: PMKID mismatch - authentication server may have derived different MSK?!");
-				return -1;
 			}
 
 			if (!sm->cur_pmksa)
diff --git a/src/utils/browser-wpadebug.c b/src/utils/browser-wpadebug.c
index 59ba4d1..5fc40fa 100644
--- a/src/utils/browser-wpadebug.c
+++ b/src/utils/browser-wpadebug.c
@@ -96,7 +96,7 @@ int hs20_web_browser(const char *url)
 
 	if (pid == 0) {
 		/* run the external command in the child process */
-		char *argv[14];
+		char *argv[12];
 
 		argv[0] = "browser-wpadebug";
 		argv[1] = "start";
@@ -109,9 +109,7 @@ int hs20_web_browser(const char *url)
 		argv[8] = "-e";
 		argv[9] = "w1.fi.wpadebug.URL";
 		argv[10] = (void *) url;
-		argv[11] = "--user";
-		argv[12] = "-3"; /* USER_CURRENT_OR_SELF */
-		argv[13] = NULL;
+		argv[11] = NULL;
 
 		execv("/system/bin/am", argv);
 		wpa_printf(MSG_ERROR, "execv: %s", strerror(errno));
diff --git a/src/utils/common.c b/src/utils/common.c
index e77b7db..5cf0d57 100644
--- a/src/utils/common.c
+++ b/src/utils/common.c
@@ -697,29 +697,6 @@ int is_hex(const u8 *data, size_t len)
 }
 
 
-int has_ctrl_char(const u8 *data, size_t len)
-{
-	size_t i;
-
-	for (i = 0; i < len; i++) {
-		if (data[i] < 32 || data[i] == 127)
-			return 1;
-	}
-	return 0;
-}
-
-
-int has_newline(const char *str)
-{
-	while (*str) {
-		if (*str == '\n' || *str == '\r')
-			return 1;
-		str++;
-	}
-	return 0;
-}
-
-
 size_t merge_byte_arrays(u8 *res, size_t res_len,
 			 const u8 *src1, size_t src1_len,
 			 const u8 *src2, size_t src2_len)
diff --git a/src/utils/common.h b/src/utils/common.h
index 7dbb24a..b718c99 100644
--- a/src/utils/common.h
+++ b/src/utils/common.h
@@ -354,6 +354,17 @@ static inline void WPA_PUT_LE64(u8 *a, u64 val)
 #ifndef ETH_P_RRB
 #define ETH_P_RRB 0x890D
 #endif /* ETH_P_RRB */
+#ifdef CONFIG_WAPI
+#ifndef ETH_HLEN
+#define ETH_HLEN 14
+#endif
+#ifndef ETH_P_WAI
+#define ETH_P_WAI 0x88B4
+#endif
+#ifndef ETH_P_WAI_PREAUTH
+#define ETH_P_WAI_PREAUTH 0x88B5
+#endif
+#endif
 
 
 #ifdef __GNUC__
@@ -503,8 +514,6 @@ const char * wpa_ssid_txt(const u8 *ssid, size_t ssid_len);
 
 char * wpa_config_parse_string(const char *value, size_t *len);
 int is_hex(const u8 *data, size_t len);
-int has_ctrl_char(const u8 *data, size_t len);
-int has_newline(const char *str);
 size_t merge_byte_arrays(u8 *res, size_t res_len,
 			 const u8 *src1, size_t src1_len,
 			 const u8 *src2, size_t src2_len);
@@ -520,11 +529,6 @@ static inline int is_broadcast_ether_addr(const u8 *a)
 	return (a[0] & a[1] & a[2] & a[3] & a[4] & a[5]) == 0xff;
 }
 
-static inline int is_multicast_ether_addr(const u8 *a)
-{
-	return a[0] & 0x01;
-}
-
 #define broadcast_ether_addr (const u8 *) "\xff\xff\xff\xff\xff\xff"
 
 #include "wpa_debug.h"
diff --git a/src/utils/eloop.c b/src/utils/eloop.c
index 0f10ab5..4a565eb 100644
--- a/src/utils/eloop.c
+++ b/src/utils/eloop.c
@@ -61,8 +61,11 @@ struct eloop_signal {
 struct eloop_sock_table {
 	int count;
 	struct eloop_sock *table;
+#ifdef CONFIG_ELOOP_EPOLL
 	eloop_event_type type;
+#else /* CONFIG_ELOOP_EPOLL */
 	int changed;
+#endif /* CONFIG_ELOOP_EPOLL */
 };
 
 struct eloop_data {
@@ -253,7 +256,9 @@ static int eloop_sock_table_add_sock(struct eloop_sock_table *table,
 	table->table = tmp;
 	eloop.max_sock = new_max_sock;
 	eloop.count++;
+#ifndef CONFIG_ELOOP_EPOLL
 	table->changed = 1;
+#endif /* CONFIG_ELOOP_EPOLL */
 	eloop_trace_sock_add_ref(table);
 
 #ifdef CONFIG_ELOOP_EPOLL
@@ -309,7 +314,9 @@ static void eloop_sock_table_remove_sock(struct eloop_sock_table *table,
 	}
 	table->count--;
 	eloop.count--;
+#ifndef CONFIG_ELOOP_EPOLL
 	table->changed = 1;
+#endif /* CONFIG_ELOOP_EPOLL */
 	eloop_trace_sock_add_ref(table);
 #ifdef CONFIG_ELOOP_EPOLL
 	if (epoll_ctl(eloop.epollfd, EPOLL_CTL_DEL, sock, NULL) < 0) {
@@ -516,10 +523,6 @@ static void eloop_sock_table_dispatch(struct epoll_event *events, int nfds)
 			continue;
 		table->handler(table->sock, table->eloop_data,
 			       table->user_data);
-		if (eloop.readers.changed ||
-		    eloop.writers.changed ||
-		    eloop.exceptions.changed)
-			break;
 	}
 }
 #endif /* CONFIG_ELOOP_EPOLL */
@@ -974,11 +977,6 @@ void eloop_run(void)
 				   , strerror(errno));
 			goto out;
 		}
-
-		eloop.readers.changed = 0;
-		eloop.writers.changed = 0;
-		eloop.exceptions.changed = 0;
-
 		eloop_process_pending_signals();
 
 		/* check if some registered timeouts have occurred */
@@ -1000,19 +998,6 @@ void eloop_run(void)
 		if (res <= 0)
 			continue;
 
-		if (eloop.readers.changed ||
-		    eloop.writers.changed ||
-		    eloop.exceptions.changed) {
-			 /*
-			  * Sockets may have been closed and reopened with the
-			  * same FD in the signal or timeout handlers, so we
-			  * must skip the previous results and check again
-			  * whether any of the currently registered sockets have
-			  * events.
-			  */
-			continue;
-		}
-
 #ifdef CONFIG_ELOOP_POLL
 		eloop_sock_table_dispatch(&eloop.readers, &eloop.writers,
 					  &eloop.exceptions, eloop.pollfds_map,
diff --git a/src/utils/http_curl.c b/src/utils/http_curl.c
index 9c49680..653eb54 100644
--- a/src/utils/http_curl.c
+++ b/src/utils/http_curl.c
@@ -26,9 +26,6 @@
 #include "common.h"
 #include "xml-utils.h"
 #include "http-utils.h"
-#ifdef EAP_TLS_OPENSSL
-#include "crypto/tls_openssl.h"
-#endif /* EAP_TLS_OPENSSL */
 
 
 struct http_ctx {
@@ -424,28 +421,6 @@ ASN1_SEQUENCE(LogotypeExtn) = {
 
 IMPLEMENT_ASN1_FUNCTIONS(LogotypeExtn);
 
-#ifdef OPENSSL_IS_BORINGSSL
-#define sk_LogotypeInfo_num(st) \
-sk_num(CHECKED_CAST(_STACK *, STACK_OF(LogotypeInfo) *, (st)))
-#define sk_LogotypeInfo_value(st, i) (LogotypeInfo *) \
-sk_value(CHECKED_CAST(_STACK *, const STACK_OF(LogotypeInfo) *, (st)), (i))
-#define sk_LogotypeImage_num(st) \
-sk_num(CHECKED_CAST(_STACK *, STACK_OF(LogotypeImage) *, (st)))
-#define sk_LogotypeImage_value(st, i) (LogotypeImage *) \
-sk_value(CHECKED_CAST(_STACK *, const STACK_OF(LogotypeImage) *, (st)), (i))
-#define sk_LogotypeAudio_num(st) \
-sk_num(CHECKED_CAST(_STACK *, STACK_OF(LogotypeAudio) *, (st)))
-#define sk_LogotypeAudio_value(st, i) (LogotypeAudio *) \
-sk_value(CHECK_CAST(_STACK *, const STACK_OF(LogotypeAudio) *, (st)), (i))
-#define sk_HashAlgAndValue_num(st) \
-sk_num(CHECKED_CAST(_STACK *, STACK_OF(HashAlgAndValue) *, (st)))
-#define sk_HashAlgAndValue_value(st, i) (HashAlgAndValue *) \
-sk_value(CHECKED_CAST(_STACK *, const STACK_OF(HashAlgAndValue) *, (st)), (i))
-#define sk_ASN1_IA5STRING_num(st) \
-sk_num(CHECKED_CAST(_STACK *, STACK_OF(ASN1_IA5STRING) *, (st)))
-#define sk_ASN1_IA5STRING_value(st, i) (ASN1_IA5STRING *) \
-sk_value(CHECKED_CAST(_STACK *, const STACK_OF(ASN1_IA5STRING) *, (st)), (i))
-#else /* OPENSSL_IS_BORINGSSL */
 #define sk_LogotypeInfo_num(st) SKM_sk_num(LogotypeInfo, (st))
 #define sk_LogotypeInfo_value(st, i) SKM_sk_value(LogotypeInfo, (st), (i))
 #define sk_LogotypeImage_num(st) SKM_sk_num(LogotypeImage, (st))
@@ -456,7 +431,6 @@ sk_value(CHECKED_CAST(_STACK *, const STACK_OF(ASN1_IA5STRING) *, (st)), (i))
 #define sk_HashAlgAndValue_value(st, i) SKM_sk_value(HashAlgAndValue, (st), (i))
 #define sk_ASN1_IA5STRING_num(st) SKM_sk_num(ASN1_IA5STRING, (st))
 #define sk_ASN1_IA5STRING_value(st, i) SKM_sk_value(ASN1_IA5STRING, (st), (i))
-#endif /* OPENSSL_IS_BORINGSSL */
 
 
 static void add_logo(struct http_ctx *ctx, struct http_cert *hcert,
@@ -1007,26 +981,6 @@ static int curl_cb_ssl_verify(int preverify_ok, X509_STORE_CTX *x509_ctx)
 	if (depth == 0 && preverify_ok && validate_server_cert(ctx, cert) < 0)
 		return 0;
 
-#ifdef OPENSSL_IS_BORINGSSL
-	if (depth == 0 && ctx->ocsp != NO_OCSP && preverify_ok) {
-		enum ocsp_result res;
-
-		res = check_ocsp_resp(ssl_ctx, ssl, cert, ctx->peer_issuer,
-				      ctx->peer_issuer_issuer);
-		if (res == OCSP_REVOKED) {
-			preverify_ok = 0;
-			wpa_printf(MSG_INFO, "OCSP: certificate revoked");
-			if (err == X509_V_OK)
-				X509_STORE_CTX_set_error(
-					x509_ctx, X509_V_ERR_CERT_REVOKED);
-		} else if (res != OCSP_GOOD && (ctx->ocsp == MANDATORY_OCSP)) {
-			preverify_ok = 0;
-			wpa_printf(MSG_INFO,
-				   "OCSP: bad certificate status response");
-		}
-	}
-#endif /* OPENSSL_IS_BORINGSSL */
-
 	if (!preverify_ok)
 		ctx->last_err = "TLS validation failed";
 
@@ -1319,16 +1273,6 @@ static CURL * setup_curl_post(struct http_ctx *ctx, const char *address,
 #ifdef EAP_TLS_OPENSSL
 		curl_easy_setopt(curl, CURLOPT_SSL_CTX_FUNCTION, curl_cb_ssl);
 		curl_easy_setopt(curl, CURLOPT_SSL_CTX_DATA, ctx);
-#ifdef OPENSSL_IS_BORINGSSL
-		/* For now, using the CURLOPT_SSL_VERIFYSTATUS option only
-		 * with BoringSSL since the OpenSSL specific callback hack to
-		 * enable OCSP is not available with BoringSSL. The OCSP
-		 * implementation within libcurl is not sufficient for the
-		 * Hotspot 2.0 OSU needs, so cannot use this with OpenSSL.
-		 */
-		if (ctx->ocsp != NO_OCSP)
-			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYSTATUS, 1L);
-#endif /* OPENSSL_IS_BORINGSSL */
 #endif /* EAP_TLS_OPENSSL */
 	} else {
 		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
diff --git a/src/utils/os.h b/src/utils/os.h
index 8913854..958f7a3 100644
--- a/src/utils/os.h
+++ b/src/utils/os.h
@@ -512,6 +512,10 @@ char * os_strdup(const char *s);
 #define os_memcmp(s1, s2, n) memcmp((s1), (s2), (n))
 #endif
 
+#ifndef os_strncpy
+#define os_strncpy(s1, s2, n) strncpy((s1), (s2), (n))
+#endif
+
 #ifndef os_strlen
 #define os_strlen(s) strlen(s)
 #endif
diff --git a/src/utils/pcsc_funcs.h b/src/utils/pcsc_funcs.h
index eacd2a2..7228753 100644
--- a/src/utils/pcsc_funcs.h
+++ b/src/utils/pcsc_funcs.h
@@ -5,6 +5,9 @@
  * This software may be distributed under the terms of the BSD license.
  * See README for more details.
  */
+ #ifdef CONFIG_ATCI
+#include "sim_funcs.h"
+#endif
 
 #ifndef PCSC_FUNCS_H
 #define PCSC_FUNCS_H
@@ -27,6 +30,11 @@ int scard_supports_umts(struct scard_data *scard);
 
 #else /* PCSC_FUNCS */
 
+#ifdef CONFIG_ATCI
+#define scard_init(s, r) NULL
+#define scard_deinit(s) do { } while (0)
+#define scard_supports_umts(s) 0
+#else
 #define scard_init(r) NULL
 #define scard_deinit(s) do { } while (0)
 #define scard_set_pin(s, p) -1
@@ -36,6 +44,7 @@ int scard_supports_umts(struct scard_data *scard);
 #define scard_umts_auth(s, r, a, r2, rl, i, c, a2) -1
 #define scard_get_pin_retry_counter(s) -1
 #define scard_supports_umts(s) 0
+#endif
 
 #endif /* PCSC_FUNCS */
 
diff --git a/src/utils/wpa_debug.c b/src/utils/wpa_debug.c
index 61c0d5c..b7a6dba 100644
--- a/src/utils/wpa_debug.c
+++ b/src/utils/wpa_debug.c
@@ -749,33 +749,6 @@ void wpa_msg_no_global(void *ctx, int level, const char *fmt, ...)
 	bin_clear_free(buf, buflen);
 }
 
-
-void wpa_msg_global_only(void *ctx, int level, const char *fmt, ...)
-{
-	va_list ap;
-	char *buf;
-	int buflen;
-	int len;
-
-	va_start(ap, fmt);
-	buflen = vsnprintf(NULL, 0, fmt, ap) + 1;
-	va_end(ap);
-
-	buf = os_malloc(buflen);
-	if (buf == NULL) {
-		wpa_printf(MSG_ERROR, "%s: Failed to allocate message buffer",
-			   __func__);
-		return;
-	}
-	va_start(ap, fmt);
-	len = vsnprintf(buf, buflen, fmt, ap);
-	va_end(ap);
-	wpa_printf(level, "%s", buf);
-	if (wpa_msg_cb)
-		wpa_msg_cb(ctx, level, WPA_MSG_ONLY_GLOBAL, buf, len);
-	os_free(buf);
-}
-
 #endif /* CONFIG_NO_WPA_MSG */
 
 
@@ -819,42 +792,3 @@ void hostapd_logger(void *ctx, const u8 *addr, unsigned int module, int level,
 	bin_clear_free(buf, buflen);
 }
 #endif /* CONFIG_NO_HOSTAPD_LOGGER */
-
-
-const char * debug_level_str(int level)
-{
-	switch (level) {
-	case MSG_EXCESSIVE:
-		return "EXCESSIVE";
-	case MSG_MSGDUMP:
-		return "MSGDUMP";
-	case MSG_DEBUG:
-		return "DEBUG";
-	case MSG_INFO:
-		return "INFO";
-	case MSG_WARNING:
-		return "WARNING";
-	case MSG_ERROR:
-		return "ERROR";
-	default:
-		return "?";
-	}
-}
-
-
-int str_to_debug_level(const char *s)
-{
-	if (os_strcasecmp(s, "EXCESSIVE") == 0)
-		return MSG_EXCESSIVE;
-	if (os_strcasecmp(s, "MSGDUMP") == 0)
-		return MSG_MSGDUMP;
-	if (os_strcasecmp(s, "DEBUG") == 0)
-		return MSG_DEBUG;
-	if (os_strcasecmp(s, "INFO") == 0)
-		return MSG_INFO;
-	if (os_strcasecmp(s, "WARNING") == 0)
-		return MSG_WARNING;
-	if (os_strcasecmp(s, "ERROR") == 0)
-		return MSG_ERROR;
-	return -1;
-}
diff --git a/src/utils/wpa_debug.h b/src/utils/wpa_debug.h
index 17d8f96..5fdc50e 100644
--- a/src/utils/wpa_debug.h
+++ b/src/utils/wpa_debug.h
@@ -164,7 +164,6 @@ void wpa_hexdump_ascii_key(int level, const char *title, const void *buf,
 #define wpa_msg_global(args...) do { } while (0)
 #define wpa_msg_global_ctrl(args...) do { } while (0)
 #define wpa_msg_no_global(args...) do { } while (0)
-#define wpa_msg_global_only(args...) do { } while (0)
 #define wpa_msg_register_cb(f) do { } while (0)
 #define wpa_msg_register_ifname_cb(f) do { } while (0)
 #else /* CONFIG_NO_WPA_MSG */
@@ -244,25 +243,10 @@ PRINTF_FORMAT(3, 4);
 void wpa_msg_no_global(void *ctx, int level, const char *fmt, ...)
 PRINTF_FORMAT(3, 4);
 
-/**
- * wpa_msg_global_only - Conditional printf for ctrl_iface monitors
- * @ctx: Pointer to context data; this is the ctx variable registered
- *	with struct wpa_driver_ops::init()
- * @level: priority level (MSG_*) of the message
- * @fmt: printf format string, followed by optional arguments
- *
- * This function is used to print conditional debugging and error messages.
- * This function is like wpa_msg_global(), but it sends the output only as a
- * global event.
- */
-void wpa_msg_global_only(void *ctx, int level, const char *fmt, ...)
-PRINTF_FORMAT(3, 4);
-
 enum wpa_msg_type {
 	WPA_MSG_PER_INTERFACE,
 	WPA_MSG_GLOBAL,
 	WPA_MSG_NO_GLOBAL,
-	WPA_MSG_ONLY_GLOBAL,
 };
 
 typedef void (*wpa_msg_cb_func)(void *ctx, int level, enum wpa_msg_type type,
@@ -364,7 +348,4 @@ static inline void wpa_debug_close_linux_tracing(void)
 #define WPA_ASSERT(a) do { } while (0)
 #endif
 
-const char * debug_level_str(int level);
-int str_to_debug_level(const char *s);
-
 #endif /* WPA_DEBUG_H */
diff --git a/src/wps/wps_attr_process.c b/src/wps/wps_attr_process.c
index e8c4579..eadb22f 100644
--- a/src/wps/wps_attr_process.c
+++ b/src/wps/wps_attr_process.c
@@ -229,16 +229,6 @@ static int wps_workaround_cred_key(struct wps_credential *cred)
 		cred->key_len--;
 #endif /* CONFIG_WPS_STRICT */
 	}
-
-
-	if (cred->auth_type & (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK) &&
-	    (cred->key_len < 8 || has_ctrl_char(cred->key, cred->key_len))) {
-		wpa_printf(MSG_INFO, "WPS: Reject credential with invalid WPA/WPA2-Personal passphrase");
-		wpa_hexdump_ascii_key(MSG_INFO, "WPS: Network Key",
-				      cred->key, cred->key_len);
-		return -1;
-	}
-
 	return 0;
 }
 
diff --git a/wpa_supplicant/Android.mk b/wpa_supplicant/Android.mk
index a6410a6..71c89d8 100644
--- a/wpa_supplicant/Android.mk
+++ b/wpa_supplicant/Android.mk
@@ -32,6 +32,14 @@ ifeq ($(BOARD_WPA_SUPPLICANT_PRIVATE_LIB),)
 L_CFLAGS += -DANDROID_LIB_STUB
 endif
 
+ifeq ($(BOARD_WLAN_DEVICE), sc2351)
+L_CFLAGS += -DCONFIG_SC2351
+endif
+
+ifeq ($(BOARD_WLAN_DEVICE), bcmdhd)
+L_CFLAGS += -DCONFIG_BCMDHD
+endif
+
 # Disable roaming in wpa_supplicant
 ifdef CONFIG_NO_ROAMING
 L_CFLAGS += -DCONFIG_NO_ROAMING
@@ -66,6 +74,7 @@ INCLUDES += $(LOCAL_PATH)/src/tls
 INCLUDES += $(LOCAL_PATH)/src/utils
 INCLUDES += $(LOCAL_PATH)/src/wps
 INCLUDES += system/security/keystore/include
+
 ifdef CONFIG_DRIVER_NL80211
 ifneq ($(wildcard external/libnl),)
 INCLUDES += external/libnl/include
@@ -315,22 +324,6 @@ L_CFLAGS += -DCONFIG_INTERWORKING
 NEED_GAS=y
 endif
 
-ifdef CONFIG_FST
-L_CFLAGS += -DCONFIG_FST
-OBJS += src/fst/fst.c
-OBJS += src/fst/fst_session.c
-OBJS += src/fst/fst_iface.c
-OBJS += src/fst/fst_group.c
-OBJS += src/fst/fst_ctrl_aux.c
-ifdef CONFIG_FST_TEST
-L_CFLAGS += -DCONFIG_FST_TEST
-endif
-ifdef CONFIG_CTRL_IFACE
-OBJS += src/fst/fst_ctrl_iface.c
-endif
-endif
-
-
 include $(LOCAL_PATH)/src/drivers/drivers.mk
 
 ifdef CONFIG_AP
@@ -557,11 +550,7 @@ endif
 
 ifdef CONFIG_EAP_PROXY
 L_CFLAGS += -DCONFIG_EAP_PROXY
-ifneq ($(CONFIG_EAP_PROXY),qmi)
-# QMI needs proprietary headers to build :(
-# Spin it into a blobbable lib
 OBJS += src/eap_peer/eap_proxy_$(CONFIG_EAP_PROXY).c
-endif
 include $(LOCAL_PATH)/eap_proxy_$(CONFIG_EAP_PROXY).mk
 CONFIG_IEEE8021X_EAPOL=y
 endif
@@ -986,7 +975,6 @@ ifeq ($(CONFIG_TLS), openssl)
 ifdef TLS_FUNCS
 L_CFLAGS += -DEAP_TLS_OPENSSL
 OBJS += src/crypto/tls_openssl.c
-OBJS += src/crypto/tls_openssl_ocsp.c
 LIBS += -lssl
 endif
 OBJS += src/crypto/crypto_openssl.c
@@ -1569,36 +1557,9 @@ LOCAL_SRC_FILES := $(OBJS_c)
 LOCAL_C_INCLUDES := $(INCLUDES)
 include $(BUILD_EXECUTABLE)
 
-# This needs QMI artifacts to be built
-ifneq ($(QCPATH),)
-
-ifeq ($(CONFIG_EAP_PROXY),qmi)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE = libwpa_qmi_eap_proxy
-LOCAL_SHARED_LIBRARIES := libcutils liblog libwpa_client
-LOCAL_SRC_FILES += src/eap_peer/eap_proxy_$(CONFIG_EAP_PROXY).c
-LOCAL_SRC_FILES += src/utils/wpa_debug.c
-LOCAL_SRC_FILES += src/utils/wpabuf.c
-LOCAL_SRC_FILES += src/utils/eloop.c
-LOCAL_SRC_FILES += src/utils/common.c
-include $(LOCAL_PATH)/eap_proxy_$(CONFIG_EAP_PROXY).mk
-LOCAL_C_INCLUDES := $(INCLUDES)
-LOCAL_CFLAGS = $(L_CFLAGS)
-
-LOCAL_STATIC_LIBRARIES += $(LIB_STATIC_EAP_PROXY)
-LOCAL_SHARED_LIBRARIES += $(LIB_SHARED_EAP_PROXY)
-
-include $(BUILD_SHARED_LIBRARY)
-
-endif # qmi EAP_PROXY
-endif # QCPATH
-
-
 ########################
 include $(CLEAR_VARS)
 LOCAL_MODULE := wpa_supplicant
-LOCAL_CLANG := false
 ifdef CONFIG_DRIVER_CUSTOM
 LOCAL_STATIC_LIBRARIES := libCustomWifi
 endif
@@ -1607,12 +1568,8 @@ LOCAL_STATIC_LIBRARIES += $(BOARD_WPA_SUPPLICANT_PRIVATE_LIB)
 endif
 LOCAL_SHARED_LIBRARIES := libc libcutils liblog
 ifdef CONFIG_EAP_PROXY
-ifneq ($(CONFIG_EAP_PROXY),qmi)
 LOCAL_STATIC_LIBRARIES += $(LIB_STATIC_EAP_PROXY)
 LOCAL_SHARED_LIBRARIES += $(LIB_SHARED_EAP_PROXY)
-else
-LOCAL_SHARED_LIBRARIES += libwpa_qmi_eap_proxy
-endif
 endif
 ifeq ($(CONFIG_TLS), openssl)
 LOCAL_SHARED_LIBRARIES += libcrypto libssl libkeystore_binder
@@ -1631,6 +1588,28 @@ else
 LOCAL_STATIC_LIBRARIES += libnl_2
 endif
 endif
+
+# SPRD Wi-Fi configurations start
+
+#ATCI configurations start
+#L_CFLAGS += -DCONFIG_ATCI
+#INCLUDES += vendor/sprd/open-source/libs/libatci
+#INCLUDES += $(LOCAL_PATH)/src/sim
+#OBJS += src/sim/attok.c
+#OBJS += src/sim/send_at.c
+#OBJS += src/sim/sim_funcs.c
+#LOCAL_SHARED_LIBRARIES += libatci
+#ATCI configurations end
+
+#WAPI configurations start
+L_CFLAGS += -DCONFIG_WAPI
+INCLUDES += ../wapi_lib/wapi_interface.h
+OBJS += src/wapi/wapi_interface_priv.c
+LOCAL_STATIC_LIBRARIES += libwapi
+#WAPI configurations end
+L_CFLAGS += -DCONFIG_LOG_OPTIMIZATIOIN
+# SPRD Wi-Fi configurations end
+
 LOCAL_CFLAGS := $(L_CFLAGS)
 LOCAL_SRC_FILES := $(OBJS)
 LOCAL_C_INCLUDES := $(INCLUDES)
diff --git a/wpa_supplicant/Makefile b/wpa_supplicant/Makefile
index 5f7a2b2..05d8e0a 100644
--- a/wpa_supplicant/Makefile
+++ b/wpa_supplicant/Makefile
@@ -993,7 +993,6 @@ ifeq ($(CONFIG_TLS), openssl)
 ifdef TLS_FUNCS
 CFLAGS += -DEAP_TLS_OPENSSL
 OBJS += ../src/crypto/tls_openssl.o
-OBJS += ../src/crypto/tls_openssl_ocsp.o
 LIBS += -lssl
 endif
 OBJS += ../src/crypto/crypto_openssl.o
@@ -1592,24 +1591,6 @@ EXTRALIBS += WbemUuid.Lib
 endif
 endif
 
-ifdef CONFIG_FST
-CFLAGS += -DCONFIG_FST
-ifdef CONFIG_FST_TEST
-CFLAGS += -DCONFIG_FST_TEST
-endif
-FST_OBJS += ../src/fst/fst.o
-FST_OBJS += ../src/fst/fst_session.o
-FST_OBJS += ../src/fst/fst_iface.o
-FST_OBJS += ../src/fst/fst_group.o
-FST_OBJS += ../src/fst/fst_ctrl_aux.o
-ifdef CONFIG_CTRL_IFACE
-FST_OBJS += ../src/fst/fst_ctrl_iface.o
-endif
-OBJS += $(FST_OBJS)
-OBJS_t += $(FST_OBJS)
-OBJS_t2 += $(FST_OBJS)
-endif
-
 ifndef LDO
 LDO=$(CC)
 endif
diff --git a/wpa_supplicant/README-P2P b/wpa_supplicant/README-P2P
index 0a21d13..6a5b032 100644
--- a/wpa_supplicant/README-P2P
+++ b/wpa_supplicant/README-P2P
@@ -633,17 +633,12 @@ p2p_set managed <0/1>
 Disable/enable managed P2P Device operations. This is disabled by
 default.
 
-p2p_set listen_channel <channel> [<op_class>]
+p2p_set listen_channel <1/6/11>
 
 Set P2P Listen channel. This is mainly meant for testing purposes and
 changing the Listen channel during normal operations can result in
 protocol failures.
 
-When specifying a social channel on the 2.4 GHz band (1/6/11) there is
-no need to specify the operating class since it defaults to 81.  When
-specifying a social channel on the 60 GHz band (2), specify the 60 GHz
-operating class (180).
-
 p2p_set ssid_postfix <postfix>
 
 Set postfix string to be added to the automatically generated P2P SSID
diff --git a/wpa_supplicant/android.config b/wpa_supplicant/android.config
index 6dbd67e..93dd091 100644
--- a/wpa_supplicant/android.config
+++ b/wpa_supplicant/android.config
@@ -436,7 +436,9 @@ CONFIG_INTERWORKING=y
 CONFIG_HS20=y
 
 # Disable roaming in wpa_supplicant
-CONFIG_NO_ROAMING=y
+#CONFIG_NO_ROAMING=y
+# enable bgscan learn mode
+CONFIG_BGSCAN_LEARN=y
 
 # AP mode operations with wpa_supplicant
 # This can be used for controlling AP mode operations with wpa_supplicant. It
@@ -476,7 +478,4 @@ CONFIG_WIFI_DISPLAY=y
 # External password backend for testing purposes (developer use)
 #CONFIG_EXT_PASSWORD_TEST=y
 
-# Enable Fast Session Transfer (FST)
-CONFIG_FST=y
-
 include $(wildcard $(LOCAL_PATH)/android_config_*.inc)
diff --git a/wpa_supplicant/ap.c b/wpa_supplicant/ap.c
index 419bd89..f3960c5 100644
--- a/wpa_supplicant/ap.c
+++ b/wpa_supplicant/ap.c
@@ -56,32 +56,12 @@ static void wpas_conf_ap_vht(struct wpa_supplicant *wpa_s,
 	if (!conf->secondary_channel)
 		goto no_vht;
 
-	switch (conf->vht_oper_chwidth) {
-	case VHT_CHANWIDTH_80MHZ:
-	case VHT_CHANWIDTH_80P80MHZ:
-		center_chan = wpas_p2p_get_vht80_center(wpa_s, mode, channel);
-		break;
-	case VHT_CHANWIDTH_160MHZ:
-		center_chan = wpas_p2p_get_vht160_center(wpa_s, mode, channel);
-		break;
-	default:
-		/*
-		 * conf->vht_oper_chwidth might not be set for non-P2P GO cases,
-		 * try oper_cwidth 160 MHz first then VHT 80 MHz, if 160 MHz is
-		 * not supported.
-		 */
-		conf->vht_oper_chwidth = VHT_CHANWIDTH_160MHZ;
-		center_chan = wpas_p2p_get_vht160_center(wpa_s, mode, channel);
-		if (!center_chan) {
-			conf->vht_oper_chwidth = VHT_CHANWIDTH_80MHZ;
-			center_chan = wpas_p2p_get_vht80_center(wpa_s, mode,
-								channel);
-		}
-		break;
-	}
+	center_chan = wpas_p2p_get_vht80_center(wpa_s, mode, channel);
 	if (!center_chan)
 		goto no_vht;
 
+	/* Use 80 MHz channel */
+	conf->vht_oper_chwidth = 1;
 	conf->vht_oper_centr_freq_seg0_idx = center_chan;
 	return;
 
@@ -184,13 +164,6 @@ static int wpa_supplicant_conf_ap(struct wpa_supplicant *wpa_s,
 		return -1;
 	}
 
-	if (ssid->pbss > 1) {
-		wpa_printf(MSG_ERROR, "Invalid pbss value(%d) for AP mode",
-			   ssid->pbss);
-		return -1;
-	}
-	bss->pbss = ssid->pbss;
-
 	wpa_supplicant_conf_ap_ht(wpa_s, ssid, conf);
 
 	if (ieee80211_is_dfs(ssid->frequency) && wpa_s->conf->country[0]) {
@@ -233,12 +206,12 @@ static int wpa_supplicant_conf_ap(struct wpa_supplicant *wpa_s,
 	bss->force_per_enrollee_psk = wpa_s->global->p2p_per_sta_psk;
 
 	if (ssid->p2p_group) {
-		os_memcpy(bss->ip_addr_go, wpa_s->p2pdev->conf->ip_addr_go, 4);
-		os_memcpy(bss->ip_addr_mask, wpa_s->p2pdev->conf->ip_addr_mask,
+		os_memcpy(bss->ip_addr_go, wpa_s->parent->conf->ip_addr_go, 4);
+		os_memcpy(bss->ip_addr_mask, wpa_s->parent->conf->ip_addr_mask,
 			  4);
 		os_memcpy(bss->ip_addr_start,
-			  wpa_s->p2pdev->conf->ip_addr_start, 4);
-		os_memcpy(bss->ip_addr_end, wpa_s->p2pdev->conf->ip_addr_end,
+			  wpa_s->parent->conf->ip_addr_start, 4);
+		os_memcpy(bss->ip_addr_end, wpa_s->parent->conf->ip_addr_end,
 			  4);
 	}
 #endif /* CONFIG_P2P */
@@ -452,14 +425,14 @@ static void ap_wps_event_cb(void *ctx, enum wps_event event,
 	if (event == WPS_EV_FAIL) {
 		struct wps_event_fail *fail = &data->fail;
 
-		if (wpa_s->p2pdev && wpa_s->p2pdev != wpa_s &&
+		if (wpa_s->parent && wpa_s->parent != wpa_s &&
 		    wpa_s == wpa_s->global->p2p_group_formation) {
 			/*
 			 * src/ap/wps_hostapd.c has already sent this on the
 			 * main interface, so only send on the parent interface
 			 * here if needed.
 			 */
-			wpa_msg(wpa_s->p2pdev, MSG_INFO, WPS_EVENT_FAIL
+			wpa_msg(wpa_s->parent, MSG_INFO, WPS_EVENT_FAIL
 				"msg=%d config_error=%d",
 				fail->msg, fail->config_error);
 		}
@@ -599,8 +572,8 @@ int wpa_supplicant_create_ap(struct wpa_supplicant *wpa_s,
 		params.p2p = 1;
 #endif /* CONFIG_P2P */
 
-	if (wpa_s->p2pdev->set_ap_uapsd)
-		params.uapsd = wpa_s->p2pdev->ap_uapsd;
+	if (wpa_s->parent->set_ap_uapsd)
+		params.uapsd = wpa_s->parent->ap_uapsd;
 	else if (params.p2p && (wpa_s->drv_flags & WPA_DRIVER_FLAGS_AP_UAPSD))
 		params.uapsd = 1; /* mandatory for P2P GO */
 	else
@@ -631,13 +604,6 @@ int wpa_supplicant_create_ap(struct wpa_supplicant *wpa_s,
 		return -1;
 	}
 
-	/* Use the maximum oper channel width if it's given. */
-	if (ssid->max_oper_chwidth)
-		conf->vht_oper_chwidth = ssid->max_oper_chwidth;
-
-	ieee80211_freq_to_chan(ssid->vht_center_freq2,
-			       &conf->vht_oper_centr_freq_seg1_idx);
-
 	os_memcpy(wpa_s->ap_iface->conf->wmm_ac_params,
 		  wpa_s->conf->wmm_ac_params,
 		  sizeof(wpa_s->conf->wmm_ac_params));
@@ -679,7 +645,7 @@ int wpa_supplicant_create_ap(struct wpa_supplicant *wpa_s,
 		}
 
 		hapd_iface->bss[i]->msg_ctx = wpa_s;
-		hapd_iface->bss[i]->msg_ctx_parent = wpa_s->p2pdev;
+		hapd_iface->bss[i]->msg_ctx_parent = wpa_s->parent;
 		hapd_iface->bss[i]->public_action_cb = ap_public_action_rx;
 		hapd_iface->bss[i]->public_action_cb_ctx = wpa_s;
 		hapd_iface->bss[i]->vendor_action_cb = ap_vendor_action_rx;
@@ -1273,8 +1239,8 @@ int wpas_ap_wps_add_nfc_pw(struct wpa_supplicant *wpa_s, u16 pw_id,
 	hapd = wpa_s->ap_iface->bss[0];
 	wps = hapd->wps;
 
-	if (wpa_s->p2pdev->conf->wps_nfc_dh_pubkey == NULL ||
-	    wpa_s->p2pdev->conf->wps_nfc_dh_privkey == NULL) {
+	if (wpa_s->parent->conf->wps_nfc_dh_pubkey == NULL ||
+	    wpa_s->parent->conf->wps_nfc_dh_privkey == NULL) {
 		wpa_printf(MSG_DEBUG, "P2P: No NFC DH key known");
 		return -1;
 	}
@@ -1283,9 +1249,9 @@ int wpas_ap_wps_add_nfc_pw(struct wpa_supplicant *wpa_s, u16 pw_id,
 	wpabuf_free(wps->dh_pubkey);
 	wpabuf_free(wps->dh_privkey);
 	wps->dh_privkey = wpabuf_dup(
-		wpa_s->p2pdev->conf->wps_nfc_dh_privkey);
+		wpa_s->parent->conf->wps_nfc_dh_privkey);
 	wps->dh_pubkey = wpabuf_dup(
-		wpa_s->p2pdev->conf->wps_nfc_dh_pubkey);
+		wpa_s->parent->conf->wps_nfc_dh_pubkey);
 	if (wps->dh_privkey == NULL || wps->dh_pubkey == NULL) {
 		wps->dh_ctx = NULL;
 		wpabuf_free(wps->dh_pubkey);
diff --git a/wpa_supplicant/bss.c b/wpa_supplicant/bss.c
index 39a1609..8134562 100644
--- a/wpa_supplicant/bss.c
+++ b/wpa_supplicant/bss.c
@@ -311,24 +311,10 @@ static int wpa_bss_known(struct wpa_supplicant *wpa_s, struct wpa_bss *bss)
 
 static int wpa_bss_in_use(struct wpa_supplicant *wpa_s, struct wpa_bss *bss)
 {
-	if (bss == wpa_s->current_bss)
-		return 1;
-
-	if (wpa_s->current_bss &&
-	    (bss->ssid_len != wpa_s->current_bss->ssid_len ||
-	     os_memcmp(bss->ssid, wpa_s->current_bss->ssid,
-		       bss->ssid_len) != 0))
-		return 0; /* SSID has changed */
-
-	return !is_zero_ether_addr(bss->bssid) &&
-		(os_memcmp(bss->bssid, wpa_s->bssid, ETH_ALEN) == 0 ||
-#ifdef MTK_HARDWARE
-		 /* if we're trying to connect this ssid, don't remove it from scan result */
-		 (!(wpa_s->drv_flags & WPA_DRIVER_FLAGS_P2P_CAPABLE) && wpa_s->current_ssid &&
-		 	 wpa_s->current_ssid->ssid_len > 0 &&
-		  	os_strncmp(wpa_s->current_ssid->ssid, bss->ssid, wpa_s->current_ssid->ssid_len) == 0) ||
-#endif
-		 os_memcmp(bss->bssid, wpa_s->pending_bssid, ETH_ALEN) == 0);
+	return bss == wpa_s->current_bss ||
+		(!is_zero_ether_addr(bss->bssid) &&
+		 (os_memcmp(bss->bssid, wpa_s->bssid, ETH_ALEN) == 0 ||
+		  os_memcmp(bss->bssid, wpa_s->pending_bssid, ETH_ALEN) == 0));
 }
 
 
diff --git a/wpa_supplicant/bss.h b/wpa_supplicant/bss.h
index c9a108f..b215380 100644
--- a/wpa_supplicant/bss.h
+++ b/wpa_supplicant/bss.h
@@ -141,17 +141,6 @@ static inline int bss_is_dmg(const struct wpa_bss *bss)
 	return bss->freq > 45000;
 }
 
-/**
- * Test whether a BSS is a PBSS.
- * This checks whether a BSS is a DMG-band PBSS. PBSS is used for P2P DMG
- * network.
- */
-static inline int bss_is_pbss(struct wpa_bss *bss)
-{
-	return bss_is_dmg(bss) &&
-		(bss->caps & IEEE80211_CAP_DMG_MASK) == IEEE80211_CAP_DMG_PBSS;
-}
-
 static inline void wpa_bss_update_level(struct wpa_bss *bss, int new_level)
 {
 	if (bss != NULL && new_level < 0)
diff --git a/wpa_supplicant/config.c b/wpa_supplicant/config.c
index 3455fc0..4cdb804 100644
--- a/wpa_supplicant/config.c
+++ b/wpa_supplicant/config.c
@@ -15,7 +15,6 @@
 #include "rsn_supp/wpa.h"
 #include "eap_peer/eap.h"
 #include "p2p/p2p.h"
-#include "fst/fst.h"
 #include "config.h"
 
 
@@ -456,12 +455,6 @@ static int wpa_config_parse_psk(const struct parse_data *data,
 		}
 		wpa_hexdump_ascii_key(MSG_MSGDUMP, "PSK (ASCII passphrase)",
 				      (u8 *) value, len);
-		if (has_ctrl_char((u8 *) value, len)) {
-			wpa_printf(MSG_ERROR,
-				   "Line %d: Invalid passphrase character",
-				   line);
-			return -1;
-		}
 		if (ssid->passphrase && os_strlen(ssid->passphrase) == len &&
 		    os_memcmp(ssid->passphrase, value, len) == 0)
 			return 0;
@@ -557,6 +550,11 @@ static int wpa_config_parse_proto(const struct parse_data *data,
 			val |= WPA_PROTO_RSN;
 		else if (os_strcmp(start, "OSEN") == 0)
 			val |= WPA_PROTO_OSEN;
+#ifdef CONFIG_WAPI
+		else if (os_strcmp(start, "WAPI") == 0) {
+			val |= WPA_PROTO_WAPI;
+		}
+#endif
 		else {
 			wpa_printf(MSG_ERROR, "Line %d: invalid proto '%s'",
 				   line, start);
@@ -617,6 +615,16 @@ static char * wpa_config_write_proto(const struct parse_data *data,
 		pos += ret;
 	}
 
+#ifdef CONFIG_WAPI
+	if (ssid->proto & WPA_PROTO_WAPI) {
+		ret = os_snprintf(pos, end - pos, "%sWAPI",
+				  pos == buf ? "" : " ");
+		if (ret < 0 || ret >= end - pos)
+			return buf;
+		pos += ret;
+	}
+#endif
+
 	if (pos == buf) {
 		os_free(buf);
 		buf = NULL;
@@ -659,6 +667,12 @@ static int wpa_config_parse_key_mgmt(const struct parse_data *data,
 			val |= WPA_KEY_MGMT_NONE;
 		else if (os_strcmp(start, "WPA-NONE") == 0)
 			val |= WPA_KEY_MGMT_WPA_NONE;
+#ifdef CONFIG_WAPI
+		else if (os_strcmp(start, "WAPI-PSK") == 0)
+			val |= WPA_KEY_MGMT_WAPI_PSK;
+		else if (os_strcmp(start, "WAPI-CERT") == 0)
+			val |= WPA_KEY_MGMT_WAPI_CERT;
+#endif
 #ifdef CONFIG_IEEE80211R
 		else if (os_strcmp(start, "FT-PSK") == 0)
 			val |= WPA_KEY_MGMT_FT_PSK;
@@ -779,6 +793,28 @@ static char * wpa_config_write_key_mgmt(const struct parse_data *data,
 		pos += ret;
 	}
 
+#ifdef CONFIG_WAPI
+	if (ssid->key_mgmt & WPA_KEY_MGMT_WAPI_PSK) {
+		ret = os_snprintf(pos, end - pos, "%sWAPI-PSK",
+				  pos == buf ? "" : " ");
+		if (ret < 0 || ret >= end - pos) {
+			end[-1] = '\0';
+			return buf;
+		}
+		pos += ret;
+	}
+
+	if (ssid->key_mgmt & WPA_KEY_MGMT_WAPI_CERT) {
+		ret = os_snprintf(pos, end - pos, "%sWAPI-CERT",
+				  pos == buf ? "" : " ");
+		if (ret < 0 || ret >= end - pos) {
+			end[-1] = '\0';
+			return buf;
+		}
+		pos += ret;
+	}
+#endif
+
 #ifdef CONFIG_IEEE80211R
 	if (ssid->key_mgmt & WPA_KEY_MGMT_FT_PSK) {
 		ret = os_snprintf(pos, end - pos, "%sFT-PSK",
@@ -1843,8 +1879,6 @@ static const struct parse_data ssid_fields[] = {
 	{ FUNC(auth_alg) },
 	{ FUNC(scan_freq) },
 	{ FUNC(freq_list) },
-	{ INT_RANGE(max_oper_chwidth, VHT_CHANWIDTH_USE_HT,
-		    VHT_CHANWIDTH_80P80MHZ) },
 #ifdef IEEE8021X_EAPOL
 	{ FUNC(eap) },
 	{ STR_LENe(identity) },
@@ -1975,7 +2009,11 @@ static const struct parse_data ssid_fields[] = {
 	{ INT(update_identifier) },
 #endif /* CONFIG_HS20 */
 	{ INT_RANGE(mac_addr, 0, 2) },
-	{ INT_RANGE(pbss, 0, 2) },
+#ifdef CONFIG_WAPI
+	{ INT(psk_key_type) },
+	{ STR(wapi_user_cert) },
+	{ STR(wapi_as_cert) },
+#endif
 };
 
 #undef OFFSET
@@ -2161,6 +2199,10 @@ void wpa_config_free_ssid(struct wpa_ssid *ssid)
 #ifdef CONFIG_MESH
 	os_free(ssid->mesh_basic_rates);
 #endif /* CONFIG_MESH */
+#ifdef CONFIG_WAPI
+	os_free(ssid->wapi_as_cert);
+	os_free(ssid->wapi_user_cert);
+#endif
 	while ((psk = dl_list_first(&ssid->psk_list, struct psk_list_entry,
 				    list))) {
 		dl_list_del(&psk->list);
@@ -2279,7 +2321,6 @@ void wpa_config_free(struct wpa_config *config)
 	os_free(config->osu_dir);
 	os_free(config->bgscan);
 	os_free(config->wowlan_triggers);
-	os_free(config->fst_group_id);
 	os_free(config);
 }
 
@@ -2615,15 +2656,14 @@ char * wpa_config_get(struct wpa_ssid *ssid, const char *var)
 		const struct parse_data *field = &ssid_fields[i];
 		if (os_strcmp(var, field->name) == 0) {
 			char *ret = field->writer(field, ssid);
-
-			if (ret && has_newline(ret)) {
+			if (ret != NULL && (os_strchr(ret, '\r') != NULL ||
+				os_strchr(ret, '\n') != NULL)) {
 				wpa_printf(MSG_ERROR,
-					   "Found newline in value for %s; not returning it",
-					   var);
+					"Found newline in value for %s; "
+					"not returning it", var);
 				os_free(ret);
 				ret = NULL;
 			}
-
 			return ret;
 		}
 	}
@@ -2810,8 +2850,6 @@ int wpa_config_set_cred(struct wpa_cred *cred, const char *var,
 
 	if (os_strcmp(var, "password") == 0 &&
 	    os_strncmp(value, "ext:", 4) == 0) {
-		if (has_newline(value))
-			return -1;
 		str_clear_free(cred->password);
 		cred->password = os_strdup(value);
 		cred->ext_password = 1;
@@ -2862,14 +2900,9 @@ int wpa_config_set_cred(struct wpa_cred *cred, const char *var,
 	}
 
 	val = wpa_config_parse_string(value, &len);
-	if (val == NULL ||
-	    (os_strcmp(var, "excluded_ssid") != 0 &&
-	     os_strcmp(var, "roaming_consortium") != 0 &&
-	     os_strcmp(var, "required_roaming_consortium") != 0 &&
-	     has_newline(val))) {
+	if (val == NULL) {
 		wpa_printf(MSG_ERROR, "Line %d: invalid field '%s' string "
 			   "value '%s'.", line, var, value);
-		os_free(val);
 		return -1;
 	}
 
@@ -3670,12 +3703,6 @@ static int wpa_global_config_parse_str(const struct global_parse_data *data,
 		return -1;
 	}
 
-	if (has_newline(pos)) {
-		wpa_printf(MSG_ERROR, "Line %d: invalid %s value with newline",
-			   line, data->name);
-		return -1;
-	}
-
 	tmp = os_strdup(pos);
 	if (tmp == NULL)
 		return -1;
@@ -4269,11 +4296,6 @@ static const struct global_parse_data global_fields[] = {
 	{ INT(passive_scan), 0 },
 	{ INT(reassoc_same_bss_optim), 0 },
 	{ INT(wps_priority), 0},
-#ifdef CONFIG_FST
-	{ STR_RANGE(fst_group_id, 1, FST_MAX_GROUP_ID_LEN), 0 },
-	{ INT_RANGE(fst_priority, 1, FST_MAX_PRIO_VALUE), 0 },
-	{ INT_RANGE(fst_llt, 1, FST_MAX_LLT_MS), 0 },
-#endif /* CONFIG_FST */
 };
 
 #undef FUNC
diff --git a/wpa_supplicant/config.h b/wpa_supplicant/config.h
index 54a79f4..d8ca054 100644
--- a/wpa_supplicant/config.h
+++ b/wpa_supplicant/config.h
@@ -1184,22 +1184,6 @@ struct wpa_config {
 	 * by executing the WPS protocol.
 	 */
 	int wps_priority;
-
-	/**
-	 * fst_group_id - FST group ID
-	 */
-	char *fst_group_id;
-
-	/**
-	 * fst_priority - priority of the interface within the FST group
-	 */
-	int fst_priority;
-
-	/**
-	 * fst_llt - default FST LLT (Link-Lost Timeout) to be used for the
-	 * interface.
-	 */
-	int fst_llt;
 };
 
 
diff --git a/wpa_supplicant/config_file.c b/wpa_supplicant/config_file.c
index 15fefc2..230baad 100644
--- a/wpa_supplicant/config_file.c
+++ b/wpa_supplicant/config_file.c
@@ -751,8 +751,6 @@ static void wpa_config_write_network(FILE *f, struct wpa_ssid *ssid)
 	INT(disabled);
 	INT(peerkey);
 	INT(mixed_cell);
-	INT(max_oper_chwidth);
-	INT(pbss);
 #ifdef CONFIG_IEEE80211W
 	write_int(f, "ieee80211w", ssid->ieee80211w,
 		  MGMT_FRAME_PROTECTION_DEFAULT);
@@ -814,6 +812,11 @@ static void wpa_config_write_network(FILE *f, struct wpa_ssid *ssid)
 	INT_DEF(vht_tx_mcs_nss_7, -1);
 	INT_DEF(vht_tx_mcs_nss_8, -1);
 #endif /* CONFIG_VHT_OVERRIDES */
+#ifdef CONFIG_WAPI
+	INT(psk_key_type);
+	STR(wapi_as_cert);
+	STR(wapi_user_cert);
+#endif
 
 #undef STR
 #undef INT
diff --git a/wpa_supplicant/config_ssid.h b/wpa_supplicant/config_ssid.h
index ca4220d..107a591 100644
--- a/wpa_supplicant/config_ssid.h
+++ b/wpa_supplicant/config_ssid.h
@@ -358,19 +358,6 @@ struct wpa_ssid {
 	} mode;
 
 	/**
-	 * pbss - Whether to use PBSS. Relevant to DMG networks only.
-	 * 0 = do not use PBSS
-	 * 1 = use PBSS
-	 * 2 = don't care (not allowed in AP mode)
-	 * Used together with mode configuration. When mode is AP, it
-	 * means to start a PCP instead of a regular AP. When mode is INFRA it
-	 * means connect to a PCP instead of AP. In this mode you can also
-	 * specify 2 (don't care) meaning connect to either AP or PCP.
-	 * P2P_GO and P2P_GROUP_FORMATION modes must use PBSS in DMG network.
-	 */
-	int pbss;
-
-	/**
 	 * disabled - Whether this network is currently disabled
 	 *
 	 * 0 = this network can be used (default).
@@ -460,10 +447,6 @@ struct wpa_ssid {
 
 	int vht;
 
-	u8 max_oper_chwidth;
-
-	unsigned int vht_center_freq2;
-
 	/**
 	 * wpa_ptk_rekey - Maximum lifetime for PTK in seconds
 	 *
@@ -734,6 +717,12 @@ struct wpa_ssid {
 	 * this MBSS will trigger a peering attempt.
 	 */
 	int no_auto_peer;
+
+#ifdef CONFIG_WAPI
+	int psk_key_type;
+	char *wapi_as_cert;
+	char *wapi_user_cert;
+#endif
 };
 
 #endif /* CONFIG_SSID_H */
diff --git a/wpa_supplicant/ctrl_iface.c b/wpa_supplicant/ctrl_iface.c
index e0c82dd..db35c1d 100644
--- a/wpa_supplicant/ctrl_iface.c
+++ b/wpa_supplicant/ctrl_iface.c
@@ -28,8 +28,6 @@
 #include "rsn_supp/pmksa_cache.h"
 #include "l2_packet/l2_packet.h"
 #include "wps/wps.h"
-#include "fst/fst.h"
-#include "fst/fst_ctrl_iface.h"
 #include "config.h"
 #include "wpa_supplicant_i.h"
 #include "driver_i.h"
@@ -286,30 +284,6 @@ static int wpas_ctrl_pno(struct wpa_supplicant *wpa_s, char *cmd)
 }
 
 
-static int wpas_ctrl_set_band(struct wpa_supplicant *wpa_s, char *band)
-{
-	union wpa_event_data event;
-
-	if (os_strcmp(band, "AUTO") == 0)
-		wpa_s->setband = WPA_SETBAND_AUTO;
-	else if (os_strcmp(band, "5G") == 0)
-		wpa_s->setband = WPA_SETBAND_5G;
-	else if (os_strcmp(band, "2G") == 0)
-		wpa_s->setband = WPA_SETBAND_2G;
-	else
-		return -1;
-
-	if (wpa_drv_setband(wpa_s, wpa_s->setband) == 0) {
-		os_memset(&event, 0, sizeof(event));
-		event.channel_list_changed.initiator = REGDOM_SET_BY_USER;
-		event.channel_list_changed.type = REGDOM_TYPE_UNKNOWN;
-		wpa_supplicant_event(wpa_s, EVENT_CHANNEL_LIST_CHANGED, &event);
-	}
-
-	return 0;
-}
-
-
 static int wpa_supplicant_ctrl_iface_set(struct wpa_supplicant *wpa_s,
 					 char *cmd)
 {
@@ -473,7 +447,14 @@ static int wpa_supplicant_ctrl_iface_set(struct wpa_supplicant *wpa_s,
 		ret = wpas_ctrl_set_blob(wpa_s, value);
 #endif /* CONFIG_NO_CONFIG_BLOBS */
 	} else if (os_strcasecmp(cmd, "setband") == 0) {
-		ret = wpas_ctrl_set_band(wpa_s, value);
+		if (os_strcmp(value, "AUTO") == 0)
+			wpa_s->setband = WPA_SETBAND_AUTO;
+		else if (os_strcmp(value, "5G") == 0)
+			wpa_s->setband = WPA_SETBAND_5G;
+		else if (os_strcmp(value, "2G") == 0)
+			wpa_s->setband = WPA_SETBAND_2G;
+		else
+			ret = -1;
 	} else {
 		value[-1] = '=';
 		ret = wpa_config_process_global(wpa_s->conf, cmd, -1);
@@ -2136,6 +2117,45 @@ static int wpa_supplicant_ctrl_iface_blacklist(struct wpa_supplicant *wpa_s,
 }
 
 
+static const char * debug_level_str(int level)
+{
+	switch (level) {
+	case MSG_EXCESSIVE:
+		return "EXCESSIVE";
+	case MSG_MSGDUMP:
+		return "MSGDUMP";
+	case MSG_DEBUG:
+		return "DEBUG";
+	case MSG_INFO:
+		return "INFO";
+	case MSG_WARNING:
+		return "WARNING";
+	case MSG_ERROR:
+		return "ERROR";
+	default:
+		return "?";
+	}
+}
+
+
+static int str_to_debug_level(const char *s)
+{
+	if (os_strcasecmp(s, "EXCESSIVE") == 0)
+		return MSG_EXCESSIVE;
+	if (os_strcasecmp(s, "MSGDUMP") == 0)
+		return MSG_MSGDUMP;
+	if (os_strcasecmp(s, "DEBUG") == 0)
+		return MSG_DEBUG;
+	if (os_strcasecmp(s, "INFO") == 0)
+		return MSG_INFO;
+	if (os_strcasecmp(s, "WARNING") == 0)
+		return MSG_WARNING;
+	if (os_strcasecmp(s, "ERROR") == 0)
+		return MSG_ERROR;
+	return -1;
+}
+
+
 static int wpa_supplicant_ctrl_iface_log_level(struct wpa_supplicant *wpa_s,
 					       char *cmd, char *buf,
 					       size_t buflen)
@@ -2168,7 +2188,7 @@ static int wpa_supplicant_ctrl_iface_log_level(struct wpa_supplicant *wpa_s,
 		}
 	}
 
-	if (os_strlen(cmd)) {
+	if (cmd && os_strlen(cmd)) {
 		int level = str_to_debug_level(cmd);
 		if (level < 0)
 			return -1;
@@ -2480,6 +2500,25 @@ static int wpa_supplicant_ctrl_iface_scan_result(
 	if (osen_ie)
 		pos = wpa_supplicant_ie_txt(pos, end, "OSEN",
 					    osen_ie, 2 + osen_ie[1]);
+#ifdef CONFIG_WAPI
+	if(!ie && !ie2) {
+		ie = wpa_bss_get_ie(bss, WLAN_EID_WAPI);
+		if (ie) {
+			if (ie[9] == 2) {
+				wpa_printf(MSG_DEBUG, "WAPI: This is a WAPI PSK network");
+				ret = os_snprintf(pos, end - pos, "[WAPI-PSK]");
+			} else if (ie[9] == 1) {
+				wpa_printf(MSG_DEBUG, "WAPI: This is a WAPI CERT network");
+				ret = os_snprintf(pos, end - pos, "[WAPI-CERT]");
+			} else {
+				wpa_printf(MSG_ERROR, "WAPI: Unknown WAPI network type");
+				ret = os_snprintf(pos, end - pos, "[WAPI-Unknown]");
+			}
+			if (ret < 0 || ret >= end - pos) return -1;
+			pos += ret;
+		}
+	}
+#endif
 	pos = wpa_supplicant_wps_ie_txt(wpa_s, pos, end, bss);
 	if (!ie && !ie2 && !osen_ie && (bss->caps & IEEE80211_CAP_PRIVACY)) {
 		ret = os_snprintf(pos, end - pos, "[WEP]");
@@ -2545,14 +2584,6 @@ static int wpa_supplicant_ctrl_iface_scan_result(
 		pos += ret;
 	}
 #endif /* CONFIG_HS20 */
-#ifdef CONFIG_FST
-	if (wpa_bss_get_ie(bss, WLAN_EID_MULTI_BAND)) {
-		ret = os_snprintf(pos, end - pos, "[FST]");
-		if (os_snprintf_error(end - pos, ret))
-			return -1;
-		pos += ret;
-	}
-#endif /* CONFIG_FST */
 
 	ret = os_snprintf(pos, end - pos, "\t%s",
 			  wpa_ssid_txt(bss->ssid, bss->ssid_len));
@@ -2744,8 +2775,6 @@ static int wpa_supplicant_ctrl_iface_select_network(
 		}
 	}
 
-	wpa_s->scan_min_time.sec = 0;
-	wpa_s->scan_min_time.usec = 0;
 	wpa_supplicant_select_network(wpa_s, ssid);
 
 	return 0;
@@ -2783,8 +2812,6 @@ static int wpa_supplicant_ctrl_iface_enable_network(
 			return 0;
 		}
 	}
-	wpa_s->scan_min_time.sec = 0;
-	wpa_s->scan_min_time.usec = 0;
 	wpa_supplicant_enable_network(wpa_s, ssid);
 
 	return 0;
@@ -3039,19 +3066,19 @@ static int wpa_supplicant_ctrl_iface_get_network(
 	*name++ = '\0';
 
 	id = atoi(cmd);
-	wpa_printf(MSG_EXCESSIVE, "CTRL_IFACE: GET_NETWORK id=%d name='%s'",
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: GET_NETWORK id=%d name='%s'",
 		   id, name);
 
 	ssid = wpa_config_get_network(wpa_s->conf, id);
 	if (ssid == NULL) {
-		wpa_printf(MSG_EXCESSIVE, "CTRL_IFACE: Could not find network "
+		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
 			   "id=%d", id);
 		return -1;
 	}
 
 	value = wpa_config_get_no_key(ssid, name);
 	if (value == NULL) {
-		wpa_printf(MSG_EXCESSIVE, "CTRL_IFACE: Failed to get network "
+		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Failed to get network "
 			   "variable '%s'", name);
 		return -1;
 	}
@@ -3069,8 +3096,7 @@ static int wpa_supplicant_ctrl_iface_get_network(
 
 
 static int wpa_supplicant_ctrl_iface_dup_network(
-	struct wpa_supplicant *wpa_s, char *cmd,
-	struct wpa_supplicant *dst_wpa_s)
+	struct wpa_supplicant *wpa_s, char *cmd)
 {
 	struct wpa_ssid *ssid_s, *ssid_d;
 	char *name, *id, *value;
@@ -3089,10 +3115,8 @@ static int wpa_supplicant_ctrl_iface_dup_network(
 
 	id_s = atoi(cmd);
 	id_d = atoi(id);
-
-	wpa_printf(MSG_DEBUG,
-		   "CTRL_IFACE: DUP_NETWORK ifname=%s->%s id=%d->%d name='%s'",
-		   wpa_s->ifname, dst_wpa_s->ifname, id_s, id_d, name);
+	wpa_printf(MSG_DEBUG, "CTRL_IFACE: DUP_NETWORK id=%d -> %d name='%s'",
+		   id_s, id_d, name);
 
 	ssid_s = wpa_config_get_network(wpa_s->conf, id_s);
 	if (ssid_s == NULL) {
@@ -3101,7 +3125,7 @@ static int wpa_supplicant_ctrl_iface_dup_network(
 		return -1;
 	}
 
-	ssid_d = wpa_config_get_network(dst_wpa_s->conf, id_d);
+	ssid_d = wpa_config_get_network(wpa_s->conf, id_d);
 	if (ssid_d == NULL) {
 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find "
 			   "network id=%d", id_d);
@@ -3115,7 +3139,7 @@ static int wpa_supplicant_ctrl_iface_dup_network(
 		return -1;
 	}
 
-	ret = wpa_supplicant_ctrl_iface_update_network(dst_wpa_s, ssid_d, name,
+	ret = wpa_supplicant_ctrl_iface_update_network(wpa_s, ssid_d, name,
 						       value);
 
 	os_free(value);
@@ -4095,6 +4119,25 @@ static int print_bss_info(struct wpa_supplicant *wpa_s, struct wpa_bss *bss,
 		if (osen_ie)
 			pos = wpa_supplicant_ie_txt(pos, end, "OSEN",
 						    osen_ie, 2 + osen_ie[1]);
+#ifdef CONFIG_WAPI
+		if(!ie && !ie2) {
+			ie = wpa_bss_get_ie(bss, WLAN_EID_WAPI);
+			if (ie) {
+				if (ie[9] == 2) {
+					wpa_printf(MSG_DEBUG, "WAPI: This is a WAPI PSK network");
+					ret = os_snprintf(pos, end - pos, "[WAPI-PSK]");
+				} else if (ie[9] == 1) {
+					wpa_printf(MSG_DEBUG, "WAPI: This is a WAPI CERT network");
+					ret = os_snprintf(pos, end - pos, "[WAPI-CERT]");
+				} else {
+					wpa_printf(MSG_ERROR, "WAPI: Unknown WAPI network type");
+					ret = os_snprintf(pos, end - pos, "[WAPI-Unknown]");
+				}
+				if (ret < 0 || ret >= end - pos) return -1;
+				pos += ret;
+			}
+		}
+#endif
 		pos = wpa_supplicant_wps_ie_txt(wpa_s, pos, end, bss);
 		if (!ie && !ie2 && !osen_ie &&
 		    (bss->caps & IEEE80211_CAP_PRIVACY)) {
@@ -4278,15 +4321,6 @@ static int print_bss_info(struct wpa_supplicant *wpa_s, struct wpa_bss *bss,
 		pos += ret;
 	}
 
-#ifdef CONFIG_FST
-	if (mask & WPA_BSS_MASK_FST) {
-		ret = fst_ctrl_iface_mb_info(bss->bssid, pos, end - pos);
-		if (ret < 0 || ret >= end - pos)
-			return 0;
-		pos += ret;
-	}
-#endif /* CONFIG_FST */
-
 	if (mask & WPA_BSS_MASK_DELIM) {
 		ret = os_snprintf(pos, end - pos, "====\n");
 		if (os_snprintf_error(end - pos, ret))
@@ -4781,30 +4815,6 @@ static int p2p_ctrl_asp_provision(struct wpa_supplicant *wpa_s, char *cmd)
 }
 
 
-static int parse_freq(int chwidth, int freq2)
-{
-	if (freq2 < 0)
-		return -1;
-	if (freq2)
-		return VHT_CHANWIDTH_80P80MHZ;
-
-	switch (chwidth) {
-	case 0:
-	case 20:
-	case 40:
-		return VHT_CHANWIDTH_USE_HT;
-	case 80:
-		return VHT_CHANWIDTH_80MHZ;
-	case 160:
-		return VHT_CHANWIDTH_160MHZ;
-	default:
-		wpa_printf(MSG_DEBUG, "Unknown max oper bandwidth: %d",
-			   chwidth);
-		return -1;
-	}
-}
-
-
 static int p2p_ctrl_connect(struct wpa_supplicant *wpa_s, char *cmd,
 			    char *buf, size_t buflen)
 {
@@ -4821,7 +4831,7 @@ static int p2p_ctrl_connect(struct wpa_supplicant *wpa_s, char *cmd,
 	int go_intent = -1;
 	int freq = 0;
 	int pd;
-	int ht40, vht, max_oper_chwidth, chwidth = 0, freq2 = 0;
+	int ht40, vht;
 
 	if (!wpa_s->global->p2p_init_wpa_s)
 		return -1;
@@ -4882,18 +4892,6 @@ static int p2p_ctrl_connect(struct wpa_supplicant *wpa_s, char *cmd,
 			return -1;
 	}
 
-	pos2 = os_strstr(pos, " freq2=");
-	if (pos2)
-		freq2 = atoi(pos2 + 7);
-
-	pos2 = os_strstr(pos, " max_oper_chwidth=");
-	if (pos2)
-		chwidth = atoi(pos2 + 18);
-
-	max_oper_chwidth = parse_freq(chwidth, freq2);
-	if (max_oper_chwidth < 0)
-		return -1;
-
 	if (os_strncmp(pos, "pin", 3) == 0) {
 		/* Request random PIN (to be displayed) and enable the PIN */
 		wps_method = WPS_PIN_DISPLAY;
@@ -4918,8 +4916,8 @@ static int p2p_ctrl_connect(struct wpa_supplicant *wpa_s, char *cmd,
 
 	new_pin = wpas_p2p_connect(wpa_s, addr, pin, wps_method,
 				   persistent_group, automatic, join,
-				   auth, go_intent, freq, freq2, persistent_id,
-				   pd, ht40, vht, max_oper_chwidth);
+				   auth, go_intent, freq, persistent_id, pd,
+				   ht40, vht);
 	if (new_pin == -2) {
 		os_memcpy(buf, "FAIL-CHANNEL-UNAVAILABLE\n", 25);
 		return 25;
@@ -5459,7 +5457,7 @@ static int p2p_ctrl_invite_persistent(struct wpa_supplicant *wpa_s, char *cmd)
 	struct wpa_ssid *ssid;
 	u8 *_peer = NULL, peer[ETH_ALEN];
 	int freq = 0, pref_freq = 0;
-	int ht40, vht, max_oper_chwidth, chwidth = 0, freq2 = 0;
+	int ht40, vht;
 
 	id = atoi(cmd);
 	pos = os_strstr(cmd, " peer=");
@@ -5497,20 +5495,8 @@ static int p2p_ctrl_invite_persistent(struct wpa_supplicant *wpa_s, char *cmd)
 	ht40 = (os_strstr(cmd, " ht40") != NULL) || wpa_s->conf->p2p_go_ht40 ||
 		vht;
 
-	pos = os_strstr(cmd, "freq2=");
-	if (pos)
-		freq2 = atoi(pos + 6);
-
-	pos = os_strstr(cmd, " max_oper_chwidth=");
-	if (pos)
-		chwidth = atoi(pos + 18);
-
-	max_oper_chwidth = parse_freq(chwidth, freq2);
-	if (max_oper_chwidth < 0)
-		return -1;
-
-	return wpas_p2p_invite(wpa_s, _peer, ssid, NULL, freq, freq2, ht40, vht,
-			       max_oper_chwidth, pref_freq);
+	return wpas_p2p_invite(wpa_s, _peer, ssid, NULL, freq, ht40, vht,
+			       pref_freq);
 }
 
 
@@ -5557,8 +5543,7 @@ static int p2p_ctrl_invite(struct wpa_supplicant *wpa_s, char *cmd)
 
 
 static int p2p_ctrl_group_add_persistent(struct wpa_supplicant *wpa_s,
-					 int id, int freq, int vht_center_freq2,
-					 int ht40, int vht, int vht_chwidth)
+					 int id, int freq, int ht40, int vht)
 {
 	struct wpa_ssid *ssid;
 
@@ -5570,9 +5555,8 @@ static int p2p_ctrl_group_add_persistent(struct wpa_supplicant *wpa_s,
 		return -1;
 	}
 
-	return wpas_p2p_group_add_persistent(wpa_s, ssid, 0, freq,
-					     vht_center_freq2, 0, ht40, vht,
-					     vht_chwidth, NULL, 0, 0);
+	return wpas_p2p_group_add_persistent(wpa_s, ssid, 0, freq, 0, ht40, vht,
+					     NULL, 0);
 }
 
 
@@ -5581,14 +5565,11 @@ static int p2p_ctrl_group_add(struct wpa_supplicant *wpa_s, char *cmd)
 	int freq = 0, persistent = 0, group_id = -1;
 	int vht = wpa_s->conf->p2p_go_vht;
 	int ht40 = wpa_s->conf->p2p_go_ht40 || vht;
-	int max_oper_chwidth, chwidth = 0, freq2 = 0;
 	char *token, *context = NULL;
 
 	while ((token = str_token(cmd, " ", &context))) {
 		if (sscanf(token, "freq=%d", &freq) == 1 ||
-		    sscanf(token, "freq2=%d", &freq2) == 1 ||
-		    sscanf(token, "persistent=%d", &group_id) == 1 ||
-		    sscanf(token, "max_oper_chwidth=%d", &chwidth) == 1) {
+		    sscanf(token, "persistent=%d", &group_id) == 1) {
 			continue;
 		} else if (os_strcmp(token, "ht40") == 0) {
 			ht40 = 1;
@@ -5605,17 +5586,11 @@ static int p2p_ctrl_group_add(struct wpa_supplicant *wpa_s, char *cmd)
 		}
 	}
 
-	max_oper_chwidth = parse_freq(chwidth, freq2);
-	if (max_oper_chwidth < 0)
-		return -1;
-
 	if (group_id >= 0)
 		return p2p_ctrl_group_add_persistent(wpa_s, group_id,
-						     freq, freq2, ht40, vht,
-						     max_oper_chwidth);
+						     freq, ht40, vht);
 
-	return wpas_p2p_group_add(wpa_s, persistent, freq, freq2, ht40, vht,
-				  max_oper_chwidth);
+	return wpas_p2p_group_add(wpa_s, persistent, freq, ht40, vht);
 }
 
 
@@ -5774,15 +5749,8 @@ static int p2p_ctrl_set(struct wpa_supplicant *wpa_s, char *cmd)
 	}
 
 	if (os_strcmp(cmd, "listen_channel") == 0) {
-		char *pos;
-		u8 channel, op_class;
-
-		channel = atoi(param);
-		pos = os_strchr(param, ' ');
-		op_class = pos ? atoi(pos) : 81;
-
-		return p2p_set_listen_channel(wpa_s->global->p2p, op_class,
-					      channel, 1);
+		return p2p_set_listen_channel(wpa_s->global->p2p, 81,
+					      atoi(param), 1);
 	}
 
 	if (os_strcmp(cmd, "ssid_postfix") == 0) {
@@ -6615,53 +6583,6 @@ static int wpa_supplicant_signal_poll(struct wpa_supplicant *wpa_s, char *buf,
 }
 
 
-static int wpas_ctrl_iface_get_pref_freq_list(
-	struct wpa_supplicant *wpa_s, char *cmd, char *buf, size_t buflen)
-{
-	unsigned int freq_list[100], num = 100, i;
-	int ret;
-	enum wpa_driver_if_type iface_type;
-	char *pos, *end;
-
-	pos = buf;
-	end = buf + buflen;
-
-	/* buf: "<interface_type>" */
-	if (os_strcmp(cmd, "STATION") == 0)
-		iface_type = WPA_IF_STATION;
-	else if (os_strcmp(cmd, "AP") == 0)
-		iface_type = WPA_IF_AP_BSS;
-	else if (os_strcmp(cmd, "P2P_GO") == 0)
-		iface_type = WPA_IF_P2P_GO;
-	else if (os_strcmp(cmd, "P2P_CLIENT") == 0)
-		iface_type = WPA_IF_P2P_CLIENT;
-	else if (os_strcmp(cmd, "IBSS") == 0)
-		iface_type = WPA_IF_IBSS;
-	else if (os_strcmp(cmd, "TDLS") == 0)
-		iface_type = WPA_IF_TDLS;
-	else
-		return -1;
-
-	wpa_printf(MSG_DEBUG,
-		   "CTRL_IFACE: GET_PREF_FREQ_LIST iface_type=%d (%s)",
-		   iface_type, buf);
-
-	ret = wpa_drv_get_pref_freq_list(wpa_s, iface_type, &num, freq_list);
-	if (ret)
-		return -1;
-
-	for (i = 0; i < num; i++) {
-		ret = os_snprintf(pos, end - pos, "%s%u",
-				  i > 0 ? "," : "", freq_list[i]);
-		if (os_snprintf_error(end - pos, ret))
-			return -1;
-		pos += ret;
-	}
-
-	return pos - buf;
-}
-
-
 static int wpa_supplicant_pktcnt_poll(struct wpa_supplicant *wpa_s, char *buf,
 				      size_t buflen)
 {
@@ -6873,7 +6794,6 @@ static void wpa_supplicant_ctrl_iface_flush(struct wpa_supplicant *wpa_s)
 	}
 
 	eloop_cancel_timeout(wpas_network_reenabled, wpa_s, NULL);
-	wpa_s->wnmsleep_used = 0;
 }
 
 
@@ -7680,33 +7600,6 @@ static int wpas_ctrl_get_alloc_fail(struct wpa_supplicant *wpa_s,
 #endif /* WPA_TRACE_BFD */
 }
 
-
-static void wpas_ctrl_event_test_cb(void *eloop_ctx, void *timeout_ctx)
-{
-	struct wpa_supplicant *wpa_s = eloop_ctx;
-	int i, count = (intptr_t) timeout_ctx;
-
-	wpa_printf(MSG_DEBUG, "TEST: Send %d control interface event messages",
-		   count);
-	for (i = 0; i < count; i++) {
-		wpa_msg_ctrl(wpa_s, MSG_INFO, "TEST-EVENT-MESSAGE %d/%d",
-			     i + 1, count);
-	}
-}
-
-
-static int wpas_ctrl_event_test(struct wpa_supplicant *wpa_s, const char *cmd)
-{
-	int count;
-
-	count = atoi(cmd);
-	if (count <= 0)
-		return -1;
-
-	return eloop_register_timeout(0, 0, wpas_ctrl_event_test_cb, wpa_s,
-				      (void *) (intptr_t) count);
-}
-
 #endif /* CONFIG_TESTING_OPTIONS */
 
 
@@ -8084,19 +7977,6 @@ static int wpas_ctrl_iface_mac_rand_scan(struct wpa_supplicant *wpa_s,
 }
 
 
-static int wpas_ctrl_cmd_debug_level(const char *cmd)
-{
-	if (os_strcmp(cmd, "PING") == 0 ||
-	    os_strncmp(cmd, "BSS ", 4) == 0 ||
-	    os_strncmp(cmd, "GET_NETWORK ", 12) == 0 ||
-	    os_strncmp(cmd, "STATUS", 6) == 0 ||
-	    os_strncmp(cmd, "STA ", 4) == 0 ||
-	    os_strncmp(cmd, "STA-", 4) == 0)
-		return MSG_EXCESSIVE;
-	return MSG_DEBUG;
-}
-
-
 char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 					 char *buf, size_t *resp_len)
 {
@@ -8104,6 +7984,30 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 	const int reply_size = 4096;
 	int reply_len;
 
+#if defined(CONFIG_SC2351)
+	struct wpa_supplicant *iface;
+	/* force disconnect p2p connection when user try to do legacy connection */
+	if (os_strncmp(buf, "SELECT_NETWORK ", 15) == 0) {
+		for (iface = wpa_s->global->ifaces; iface; iface = iface->next) {
+			if(os_strcmp(iface->ifname, "p2p0")==0) {
+				wpas_p2p_disconnect(iface);
+				os_memset(iface->p2p_auth_invite, 0, ETH_ALEN);
+			}
+		}
+	}
+	/* force disconnect legacy connection when user try to do p2p connection */
+	if (os_strncmp(buf, "P2P_CONNECT ", 12) == 0 ||
+		os_strncmp(buf, "P2P_INVITE ", 11) == 0 ||
+		os_strncmp(buf, "P2P_GROUP_ADD ", 14) == 0) {
+		for (iface = wpa_s->global->ifaces; iface; iface = iface->next) {
+			if(os_strcmp(iface->ifname, "wlan0")==0) {
+				wpa_supplicant_disable_network(iface, NULL);
+				wpa_s->disconnected = 1;
+			}
+		}
+	}
+#endif
+
 	if (os_strncmp(buf, WPA_CTRL_RSP, os_strlen(WPA_CTRL_RSP)) == 0 ||
 	    os_strncmp(buf, "SET_NETWORK ", 12) == 0) {
 		if (wpa_debug_show_keys)
@@ -8120,7 +8024,12 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 		wpa_hexdump_ascii_key(MSG_DEBUG, "RX ctrl_iface",
 				      (const u8 *) buf, os_strlen(buf));
 	} else {
-		int level = wpas_ctrl_cmd_debug_level(buf);
+		int level = MSG_DEBUG;
+		if (os_strcmp(buf, "PING") == 0)
+			level = MSG_EXCESSIVE;
+#ifdef CONFIG_LOG_OPTIMIZATIOIN
+		if(os_strcmp(buf, "SIGNAL_POLL") != 0)
+#endif
 		wpa_dbg(wpa_s, level, "Control interface command '%s'", buf);
 	}
 
@@ -8537,9 +8446,6 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 	} else if (os_strcmp(buf, "SCAN_RESULTS") == 0) {
 		reply_len = wpa_supplicant_ctrl_iface_scan_results(
 			wpa_s, reply, reply_size);
-	} else if (os_strcmp(buf, "ABORT_SCAN") == 0) {
-		if (wpas_abort_ongoing_scan(wpa_s) < 0)
-			reply_len = -1;
 	} else if (os_strncmp(buf, "SELECT_NETWORK ", 15) == 0) {
 		if (wpa_supplicant_ctrl_iface_select_network(wpa_s, buf + 15))
 			reply_len = -1;
@@ -8562,8 +8468,7 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 		reply_len = wpa_supplicant_ctrl_iface_get_network(
 			wpa_s, buf + 12, reply, reply_size);
 	} else if (os_strncmp(buf, "DUP_NETWORK ", 12) == 0) {
-		if (wpa_supplicant_ctrl_iface_dup_network(wpa_s, buf + 12,
-							  wpa_s))
+		if (wpa_supplicant_ctrl_iface_dup_network(wpa_s, buf + 12))
 			reply_len = -1;
 	} else if (os_strcmp(buf, "LIST_CREDS") == 0) {
 		reply_len = wpa_supplicant_ctrl_iface_list_creds(
@@ -8739,9 +8644,6 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 			reply_len = -1;
 	} else if (os_strcmp(buf, "GET_ALLOC_FAIL") == 0) {
 		reply_len = wpas_ctrl_get_alloc_fail(wpa_s, reply, reply_size);
-	} else if (os_strncmp(buf, "EVENT_TEST ", 11) == 0) {
-		if (wpas_ctrl_event_test(wpa_s, buf + 11) < 0)
-			reply_len = -1;
 #endif /* CONFIG_TESTING_OPTIONS */
 	} else if (os_strncmp(buf, "VENDOR_ELEM_ADD ", 16) == 0) {
 		if (wpas_ctrl_vendor_elem_add(wpa_s, buf + 16) < 0)
@@ -8760,9 +8662,6 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 	} else if (os_strncmp(buf, "MAC_RAND_SCAN ", 14) == 0) {
 		if (wpas_ctrl_iface_mac_rand_scan(wpa_s, buf + 14))
 			reply_len = -1;
-	} else if (os_strncmp(buf, "GET_PREF_FREQ_LIST ", 19) == 0) {
-		reply_len = wpas_ctrl_iface_get_pref_freq_list(
-			wpa_s, buf + 19, reply, reply_size);
 	} else {
 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
@@ -9164,41 +9063,6 @@ static int wpas_global_ctrl_iface_set(struct wpa_global *global, char *cmd)
 }
 
 
-static int wpas_global_ctrl_iface_dup_network(struct wpa_global *global,
-					      char *cmd)
-{
-	struct wpa_supplicant *wpa_s[2]; /* src, dst */
-	char *p;
-	unsigned int i;
-
-	/* cmd: "<src ifname> <dst ifname> <src network id> <dst network id>
-	 * <variable name> */
-
-	for (i = 0; i < ARRAY_SIZE(wpa_s) ; i++) {
-		p = os_strchr(cmd, ' ');
-		if (p == NULL)
-			return -1;
-		*p = '\0';
-
-		wpa_s[i] = global->ifaces;
-		for (; wpa_s[i]; wpa_s[i] = wpa_s[i]->next) {
-			if (os_strcmp(cmd, wpa_s[i]->ifname) == 0)
-				break;
-		}
-
-		if (!wpa_s[i]) {
-			wpa_printf(MSG_DEBUG,
-				   "CTRL_IFACE: Could not find iface=%s", cmd);
-			return -1;
-		}
-
-		cmd = p + 1;
-	}
-
-	return wpa_supplicant_ctrl_iface_dup_network(wpa_s[0], cmd, wpa_s[1]);
-}
-
-
 #ifndef CONFIG_NO_CONFIG_WRITE
 static int wpas_global_ctrl_iface_save_config(struct wpa_global *global)
 {
@@ -9280,59 +9144,6 @@ static int wpas_global_ctrl_iface_status(struct wpa_global *global,
 }
 
 
-#ifdef CONFIG_FST
-
-static int wpas_global_ctrl_iface_fst_attach(struct wpa_global *global,
-					     char *cmd, char *buf,
-					     size_t reply_size)
-{
-	char ifname[IFNAMSIZ + 1];
-	struct fst_iface_cfg cfg;
-	struct wpa_supplicant *wpa_s;
-	struct fst_wpa_obj iface_obj;
-
-	if (!fst_parse_attach_command(cmd, ifname, sizeof(ifname), &cfg)) {
-		wpa_s = wpa_supplicant_get_iface(global, ifname);
-		if (wpa_s) {
-			if (wpa_s->fst) {
-				wpa_printf(MSG_INFO, "FST: Already attached");
-				return -1;
-			}
-			fst_wpa_supplicant_fill_iface_obj(wpa_s, &iface_obj);
-			wpa_s->fst = fst_attach(ifname, wpa_s->own_addr,
-						&iface_obj, &cfg);
-			if (wpa_s->fst)
-				return os_snprintf(buf, reply_size, "OK\n");
-		}
-	}
-
-	return -1;
-}
-
-
-static int wpas_global_ctrl_iface_fst_detach(struct wpa_global *global,
-					     char *cmd, char *buf,
-					     size_t reply_size)
-{
-	char ifname[IFNAMSIZ + 1];
-	struct wpa_supplicant *wpa_s;
-
-	if (!fst_parse_detach_command(cmd, ifname, sizeof(ifname))) {
-		wpa_s = wpa_supplicant_get_iface(global, ifname);
-		if (wpa_s) {
-			if (!fst_iface_detach(ifname)) {
-				wpa_s->fst = NULL;
-				return os_snprintf(buf, reply_size, "OK\n");
-			}
-		}
-	}
-
-	return -1;
-}
-
-#endif /* CONFIG_FST */
-
-
 char * wpa_supplicant_global_ctrl_iface_process(struct wpa_global *global,
 						char *buf, size_t *resp_len)
 {
@@ -9384,18 +9195,6 @@ char * wpa_supplicant_global_ctrl_iface_process(struct wpa_global *global,
 	} else if (os_strcmp(buf, "INTERFACES") == 0) {
 		reply_len = wpa_supplicant_global_iface_interfaces(
 			global, reply, reply_size);
-#ifdef CONFIG_FST
-	} else if (os_strncmp(buf, "FST-ATTACH ", 11) == 0) {
-		reply_len = wpas_global_ctrl_iface_fst_attach(global, buf + 11,
-							      reply,
-							      reply_size);
-	} else if (os_strncmp(buf, "FST-DETACH ", 11) == 0) {
-		reply_len = wpas_global_ctrl_iface_fst_detach(global, buf + 11,
-							      reply,
-							      reply_size);
-	} else if (os_strncmp(buf, "FST-MANAGER ", 12) == 0) {
-		reply_len = fst_ctrl_iface_receive(buf + 12, reply, reply_size);
-#endif /* CONFIG_FST */
 	} else if (os_strcmp(buf, "TERMINATE") == 0) {
 		wpa_supplicant_terminate_proc(global);
 	} else if (os_strcmp(buf, "SUSPEND") == 0) {
@@ -9416,9 +9215,6 @@ char * wpa_supplicant_global_ctrl_iface_process(struct wpa_global *global,
 #endif /* CONFIG_P2P */
 			reply_len = -1;
 		}
-	} else if (os_strncmp(buf, "DUP_NETWORK ", 12) == 0) {
-		if (wpas_global_ctrl_iface_dup_network(global, buf + 12))
-			reply_len = -1;
 #ifndef CONFIG_NO_CONFIG_WRITE
 	} else if (os_strcmp(buf, "SAVE_CONFIG") == 0) {
 		if (wpas_global_ctrl_iface_save_config(global))
diff --git a/wpa_supplicant/ctrl_iface_unix.c b/wpa_supplicant/ctrl_iface_unix.c
index 21de621..d8be99d 100644
--- a/wpa_supplicant/ctrl_iface_unix.c
+++ b/wpa_supplicant/ctrl_iface_unix.c
@@ -13,10 +13,6 @@
 #include <stddef.h>
 #include <unistd.h>
 #include <fcntl.h>
-#ifdef __linux__
-#include <sys/ioctl.h>
-#include <linux/sockios.h>
-#endif /* __linux__ */
 #ifdef ANDROID
 #include <cutils/sockets.h>
 #endif /* ANDROID */
@@ -52,8 +48,6 @@ struct ctrl_iface_priv {
 	int sock;
 	struct dl_list ctrl_dst;
 	int android_control_socket;
-	struct dl_list msg_queue;
-	unsigned int throttle_count;
 };
 
 
@@ -62,17 +56,6 @@ struct ctrl_iface_global_priv {
 	int sock;
 	struct dl_list ctrl_dst;
 	int android_control_socket;
-	struct dl_list msg_queue;
-	unsigned int throttle_count;
-};
-
-struct ctrl_iface_msg {
-	struct dl_list list;
-	struct wpa_supplicant *wpa_s;
-	int level;
-	enum wpa_msg_type type;
-	const char *txt;
-	size_t len;
 };
 
 
@@ -89,32 +72,6 @@ static int wpas_ctrl_iface_global_reinit(struct wpa_global *global,
 					 struct ctrl_iface_global_priv *priv);
 
 
-static void wpas_ctrl_sock_debug(const char *title, int sock, const char *buf,
-				 size_t len)
-{
-#ifdef __linux__
-	socklen_t optlen;
-	int sndbuf, outq;
-	int level = MSG_DEBUG;
-
-	if (len >= 5 && os_strncmp(buf, "PONG\n", 5) == 0)
-		level = MSG_EXCESSIVE;
-
-	optlen = sizeof(sndbuf);
-	sndbuf = 0;
-	if (getsockopt(sock, SOL_SOCKET, SO_SNDBUF, &sndbuf, &optlen) < 0)
-		sndbuf = -1;
-
-	if (ioctl(sock, SIOCOUTQ, &outq) < 0)
-		outq = -1;
-
-	wpa_printf(level,
-		   "CTRL-DEBUG: %s: sock=%d sndbuf=%d outq=%d send_len=%d",
-		   title, sock, sndbuf, outq, (int) len);
-#endif /* __linux__ */
-}
-
-
 static int wpa_supplicant_ctrl_iface_attach(struct dl_list *ctrl_dst,
 					    struct sockaddr_un *from,
 					    socklen_t fromlen, int global)
@@ -258,8 +215,6 @@ static void wpa_supplicant_ctrl_iface_receive(int sock, void *eloop_ctx,
 	}
 
 	if (reply) {
-		wpas_ctrl_sock_debug("ctrl_sock-sendto", sock, reply,
-				     reply_len);
 		if (sendto(sock, reply, reply_len, 0, (struct sockaddr *) &from,
 			   fromlen) < 0) {
 			int _errno = errno;
@@ -347,209 +302,32 @@ static char * wpa_supplicant_ctrl_iface_path(struct wpa_supplicant *wpa_s)
 }
 
 
-static int wpas_ctrl_iface_throttle(int sock)
-{
-#ifdef __linux__
-	socklen_t optlen;
-	int sndbuf, outq;
-
-	optlen = sizeof(sndbuf);
-	sndbuf = 0;
-	if (getsockopt(sock, SOL_SOCKET, SO_SNDBUF, &sndbuf, &optlen) < 0 ||
-	    ioctl(sock, SIOCOUTQ, &outq) < 0 ||
-	    sndbuf <= 0 || outq < 0)
-		return 0;
-	return outq > sndbuf / 2;
-#else /* __linux__ */
-	return 0;
-#endif /* __linux__ */
-}
-
-
-static void wpas_ctrl_msg_send_pending_global(struct wpa_global *global)
-{
-	struct ctrl_iface_global_priv *gpriv;
-	struct ctrl_iface_msg *msg;
-
-	gpriv = global->ctrl_iface;
-	while (gpriv && !dl_list_empty(&gpriv->msg_queue) &&
-	       !wpas_ctrl_iface_throttle(gpriv->sock)) {
-		msg = dl_list_first(&gpriv->msg_queue, struct ctrl_iface_msg,
-				    list);
-		if (!msg)
-			break;
-		dl_list_del(&msg->list);
-		wpa_supplicant_ctrl_iface_send(
-			msg->wpa_s,
-			msg->type != WPA_MSG_PER_INTERFACE ?
-			NULL : msg->wpa_s->ifname,
-			gpriv->sock, &gpriv->ctrl_dst, msg->level,
-			msg->txt, msg->len, NULL, gpriv);
-		os_free(msg);
-	}
-}
-
-
-static void wpas_ctrl_msg_send_pending_iface(struct wpa_supplicant *wpa_s)
-{
-	struct ctrl_iface_priv *priv;
-	struct ctrl_iface_msg *msg;
-
-	priv = wpa_s->ctrl_iface;
-	while (priv && !dl_list_empty(&priv->msg_queue) &&
-	       !wpas_ctrl_iface_throttle(priv->sock)) {
-		msg = dl_list_first(&priv->msg_queue, struct ctrl_iface_msg,
-				    list);
-		if (!msg)
-			break;
-		dl_list_del(&msg->list);
-		wpa_supplicant_ctrl_iface_send(wpa_s, NULL, priv->sock,
-					       &priv->ctrl_dst, msg->level,
-					       msg->txt, msg->len, priv, NULL);
-		os_free(msg);
-	}
-}
-
-
-static void wpas_ctrl_msg_queue_timeout(void *eloop_ctx, void *timeout_ctx)
-{
-	struct wpa_supplicant *wpa_s = eloop_ctx;
-	struct ctrl_iface_priv *priv;
-	struct ctrl_iface_global_priv *gpriv;
-	int sock = -1, gsock = -1;
-
-	wpas_ctrl_msg_send_pending_global(wpa_s->global);
-	wpas_ctrl_msg_send_pending_iface(wpa_s);
-
-	priv = wpa_s->ctrl_iface;
-	if (priv && !dl_list_empty(&priv->msg_queue))
-		sock = priv->sock;
-
-	gpriv = wpa_s->global->ctrl_iface;
-	if (gpriv && !dl_list_empty(&gpriv->msg_queue))
-		gsock = gpriv->sock;
-
-	if (sock > -1 || gsock > -1) {
-		/* Continue pending message transmission from a timeout */
-		wpa_printf(MSG_MSGDUMP,
-			   "CTRL: Had to throttle pending event message transmission for (sock %d gsock %d)",
-			   sock, gsock);
-		eloop_register_timeout(0, 20000, wpas_ctrl_msg_queue_timeout,
-				       wpa_s, NULL);
-	}
-}
-
-
-static void wpas_ctrl_msg_queue(struct dl_list *queue,
-				struct wpa_supplicant *wpa_s, int level,
-				enum wpa_msg_type type,
-				const char *txt, size_t len)
-{
-	struct ctrl_iface_msg *msg;
-
-	msg = os_zalloc(sizeof(*msg) + len);
-	if (!msg)
-		return;
-
-	msg->wpa_s = wpa_s;
-	msg->level = level;
-	msg->type = type;
-	os_memcpy(msg + 1, txt, len);
-	msg->txt = (const char *) (msg + 1);
-	msg->len = len;
-	dl_list_add_tail(queue, &msg->list);
-	eloop_cancel_timeout(wpas_ctrl_msg_queue_timeout, wpa_s, NULL);
-	eloop_register_timeout(0, 0, wpas_ctrl_msg_queue_timeout, wpa_s, NULL);
-}
-
-
-static void wpas_ctrl_msg_queue_limit(unsigned int throttle_count,
-				      struct dl_list *queue)
-{
-	struct ctrl_iface_msg *msg;
-
-	if (throttle_count < 2000)
-		return;
-
-	msg = dl_list_first(queue, struct ctrl_iface_msg, list);
-	if (msg) {
-		wpa_printf(MSG_DEBUG, "CTRL: Dropped oldest pending message");
-		dl_list_del(&msg->list);
-		os_free(msg);
-	}
-}
-
-
 static void wpa_supplicant_ctrl_iface_msg_cb(void *ctx, int level,
 					     enum wpa_msg_type type,
 					     const char *txt, size_t len)
 {
 	struct wpa_supplicant *wpa_s = ctx;
-	struct ctrl_iface_priv *priv;
-	struct ctrl_iface_global_priv *gpriv;
 
 	if (wpa_s == NULL)
 		return;
 
-	gpriv = wpa_s->global->ctrl_iface;
-
-	if (type != WPA_MSG_NO_GLOBAL && gpriv &&
-	    !dl_list_empty(&gpriv->ctrl_dst)) {
-		if (!dl_list_empty(&gpriv->msg_queue) ||
-		    wpas_ctrl_iface_throttle(gpriv->sock)) {
-			if (gpriv->throttle_count == 0) {
-				wpa_printf(MSG_MSGDUMP,
-					   "CTRL: Had to throttle global event message for sock %d",
-					   gpriv->sock);
-			}
-			gpriv->throttle_count++;
-			wpas_ctrl_msg_queue_limit(gpriv->throttle_count,
-						  &gpriv->msg_queue);
-			wpas_ctrl_msg_queue(&gpriv->msg_queue, wpa_s, level,
-					    type, txt, len);
-		} else {
-			if (gpriv->throttle_count) {
-				wpa_printf(MSG_MSGDUMP,
-					   "CTRL: Had to throttle %u global event message(s) for sock %d",
-					   gpriv->throttle_count, gpriv->sock);
-			}
-			gpriv->throttle_count = 0;
+	if (type != WPA_MSG_NO_GLOBAL && wpa_s->global->ctrl_iface) {
+		struct ctrl_iface_global_priv *priv = wpa_s->global->ctrl_iface;
+		if (!dl_list_empty(&priv->ctrl_dst)) {
 			wpa_supplicant_ctrl_iface_send(
 				wpa_s,
-				type != WPA_MSG_PER_INTERFACE ?
-				NULL : wpa_s->ifname,
-				gpriv->sock, &gpriv->ctrl_dst, level,
-				txt, len, NULL, gpriv);
+				type == WPA_MSG_GLOBAL ? NULL : wpa_s->ifname,
+				priv->sock, &priv->ctrl_dst, level, txt, len,
+				NULL, priv);
 		}
 	}
 
-	priv = wpa_s->ctrl_iface;
-
-	if (type != WPA_MSG_ONLY_GLOBAL && priv) {
-		if (!dl_list_empty(&priv->msg_queue) ||
-		    wpas_ctrl_iface_throttle(priv->sock)) {
-			if (priv->throttle_count == 0) {
-				wpa_printf(MSG_MSGDUMP,
-					   "CTRL: Had to throttle event message for sock %d",
-					   priv->sock);
-			}
-			priv->throttle_count++;
-			wpas_ctrl_msg_queue_limit(priv->throttle_count,
-						  &priv->msg_queue);
-			wpas_ctrl_msg_queue(&priv->msg_queue, wpa_s, level,
-					    type, txt, len);
-		} else {
-			if (priv->throttle_count) {
-				wpa_printf(MSG_MSGDUMP,
-					   "CTRL: Had to throttle %u event message(s) for sock %d",
-					   priv->throttle_count, priv->sock);
-			}
-			priv->throttle_count = 0;
-			wpa_supplicant_ctrl_iface_send(wpa_s, NULL, priv->sock,
-						       &priv->ctrl_dst, level,
-						       txt, len, priv, NULL);
-		}
-	}
+	if (wpa_s->ctrl_iface == NULL)
+		return;
+	wpa_supplicant_ctrl_iface_send(wpa_s, NULL, wpa_s->ctrl_iface->sock,
+				       &wpa_s->ctrl_iface->ctrl_dst,
+				       level, txt, len, wpa_s->ctrl_iface,
+				       NULL);
 }
 
 
@@ -767,7 +545,6 @@ wpa_supplicant_ctrl_iface_init(struct wpa_supplicant *wpa_s)
 	if (priv == NULL)
 		return NULL;
 	dl_list_init(&priv->ctrl_dst);
-	dl_list_init(&priv->msg_queue);
 	priv->wpa_s = wpa_s;
 	priv->sock = -1;
 
@@ -814,8 +591,6 @@ static int wpas_ctrl_iface_reinit(struct wpa_supplicant *wpa_s,
 void wpa_supplicant_ctrl_iface_deinit(struct ctrl_iface_priv *priv)
 {
 	struct wpa_ctrl_dst *dst, *prev;
-	struct ctrl_iface_msg *msg, *prev_msg;
-	struct ctrl_iface_global_priv *gpriv;
 
 	if (priv->sock > -1) {
 		char *fname;
@@ -871,22 +646,6 @@ free_dst:
 	dl_list_for_each_safe(dst, prev, &priv->ctrl_dst, struct wpa_ctrl_dst,
 			      list)
 		os_free(dst);
-	dl_list_for_each_safe(msg, prev_msg, &priv->msg_queue,
-			      struct ctrl_iface_msg, list) {
-		dl_list_del(&msg->list);
-		os_free(msg);
-	}
-	gpriv = priv->wpa_s->global->ctrl_iface;
-	if (gpriv) {
-		dl_list_for_each_safe(msg, prev_msg, &gpriv->msg_queue,
-				      struct ctrl_iface_msg, list) {
-			if (msg->wpa_s == priv->wpa_s) {
-				dl_list_del(&msg->list);
-				os_free(msg);
-			}
-		}
-	}
-	eloop_cancel_timeout(wpas_ctrl_msg_queue_timeout, priv->wpa_s, NULL);
 	os_free(priv);
 }
 
@@ -956,11 +715,11 @@ static void wpa_supplicant_ctrl_iface_send(struct wpa_supplicant *wpa_s,
 			      offsetof(struct sockaddr_un, sun_path));
 		msg.msg_name = (void *) &dst->addr;
 		msg.msg_namelen = dst->addrlen;
-		wpas_ctrl_sock_debug("ctrl_sock-sendmsg", sock, buf, len);
 		if (sendmsg(sock, &msg, MSG_DONTWAIT) >= 0) {
-			wpa_printf(MSG_MSGDUMP,
-				   "CTRL_IFACE monitor sent successfully to %s",
+#ifndef CONFIG_LOG_OPTIMIZATIOIN
+			wpa_printf(MSG_DEBUG, "CTRL_IFACE monitor sent successfully to %s",
 				   addr_txt);
+#endif
 			dst->errors = 0;
 			continue;
 		}
@@ -1114,8 +873,6 @@ static void wpa_supplicant_global_ctrl_iface_receive(int sock, void *eloop_ctx,
 	}
 
 	if (reply) {
-		wpas_ctrl_sock_debug("global_ctrl_sock-sendto",
-				     sock, reply, reply_len);
 		if (sendto(sock, reply, reply_len, 0, (struct sockaddr *) &from,
 			   fromlen) < 0) {
 			wpa_printf(MSG_DEBUG, "ctrl_iface sendto failed: %s",
@@ -1316,7 +1073,6 @@ wpa_supplicant_global_ctrl_iface_init(struct wpa_global *global)
 	if (priv == NULL)
 		return NULL;
 	dl_list_init(&priv->ctrl_dst);
-	dl_list_init(&priv->msg_queue);
 	priv->global = global;
 	priv->sock = -1;
 
@@ -1366,7 +1122,6 @@ void
 wpa_supplicant_global_ctrl_iface_deinit(struct ctrl_iface_global_priv *priv)
 {
 	struct wpa_ctrl_dst *dst, *prev;
-	struct ctrl_iface_msg *msg, *prev_msg;
 
 	if (priv->sock >= 0) {
 		eloop_unregister_read_sock(priv->sock);
@@ -1377,10 +1132,5 @@ wpa_supplicant_global_ctrl_iface_deinit(struct ctrl_iface_global_priv *priv)
 	dl_list_for_each_safe(dst, prev, &priv->ctrl_dst, struct wpa_ctrl_dst,
 			      list)
 		os_free(dst);
-	dl_list_for_each_safe(msg, prev_msg, &priv->msg_queue,
-			      struct ctrl_iface_msg, list) {
-		dl_list_del(&msg->list);
-		os_free(msg);
-	}
 	os_free(priv);
 }
diff --git a/wpa_supplicant/dbus/dbus_new.c b/wpa_supplicant/dbus/dbus_new.c
index 190822b..1959ea7 100644
--- a/wpa_supplicant/dbus/dbus_new.c
+++ b/wpa_supplicant/dbus/dbus_new.c
@@ -1203,7 +1203,7 @@ static int match_group_where_peer_is_client(struct p2p_group *group,
 					 cfg->ssid_len);
 	if (wpa_s_go != NULL && wpa_s_go == data->wpa_s) {
 		wpas_dbus_signal_peer_groups_changed(
-			data->wpa_s->p2pdev, data->info->p2p_device_addr);
+			data->wpa_s->parent, data->info->p2p_device_addr);
 		return 0;
 	}
 
@@ -1220,7 +1220,7 @@ static void signal_peer_groups_changed(struct p2p_peer_info *info,
 	wpa_s_go = wpas_get_p2p_client_iface(data->wpa_s,
 					     info->p2p_device_addr);
 	if (wpa_s_go != NULL && wpa_s_go == data->wpa_s) {
-		wpas_dbus_signal_peer_groups_changed(data->wpa_s->p2pdev,
+		wpas_dbus_signal_peer_groups_changed(data->wpa_s->parent,
 						     info->p2p_device_addr);
 		return;
 	}
diff --git a/wpa_supplicant/dbus/dbus_new_handlers_p2p.c b/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
index f552905..e9d60df 100644
--- a/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
+++ b/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
@@ -364,14 +364,13 @@ DBusMessage * wpas_dbus_handler_p2p_group_add(DBusMessage *message,
 			goto inv_args;
 
 		if (wpas_p2p_group_add_persistent(wpa_s, ssid, 0, freq, 0, 0, 0,
-						  0, 0, NULL, 0, 0)) {
+						  NULL, 0)) {
 			reply = wpas_dbus_error_unknown_error(
 				message,
 				"Failed to reinvoke a persistent group");
 			goto out;
 		}
-	} else if (wpas_p2p_group_add(wpa_s, persistent_group, freq, 0, 0, 0,
-		    0))
+	} else if (wpas_p2p_group_add(wpa_s, persistent_group, freq, 0, 0))
 		goto inv_args;
 
 out:
@@ -583,7 +582,7 @@ DBusMessage * wpas_dbus_handler_p2p_connect(DBusMessage *message,
 
 	new_pin = wpas_p2p_connect(wpa_s, addr, pin, wps_method,
 				   persistent_group, 0, join, authorize_only,
-				   go_intent, freq, 0, -1, 0, 0, 0, 0);
+				   go_intent, freq, -1, 0, 0, 0);
 
 	if (new_pin >= 0) {
 		char npin[9];
@@ -734,8 +733,8 @@ DBusMessage * wpas_dbus_handler_p2p_invite(DBusMessage *message,
 		if (ssid == NULL || ssid->disabled != 2)
 			goto err;
 
-		if (wpas_p2p_invite(wpa_s, peer_addr, ssid, NULL, 0, 0, 0, 0, 0,
-				    0) < 0) {
+		if (wpas_p2p_invite(wpa_s, peer_addr, ssid, NULL, 0, 0, 0, 0) <
+		    0) {
 			reply = wpas_dbus_error_unknown_error(
 				message,
 				"Failed to reinvoke a persistent group");
diff --git a/wpa_supplicant/defconfig b/wpa_supplicant/defconfig
index d714a69..7f627fd 100644
--- a/wpa_supplicant/defconfig
+++ b/wpa_supplicant/defconfig
@@ -495,9 +495,3 @@ CONFIG_PEERKEY=y
 #
 # External password backend for testing purposes (developer use)
 #CONFIG_EXT_PASSWORD_TEST=y
-
-# Enable Fast Session Transfer (FST)
-#CONFIG_FST=y
-
-# Enable CLI commands for FST testing
-#CONFIG_FST_TEST=y
diff --git a/wpa_supplicant/driver_i.h b/wpa_supplicant/driver_i.h
index c739c72..1fcb180 100644
--- a/wpa_supplicant/driver_i.h
+++ b/wpa_supplicant/driver_i.h
@@ -885,38 +885,4 @@ static inline int wpa_drv_disable_transmit_sa(struct wpa_supplicant *wpa_s,
 }
 #endif /* CONFIG_MACSEC */
 
-static inline int wpa_drv_setband(struct wpa_supplicant *wpa_s,
-				  enum set_band band)
-{
-	if (!wpa_s->driver->set_band)
-		return -1;
-	return wpa_s->driver->set_band(wpa_s->drv_priv, band);
-}
-
-static inline int wpa_drv_abort_scan(struct wpa_supplicant *wpa_s)
-{
-	if (!wpa_s->driver->abort_scan)
-		return -1;
-	return wpa_s->driver->abort_scan(wpa_s->drv_priv);
-}
-
-static inline int wpa_drv_get_pref_freq_list(struct wpa_supplicant *wpa_s,
-					     enum wpa_driver_if_type if_type,
-					     unsigned int *num,
-					     unsigned int *freq_list)
-{
-	if (!wpa_s->driver->get_pref_freq_list)
-		return -1;
-	return wpa_s->driver->get_pref_freq_list(wpa_s->drv_priv, if_type,
-						 num, freq_list);
-}
-
-static inline int wpa_drv_set_prob_oper_freq(struct wpa_supplicant *wpa_s,
-					     unsigned int freq)
-{
-	if (!wpa_s->driver->set_prob_oper_freq)
-		return 0;
-	return wpa_s->driver->set_prob_oper_freq(wpa_s->drv_priv, freq);
-}
-
 #endif /* DRIVER_I_H */
diff --git a/wpa_supplicant/eap_proxy_qmi.mak b/wpa_supplicant/eap_proxy_qmi.mak
deleted file mode 100644
index 0a046f6..0000000
--- a/wpa_supplicant/eap_proxy_qmi.mak
+++ /dev/null
@@ -1,19 +0,0 @@
-CFLAGS += -DSIM_AKA_IDENTITY_IMSI
-CFLAGS += -DSIM_AKA_IMSI_RAW_ENABLED
-
-CFLAGS += $(shell $(PKG_CONFIG) --cflags qmi qmi-framework)
-
-LIBS += $(shell $(PKG_CONFIG) --libs qmi qmi-framework) -lpthread
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-# This is supported only in B Family devices.
-CONFIG_EAP_AKA_PRIME=y
-
-ifdef CONFIG_EAP_PROXY_AKA_PRIME
-CFLAGS += -DCONFIG_EAP_PROXY_AKA_PRIME
-endif
-
-ifdef CONFIG_EAP_PROXY_DUAL_SIM
-CFLAGS += -DCONFIG_EAP_PROXY_DUAL_SIM
-endif
diff --git a/wpa_supplicant/eap_proxy_qmi.mk b/wpa_supplicant/eap_proxy_qmi.mk
deleted file mode 100644
index 139c058..0000000
--- a/wpa_supplicant/eap_proxy_qmi.mk
+++ /dev/null
@@ -1,38 +0,0 @@
-
-LOCAL_PATH := $(call my-dir)
-
-ifeq ($(BOARD_HAS_QCOM_WLAN), true)
-L_CFLAGS += -DSIM_AKA_IDENTITY_IMSI
-#L_CFLAGS += -DSIM_AKA_IMSI_RAW_ENABLED
-
-ifdef CONFIG_EAP_PROXY_DUAL_SIM
-L_CFLAGS += -DCONFIG_EAP_PROXY_DUAL_SIM
-endif
-
-LIB_SHARED_EAP_PROXY := libqmi_cci libqmiservices libidl
-INCLUDES += $(TARGET_OUT_HEADERS)/qmi-framework/inc
-INCLUDES += $(TARGET_OUT_HEADERS)/qmi/inc
-INCLUDES += $(TARGET_OUT_HEADERS)/qmi/platform
-INCLUDES += $(TARGET_OUT_HEADERS)/qmi/core/lib/inc
-
-ifdef CONFIG_EAP_PROXY_MDM_DETECT
-L_CFLAGS += -DCONFIG_EAP_PROXY_MDM_DETECT
-INCLUDES += $(TARGET_OUT_HEADERS)/libmdmdetect/inc
-LIB_SHARED_EAP_PROXY += libmdmdetect
-endif
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-# This is supported only in B Family devices.
-ifdef CONFIG_EAP_PROXY_AKA_PRIME
-L_CFLAGS += -DCONFIG_EAP_PROXY_AKA_PRIME
-endif
-
-ifdef CONFIG_EAP_PROXY_MSM8994_TARGET
-L_CFLAGS += -DCONFIG_EAP_PROXY_MSM8994_TARGET
-endif
-
-#ANDROID_SETGROUPS_OVERRIDE := AID_RADIO AID_WIFI AID_KEYSTORE AID_DIAG AID_INET AID_QCOM_DIAG AID_NET_RAW
-L_CFLAGS += -DANDROID_SETGROUPS_OVERRIDE=1001,1010,1017,2002,1003,3009,3004
-endif
-
diff --git a/wpa_supplicant/events.c b/wpa_supplicant/events.c
index 567fbc0..1a9e4ce 100644
--- a/wpa_supplicant/events.c
+++ b/wpa_supplicant/events.c
@@ -23,7 +23,6 @@
 #include "eap_peer/eap.h"
 #include "ap/hostapd.h"
 #include "p2p/p2p.h"
-#include "fst/fst.h"
 #include "wnm_sta.h"
 #include "notify.h"
 #include "common/ieee802_11_defs.h"
@@ -47,6 +46,7 @@
 #include "mesh_mpm.h"
 #include "wmm_ac.h"
 
+#define BLACKLIST_LIMITATION 2
 
 #ifndef CONFIG_NO_SCAN_PROCESSING
 static int wpas_select_network_from_last_scan(struct wpa_supplicant *wpa_s,
@@ -306,7 +306,6 @@ void wpa_supplicant_mark_disassoc(struct wpa_supplicant *wpa_s)
 	wpa_s->key_mgmt = 0;
 
 	wpas_rrm_reset(wpa_s);
-	wpa_s->wnmsleep_used = 0;
 }
 
 
@@ -843,7 +842,7 @@ static struct wpa_ssid * wpa_scan_res_match(struct wpa_supplicant *wpa_s,
 
 	e = wpa_blacklist_get(wpa_s, bss->bssid);
 	if (e) {
-		int limit = 1;
+		int limit = BLACKLIST_LIMITATION;
 		if (wpa_supplicant_enabled_networks(wpa_s) == 1) {
 			/*
 			 * When only a single network is enabled, we can
@@ -853,7 +852,7 @@ static struct wpa_ssid * wpa_scan_res_match(struct wpa_supplicant *wpa_s,
 			 * single error if there are no other BSSes of the
 			 * current ESS.
 			 */
-			limit = 0;
+			//limit = 0;
 		}
 		if (e->count > limit) {
 			wpa_dbg(wpa_s, MSG_DEBUG, "   skip - blacklisted "
@@ -896,7 +895,7 @@ static struct wpa_ssid * wpa_scan_res_match(struct wpa_supplicant *wpa_s,
 		}
 
 #ifdef CONFIG_WPS
-		if ((ssid->key_mgmt & WPA_KEY_MGMT_WPS) && e && e->count > 0) {
+		if ((ssid->key_mgmt & WPA_KEY_MGMT_WPS) && e && e->count > BLACKLIST_LIMITATION) {
 			wpa_dbg(wpa_s, MSG_DEBUG, "   skip - blacklisted "
 				"(WPS)");
 			continue;
@@ -951,6 +950,22 @@ static struct wpa_ssid * wpa_scan_res_match(struct wpa_supplicant *wpa_s,
 				"   skip - BSSID not in whitelist");
 			continue;
 		}
+#ifdef CONFIG_WAPI
+		const u8 *wapi_ie;
+		u8 wapi_ie_len;
+		wapi_ie = wpa_bss_get_ie(bss, WLAN_EID_WAPI);
+		if ((ssid->proto & WPA_PROTO_WAPI) && wapi_ie) {
+			if(os_strcmp(wpa_s->ifname,"wlan0")) return NULL;
+			if ( (ssid->key_mgmt & WPA_KEY_MGMT_WAPI_PSK) && (wapi_ie[9] == 2) ) {
+				wpa_printf(MSG_DEBUG, "WAPI: PSK network is selected based on WAPI IE");
+				return ssid;
+			}
+			if ( (ssid->key_mgmt & WPA_KEY_MGMT_WAPI_CERT) && (wapi_ie[9] == 1) ) {
+				wpa_printf(MSG_DEBUG, "WAPI: CERT network is selected based on WAPI IE");
+				return ssid;
+			}
+		}
+#endif
 
 		if (!wpa_supplicant_ssid_bss_match(wpa_s, ssid, bss))
 			continue;
@@ -982,14 +997,8 @@ static struct wpa_ssid * wpa_scan_res_match(struct wpa_supplicant *wpa_s,
 			continue;
 		}
 
-		if (!bss_is_ess(bss) && !bss_is_pbss(bss)) {
-			wpa_dbg(wpa_s, MSG_DEBUG, "   skip - neither ESS nor PBSS network");
-			continue;
-		}
-
-		if (ssid->pbss != 2 && ssid->pbss != bss_is_pbss(bss)) {
-			wpa_dbg(wpa_s, MSG_DEBUG, "   skip - PBSS mismatch (ssid %d bss %d)",
-				ssid->pbss, bss_is_pbss(bss));
+		if (!bss_is_ess(bss)) {
+			wpa_dbg(wpa_s, MSG_DEBUG, "   skip - not ESS network");
 			continue;
 		}
 
@@ -1046,19 +1055,6 @@ static struct wpa_ssid * wpa_scan_res_match(struct wpa_supplicant *wpa_s,
 		 */
 #endif /* CONFIG_P2P */
 
-		if (os_reltime_before(&bss->last_update, &wpa_s->scan_min_time))
-		{
-			struct os_reltime diff;
-
-			os_reltime_sub(&wpa_s->scan_min_time,
-				       &bss->last_update, &diff);
-			wpa_dbg(wpa_s, MSG_DEBUG,
-				"   skip - scan result not recent enough (%u.%06u seconds too old)",
-				(unsigned int) diff.sec,
-				(unsigned int) diff.usec);
-			continue;
-		}
-
 		/* Matching configuration found */
 		return ssid;
 	}
@@ -1075,13 +1071,6 @@ wpa_supplicant_select_bss(struct wpa_supplicant *wpa_s,
 			  int only_first_ssid)
 {
 	unsigned int i;
-#ifdef MTK_HARDWARE
-	struct wpa_bss *temp_bss = NULL;
-	struct dl_list *list_next = NULL;
-	int shared_freq = 0;
-	int num = 0;
-#endif
-
 
 	if (only_first_ssid)
 		wpa_dbg(wpa_s, MSG_DEBUG, "Try to find BSS matching pre-selected network id=%d",
@@ -1089,49 +1078,6 @@ wpa_supplicant_select_bss(struct wpa_supplicant *wpa_s,
 	else
 		wpa_dbg(wpa_s, MSG_DEBUG, "Selecting BSS from priority group %d",
 			group->priority);
-#ifdef MTK_HARDWARE
-       if (os_strncmp(wpa_s->ifname, "wlan", 4) == 0)
-               num = get_shared_radio_freqs(wpa_s, &shared_freq, 1);
-       /*
-	* for channel conflict revise feature
-	* if p2p/wfd is connected, search in full scan result to find the ssid.
-	* because framework also base on
-	* this result, but not last scan result.
-	*
-	* changes in function wpa_bss_in_use will asure the intended bsses
-	* are not removed from full scan result.
-	*/
-       if (num > 0 && shared_freq > 0) {
-	       wpa_printf(MSG_DEBUG, "try to find a bss on freq %d", shared_freq);
-	       temp_bss = dl_list_first(&wpa_s->bss, struct wpa_bss, list);
-	       for (i = 0; i < wpa_s->num_bss; i++) {
-		       list_next = temp_bss->list.next;
-		       if (temp_bss->freq != shared_freq) {
-			       temp_bss = dl_list_entry(list_next, struct wpa_bss, list);
-			       continue;
-		       }
-		       *selected_ssid = wpa_scan_res_match(wpa_s, i, temp_bss, group,
-				       only_first_ssid);
-
-		       if (!*selected_ssid) {
-			       temp_bss = dl_list_entry(list_next, struct wpa_bss, list);
-			       continue;
-		       }
-
-		       wpa_printf(MSG_DEBUG, "on Freq %d, "
-				       "found a BSS in previous scan res", shared_freq);
-		       return temp_bss;
-	       }
-	       /*
-		* it is rarely that we aren't able to find this ssid in full scan result,
-		* unless this bss was removed just after
-		* framework select this bss and before send command to wpa_supplicant
-		*/
-	       wpa_printf(MSG_ERROR, "didn't find BSS on freq %d, "
-			       "try to find on other freqs", shared_freq);
-       }
-#endif
-
 
 	for (i = 0; i < wpa_s->last_scan_res_used; i++) {
 		struct wpa_bss *bss = wpa_s->last_scan_res[i];
@@ -1476,8 +1422,6 @@ static int _wpa_supplicant_event_scan_results(struct wpa_supplicant *wpa_s,
 			return -1;
 		if (!own_request)
 			return -1;
-		if (data && data->scan_info.external_scan)
-			return -1;
 		wpa_dbg(wpa_s, MSG_DEBUG, "Failed to get scan results - try "
 			"scanning again");
 		wpa_supplicant_req_new_scan(wpa_s, 1, 0);
@@ -1502,7 +1446,7 @@ static int _wpa_supplicant_event_scan_results(struct wpa_supplicant *wpa_s,
 #endif /* CONFIG_NO_RANDOM_POOL */
 
 	if (own_request && wpa_s->scan_res_handler &&
-	    !(data && data->scan_info.external_scan)) {
+	    (wpa_s->own_scan_running || !wpa_s->radio->external_scan_running)) {
 		void (*scan_res_handler)(struct wpa_supplicant *wpa_s,
 					 struct wpa_scan_results *scan_res);
 
@@ -1523,11 +1467,9 @@ static int _wpa_supplicant_event_scan_results(struct wpa_supplicant *wpa_s,
 	}
 
 	wpa_dbg(wpa_s, MSG_DEBUG, "New scan results available (own=%u ext=%u)",
-		wpa_s->own_scan_running,
-		data ? data->scan_info.external_scan : 0);
+		wpa_s->own_scan_running, wpa_s->radio->external_scan_running);
 	if (wpa_s->last_scan_req == MANUAL_SCAN_REQ &&
-	    wpa_s->manual_scan_use_id && wpa_s->own_scan_running &&
-	    own_request && !(data && data->scan_info.external_scan)) {
+	    wpa_s->manual_scan_use_id && wpa_s->own_scan_running) {
 		wpa_msg_ctrl(wpa_s, MSG_INFO, WPA_EVENT_SCAN_RESULTS "id=%u",
 			     wpa_s->manual_scan_id);
 		wpa_s->manual_scan_use_id = 0;
@@ -1538,7 +1480,7 @@ static int _wpa_supplicant_event_scan_results(struct wpa_supplicant *wpa_s,
 
 	wpas_notify_scan_done(wpa_s, 1);
 
-	if (data && data->scan_info.external_scan) {
+	if (!wpa_s->own_scan_running && wpa_s->radio->external_scan_running) {
 		wpa_dbg(wpa_s, MSG_DEBUG, "Do not use results from externally requested scan operation for network selection");
 		wpa_scan_results_free(scan_res);
 		return 0;
@@ -1569,7 +1511,7 @@ static int _wpa_supplicant_event_scan_results(struct wpa_supplicant *wpa_s,
 
 	wpa_scan_results_free(scan_res);
 
-	if (own_request && wpa_s->scan_work) {
+	if (wpa_s->scan_work) {
 		struct wpa_radio_work *work = wpa_s->scan_work;
 		wpa_s->scan_work = NULL;
 		radio_work_done(work);
@@ -1579,7 +1521,7 @@ static int _wpa_supplicant_event_scan_results(struct wpa_supplicant *wpa_s,
 
 scan_work_done:
 	wpa_scan_results_free(scan_res);
-	if (own_request && wpa_s->scan_work) {
+	if (wpa_s->scan_work) {
 		struct wpa_radio_work *work = wpa_s->scan_work;
 		wpa_s->scan_work = NULL;
 		radio_work_done(work);
@@ -1706,10 +1648,6 @@ static int wpas_select_network_from_last_scan(struct wpa_supplicant *wpa_s,
 
 			wpa_msg_ctrl(wpa_s, MSG_INFO,
 				     WPA_EVENT_NETWORK_NOT_FOUND);
-#ifdef MTK_HARDWARE
-			if (os_strncmp(wpa_s->ifname, "wlan", 4) == 0)
-				wpa_s->current_ssid = NULL;
-#endif
 		}
 	}
 	return 0;
@@ -1897,50 +1835,6 @@ static void interworking_process_assoc_resp(struct wpa_supplicant *wpa_s,
 #endif /* CONFIG_INTERWORKING */
 
 
-#ifdef CONFIG_FST
-static int wpas_fst_update_mbie(struct wpa_supplicant *wpa_s,
-				const u8 *ie, size_t ie_len)
-{
-	struct mb_ies_info mb_ies;
-
-	if (!ie || !ie_len || !wpa_s->fst)
-	    return -ENOENT;
-
-	os_memset(&mb_ies, 0, sizeof(mb_ies));
-
-	while (ie_len >= 2 && mb_ies.nof_ies < MAX_NOF_MB_IES_SUPPORTED) {
-		size_t len;
-
-		len = 2 + ie[1];
-		if (len > ie_len) {
-			wpa_hexdump(MSG_DEBUG, "FST: Truncated IE found",
-				    ie, ie_len);
-			break;
-		}
-
-		if (ie[0] == WLAN_EID_MULTI_BAND) {
-			wpa_printf(MSG_DEBUG, "MB IE of %u bytes found",
-				   (unsigned int) len);
-			mb_ies.ies[mb_ies.nof_ies].ie = ie + 2;
-			mb_ies.ies[mb_ies.nof_ies].ie_len = len - 2;
-			mb_ies.nof_ies++;
-		}
-
-		ie_len -= len;
-		ie += len;
-	}
-
-	if (mb_ies.nof_ies > 0) {
-		wpabuf_free(wpa_s->received_mb_ies);
-		wpa_s->received_mb_ies = mb_ies_by_info(&mb_ies);
-		return 0;
-	}
-
-	return -ENOENT;
-}
-#endif /* CONFIG_FST */
-
-
 static int wpa_supplicant_event_associnfo(struct wpa_supplicant *wpa_s,
 					  union wpa_event_data *data)
 {
@@ -2161,51 +2055,11 @@ static int wpa_supplicant_assoc_update_ie(struct wpa_supplicant *wpa_s)
 }
 
 
-static void wpas_fst_update_mb_assoc(struct wpa_supplicant *wpa_s,
-				     union wpa_event_data *data)
-{
-#ifdef CONFIG_FST
-	struct assoc_info *ai = data ? &data->assoc_info : NULL;
-	struct wpa_bss *bss = wpa_s->current_bss;
-	const u8 *ieprb, *iebcn;
-
-	wpabuf_free(wpa_s->received_mb_ies);
-	wpa_s->received_mb_ies = NULL;
-
-	if (ai &&
-	    !wpas_fst_update_mbie(wpa_s, ai->resp_ies, ai->resp_ies_len)) {
-		wpa_printf(MSG_DEBUG,
-			   "FST: MB IEs updated from Association Response frame");
-		return;
-	}
-
-	if (ai &&
-	    !wpas_fst_update_mbie(wpa_s, ai->beacon_ies, ai->beacon_ies_len)) {
-		wpa_printf(MSG_DEBUG,
-			   "FST: MB IEs updated from association event Beacon IEs");
-		return;
-	}
-
-	if (!bss)
-		return;
-
-	ieprb = (const u8 *) (bss + 1);
-	iebcn = ieprb + bss->ie_len;
-
-	if (!wpas_fst_update_mbie(wpa_s, ieprb, bss->ie_len))
-		wpa_printf(MSG_DEBUG, "FST: MB IEs updated from bss IE");
-	else if (!wpas_fst_update_mbie(wpa_s, iebcn, bss->beacon_ie_len))
-		wpa_printf(MSG_DEBUG, "FST: MB IEs updated from bss beacon IE");
-#endif /* CONFIG_FST */
-}
-
-
 static void wpa_supplicant_event_assoc(struct wpa_supplicant *wpa_s,
 				       union wpa_event_data *data)
 {
 	u8 bssid[ETH_ALEN];
 	int ft_completed;
-	int new_bss = 0;
 
 #ifdef CONFIG_AP
 	if (wpa_s->ap_iface) {
@@ -2219,6 +2073,51 @@ static void wpa_supplicant_event_assoc(struct wpa_supplicant *wpa_s,
 		return;
 	}
 #endif /* CONFIG_AP */
+#ifdef CONFIG_WAPI
+	if (wpa_s->current_ssid && (wpa_s->current_ssid->proto & WPA_PROTO_WAPI)) {
+		u8 *ap_wapi_ie;
+		u8 ap_wapi_ie_len;
+		MAC_ADDRESS bssid_s;
+		MAC_ADDRESS own_s;
+
+		wpa_printf(MSG_DEBUG,"WAPI: %s: associated to a wapi network.\n", __FUNCTION__);
+		if (wpa_drv_get_bssid(wpa_s, bssid) >= 0 &&
+			os_memcmp(bssid, wpa_s->bssid, ETH_ALEN) != 0) {
+			wpa_msg(wpa_s, MSG_DEBUG, "Associated to a new BSS: BSSID="
+				MACSTR, MAC2STR(bssid));
+			os_memcpy(wpa_s->bssid, bssid, ETH_ALEN);
+			os_memset(wpa_s->pending_bssid, 0, ETH_ALEN);
+		}
+
+		os_memset(&bssid_s, 0, sizeof(bssid_s));
+		os_memset(&own_s, 0, sizeof(own_s));
+		os_memcpy(bssid_s.v, bssid, sizeof(bssid_s.v));
+		os_memcpy(own_s.v, wpa_s->own_addr, sizeof(own_s.v));
+		wpa_hexdump(MSG_DEBUG,"WAPI: bssid",bssid, sizeof(bssid));
+		wpa_hexdump(MSG_DEBUG,"WAPI: own mac",wpa_s->own_addr, 6);
+
+		if(wpa_s->current_bss == NULL) return;
+		ap_wapi_ie = wpa_bss_get_ie(wpa_s->current_bss, WLAN_EID_WAPI);
+		ap_wapi_ie_len = ap_wapi_ie ? 2 + ap_wapi_ie[1] : 0;
+		if(ap_wapi_ie_len)
+		{
+			wpa_printf(MSG_DEBUG,"WAPI: ap_wapi_ie_len is %d \n", ap_wapi_ie_len);
+			WAI_Msg_Input(CONN_ASSOC, &bssid_s, &own_s, ap_wapi_ie, ap_wapi_ie_len);
+		}
+		else
+		{
+			wpa_printf(MSG_DEBUG,"WAPI: ap_wapi_ie_len is Zero \n");
+			WAI_Msg_Input(CONN_ASSOC, &bssid_s, &own_s, NULL, 0);
+		}
+
+		wpa_supplicant_cancel_auth_timeout(wpa_s);
+		wpa_supplicant_set_state(wpa_s, WPA_ASSOCIATED);
+		wpa_msg(wpa_s, MSG_INFO, "Associated with " MACSTR, MAC2STR(bssid));
+		wpa_s->assoc_freq = data->assoc_info.freq;
+		wpa_printf(MSG_DEBUG,"wpa_s->assoc_freq = %u \n", wpa_s->assoc_freq);
+		return;
+	}
+#endif
 
 	eloop_cancel_timeout(wpas_network_reenabled, wpa_s, NULL);
 
@@ -2237,7 +2136,6 @@ static void wpa_supplicant_event_assoc(struct wpa_supplicant *wpa_s,
 	if (os_memcmp(bssid, wpa_s->bssid, ETH_ALEN) != 0) {
 		wpa_dbg(wpa_s, MSG_DEBUG, "Associated to a new BSS: BSSID="
 			MACSTR, MAC2STR(bssid));
-		new_bss = 1;
 		random_add_randomness(bssid, ETH_ALEN);
 		os_memcpy(wpa_s->bssid, bssid, ETH_ALEN);
 		os_memset(wpa_s->pending_bssid, 0, ETH_ALEN);
@@ -2251,21 +2149,19 @@ static void wpa_supplicant_event_assoc(struct wpa_supplicant *wpa_s,
 				wpa_s, WLAN_REASON_DEAUTH_LEAVING);
 			return;
 		}
-	}
 
 #ifdef ANDROID
-	if (wpa_s->conf->ap_scan == 1) {
+		if (wpa_s->conf->ap_scan == 1) {
 #else
-	if (wpa_s->conf->ap_scan == 1 &&
-	    wpa_s->drv_flags & WPA_DRIVER_FLAGS_BSS_SELECTION) {
+		if (wpa_s->conf->ap_scan == 1 &&
+		    wpa_s->drv_flags & WPA_DRIVER_FLAGS_BSS_SELECTION) {
 #endif
-		if (wpa_supplicant_assoc_update_ie(wpa_s) < 0 && new_bss)
-			wpa_msg(wpa_s, MSG_WARNING,
-				"WPA/RSN IEs not updated");
+			if (wpa_supplicant_assoc_update_ie(wpa_s) < 0)
+				wpa_msg(wpa_s, MSG_WARNING,
+					"WPA/RSN IEs not updated");
+		}
 	}
 
-	wpas_fst_update_mb_assoc(wpa_s, data);
-
 #ifdef CONFIG_SME
 	os_memcpy(wpa_s->sme.prev_bssid, bssid, ETH_ALEN);
 	wpa_s->sme.prev_bssid_set = 1;
@@ -2486,6 +2382,33 @@ static void wpa_supplicant_event_disassoc_finish(struct wpa_supplicant *wpa_s,
 	authenticating = wpa_s->wpa_state == WPA_AUTHENTICATING;
 	os_memcpy(prev_pending_bssid, wpa_s->pending_bssid, ETH_ALEN);
 
+#ifdef CONFIG_WAPI
+	if (wpa_s->current_ssid && (wpa_s->current_ssid->proto == WPA_PROTO_WAPI)) { /* this is a WAPI network */
+		MAC_ADDRESS bssid_s;
+		MAC_ADDRESS own_s;
+
+		os_memset(&bssid_s, 0, sizeof(bssid_s));
+		os_memset(&own_s, 0, sizeof(own_s));
+		os_memcpy(bssid_s.v, wpa_s->bssid, sizeof(bssid_s.v));
+		os_memcpy(own_s.v, wpa_s->own_addr, sizeof(own_s.v));
+
+		WAI_Msg_Input(CONN_DISASSOC, &bssid_s, &own_s, NULL, 0);
+
+		if (wpa_s->wpa_state >= WPA_ASSOCIATED)
+			wpa_supplicant_req_scan(wpa_s, 0, 100000);
+		bssid = wpa_s->bssid;
+		if (os_memcmp(bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) == 0)
+			bssid = wpa_s->pending_bssid;
+		wpa_blacklist_add(wpa_s, bssid);
+		wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_DISCONNECTED "- Disconnect event - "
+			"remove keys");
+		wpa_supplicant_mark_disassoc(wpa_s);
+		wpas_connect_work_done(wpa_s);
+
+		return;
+	}
+#endif
+
 	if (wpa_s->key_mgmt == WPA_KEY_MGMT_WPA_NONE) {
 		/*
 		 * At least Host AP driver and a Prism3 card seemed to be
@@ -2507,8 +2430,7 @@ static void wpa_supplicant_event_disassoc_finish(struct wpa_supplicant *wpa_s,
 	if (!wpa_s->disconnected &&
 	    (!wpa_s->auto_reconnect_disabled ||
 	     wpa_s->key_mgmt == WPA_KEY_MGMT_WPS ||
-	     wpas_wps_searching(wpa_s) ||
-	     wpas_wps_reenable_networks_pending(wpa_s))) {
+	     wpas_wps_searching(wpa_s))) {
 		wpa_dbg(wpa_s, MSG_DEBUG, "Auto connect enabled: try to "
 			"reconnect (wps=%d/%d wpa_state=%d)",
 			wpa_s->key_mgmt == WPA_KEY_MGMT_WPS,
@@ -2537,10 +2459,7 @@ static void wpa_supplicant_event_disassoc_finish(struct wpa_supplicant *wpa_s,
 			"try to re-connect");
 		wpa_s->reassociate = 0;
 		wpa_s->disconnected = 1;
-#ifdef ANDROID
-		if (!wpa_s->pno)
-#endif
-			wpa_supplicant_cancel_sched_scan(wpa_s);
+		wpa_supplicant_cancel_sched_scan(wpa_s);
 	}
 	bssid = wpa_s->bssid;
 	if (is_zero_ether_addr(bssid))
@@ -2768,6 +2687,11 @@ wpa_supplicant_event_interface_status(struct wpa_supplicant *wpa_s,
 		}
 #endif /* CONFIG_P2P */
 
+#ifdef CONFIG_WAPI
+		l2_packet_deinit(wpa_s->l2_wapi);
+		wpa_s->l2_wapi = NULL;
+#endif
+
 #ifdef CONFIG_TERMINATE_ONLASTIF
 		/* check if last interface */
 		if (!any_interfaces(wpa_s->global->ifaces))
@@ -3289,13 +3213,6 @@ static void wpas_event_rx_mgmt_action(struct wpa_supplicant *wpa_s,
 		return;
 	}
 
-#ifdef CONFIG_FST
-	if (mgmt->u.action.category == WLAN_ACTION_FST && wpa_s->fst) {
-		fst_rx_action(wpa_s->fst, mgmt, len);
-		return;
-	}
-#endif /* CONFIG_FST */
-
 	wpas_p2p_rx_action(wpa_s, mgmt->da, mgmt->sa, mgmt->bssid,
 			   category, payload, plen, freq);
 	if (wpa_s->ifmsh)
@@ -3412,20 +3329,12 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 
 	switch (event) {
 	case EVENT_AUTH:
-#ifdef CONFIG_FST
-		wpas_fst_update_mbie(wpa_s, data->auth.ies, data->auth.ies_len);
-#endif /* CONFIG_FST */
 		sme_event_auth(wpa_s, data);
 		break;
 	case EVENT_ASSOC:
 		wpa_supplicant_event_assoc(wpa_s, data);
 		if (data && data->assoc_info.authorized)
 			wpa_supplicant_event_assoc_auth(wpa_s, data);
-		if (data) {
-			wpa_msg(wpa_s, MSG_INFO,
-				WPA_EVENT_SUBNET_STATUS_UPDATE "status=%u",
-				data->assoc_info.subnet_status);
-		}
 		break;
 	case EVENT_DISASSOC:
 		wpas_event_disassoc(wpa_s,
@@ -3440,11 +3349,10 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 		break;
 #ifndef CONFIG_NO_SCAN_PROCESSING
 	case EVENT_SCAN_STARTED:
-		if (wpa_s->own_scan_requested ||
-		    (data && !data->scan_info.external_scan)) {
+		os_get_reltime(&wpa_s->scan_start_time);
+		if (wpa_s->own_scan_requested) {
 			struct os_reltime diff;
 
-			os_get_reltime(&wpa_s->scan_start_time);
 			os_reltime_sub(&wpa_s->scan_start_time,
 				       &wpa_s->scan_trigger_time, &diff);
 			wpa_dbg(wpa_s, MSG_DEBUG, "Own scan request started a scan in %ld.%06ld seconds",
@@ -3467,8 +3375,7 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 		}
 		break;
 	case EVENT_SCAN_RESULTS:
-		if (!(data && data->scan_info.external_scan) &&
-		    os_reltime_initialized(&wpa_s->scan_start_time)) {
+		if (os_reltime_initialized(&wpa_s->scan_start_time)) {
 			struct os_reltime now, diff;
 			os_get_reltime(&now);
 			os_reltime_sub(&now, &wpa_s->scan_start_time, &diff);
@@ -3479,10 +3386,8 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 		}
 		if (wpa_supplicant_event_scan_results(wpa_s, data))
 			break; /* interface may have been removed */
-		if (!(data && data->scan_info.external_scan))
-			wpa_s->own_scan_running = 0;
-		if (data && data->scan_info.nl_scan_event)
-			wpa_s->radio->external_scan_running = 0;
+		wpa_s->own_scan_running = 0;
+		wpa_s->radio->external_scan_running = 0;
 		radio_work_check_next(wpa_s);
 		break;
 #endif /* CONFIG_NO_SCAN_PROCESSING */
diff --git a/wpa_supplicant/main.c b/wpa_supplicant/main.c
index d5d47e1..1c93306 100644
--- a/wpa_supplicant/main.c
+++ b/wpa_supplicant/main.c
@@ -12,7 +12,6 @@
 #endif /* __linux__ */
 
 #include "common.h"
-#include "fst/fst.h"
 #include "wpa_supplicant_i.h"
 #include "driver_i.h"
 #include "p2p_supplicant.h"
@@ -310,17 +309,6 @@ int main(int argc, char *argv[])
 			   "wpa_supplicant");
 	}
 
-	if (fst_global_init()) {
-		wpa_printf(MSG_ERROR, "Failed to initialize FST");
-		exitcode = -1;
-		goto out;
-	}
-
-#if defined(CONFIG_FST) && defined(CONFIG_CTRL_IFACE)
-	if (!fst_global_add_ctrl(fst_ctrl_cli))
-		wpa_printf(MSG_WARNING, "Failed to add CLI FST ctrl");
-#endif
-
 	for (i = 0; exitcode == 0 && i < iface_count; i++) {
 		struct wpa_supplicant *wpa_s;
 
@@ -346,8 +334,6 @@ int main(int argc, char *argv[])
 
 	wpa_supplicant_deinit(global);
 
-	fst_global_deinit();
-
 out:
 	wpa_supplicant_fd_workaround(0);
 	os_free(ifaces);
diff --git a/wpa_supplicant/notify.c b/wpa_supplicant/notify.c
index aa8c214..822db74 100644
--- a/wpa_supplicant/notify.c
+++ b/wpa_supplicant/notify.c
@@ -17,7 +17,6 @@
 #include "dbus/dbus_old.h"
 #include "dbus/dbus_new.h"
 #include "rsn_supp/wpa.h"
-#include "fst/fst.h"
 #include "driver_i.h"
 #include "scan.h"
 #include "p2p_supplicant.h"
@@ -89,16 +88,6 @@ void wpas_notify_state_changed(struct wpa_supplicant *wpa_s,
 	/* notify the new DBus API */
 	wpas_dbus_signal_prop_changed(wpa_s, WPAS_DBUS_PROP_STATE);
 
-#ifdef CONFIG_FST
-	if (wpa_s->fst && !is_zero_ether_addr(wpa_s->bssid)) {
-		if (new_state == WPA_COMPLETED)
-			fst_notify_peer_connected(wpa_s->fst, wpa_s->bssid);
-		else if (old_state >= WPA_ASSOCIATED &&
-			 new_state < WPA_ASSOCIATED)
-			fst_notify_peer_disconnected(wpa_s->fst, wpa_s->bssid);
-	}
-#endif /* CONFIG_FST */
-
 	if (new_state == WPA_COMPLETED)
 		wpas_p2p_notif_connected(wpa_s);
 	else if (old_state >= WPA_ASSOCIATED && new_state < WPA_ASSOCIATED)
diff --git a/wpa_supplicant/p2p_supplicant.c b/wpa_supplicant/p2p_supplicant.c
index 27aa2f9..0f3717d 100644
--- a/wpa_supplicant/p2p_supplicant.c
+++ b/wpa_supplicant/p2p_supplicant.c
@@ -317,7 +317,6 @@ static int wpas_p2p_scan(void *ctx, enum p2p_scan_type type, int freq,
 	int social_channels_freq[] = { 2412, 2437, 2462, 60480 };
 	size_t ielen;
 	u8 *n, i;
-	unsigned int bands;
 
 	if (wpa_s->global->p2p_disabled || wpa_s->global->p2p == NULL)
 		return -1;
@@ -347,6 +346,28 @@ static int wpas_p2p_scan(void *ctx, enum p2p_scan_type type, int freq,
 	if (wps_ie == NULL)
 		goto fail;
 
+	ielen = p2p_scan_ie_buf_len(wpa_s->global->p2p);
+	ies = wpabuf_alloc(wpabuf_len(wps_ie) + ielen);
+	if (ies == NULL) {
+		wpabuf_free(wps_ie);
+		goto fail;
+	}
+	wpabuf_put_buf(ies, wps_ie);
+	wpabuf_free(wps_ie);
+
+	p2p_scan_ie(wpa_s->global->p2p, ies, dev_id);
+
+	params->p2p_probe = 1;
+	n = os_malloc(wpabuf_len(ies));
+	if (n == NULL) {
+		wpabuf_free(ies);
+		goto fail;
+	}
+	os_memcpy(n, wpabuf_head(ies), wpabuf_len(ies));
+	params->extra_ies = n;
+	params->extra_ies_len = wpabuf_len(ies);
+	wpabuf_free(ies);
+
 	switch (type) {
 	case P2P_SCAN_SOCIAL:
 		params->freqs = os_calloc(ARRAY_SIZE(social_channels_freq) + 1,
@@ -387,29 +408,6 @@ static int wpas_p2p_scan(void *ctx, enum p2p_scan_type type, int freq,
 		break;
 	}
 
-	ielen = p2p_scan_ie_buf_len(wpa_s->global->p2p);
-	ies = wpabuf_alloc(wpabuf_len(wps_ie) + ielen);
-	if (ies == NULL) {
-		wpabuf_free(wps_ie);
-		goto fail;
-	}
-	wpabuf_put_buf(ies, wps_ie);
-	wpabuf_free(wps_ie);
-
-	bands = wpas_get_bands(wpa_s, params->freqs);
-	p2p_scan_ie(wpa_s->global->p2p, ies, dev_id, bands);
-
-	params->p2p_probe = 1;
-	n = os_malloc(wpabuf_len(ies));
-	if (n == NULL) {
-		wpabuf_free(ies);
-		goto fail;
-	}
-	os_memcpy(n, wpabuf_head(ies), wpabuf_len(ies));
-	params->extra_ies = n;
-	params->extra_ies_len = wpabuf_len(ies);
-	wpabuf_free(ies);
-
 	radio_remove_works(wpa_s, "p2p-scan", 0);
 	if (radio_add_work(wpa_s, 0, "p2p-scan", 0, wpas_p2p_trigger_scan_cb,
 			   params) < 0)
@@ -756,8 +754,6 @@ grp_owner:
 
 		if (!s && !owner && p2p_no_group_iface) {
 			p2p_set_intended_addr(wpa_s->global->p2p,
-					      wpa_s->p2p_mgmt ?
-					      wpa_s->parent->own_addr :
 					      wpa_s->own_addr);
 		} else if (!s && !owner) {
 			if (wpas_p2p_add_group_interface(wpa_s,
@@ -831,7 +827,7 @@ static int wpas_p2p_group_delete(struct wpa_supplicant *wpa_s,
 
 	if (wpa_s->cross_connect_in_use) {
 		wpa_s->cross_connect_in_use = 0;
-		wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+		wpa_msg_global(wpa_s->parent, MSG_INFO,
 			       P2P_EVENT_CROSS_CONNECT_DISABLE "%s %s",
 			       wpa_s->ifname, wpa_s->cross_connect_uplink);
 	}
@@ -862,7 +858,7 @@ static int wpas_p2p_group_delete(struct wpa_supplicant *wpa_s,
 		break;
 	}
 	if (removal_reason != P2P_GROUP_REMOVAL_SILENT) {
-		wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+		wpa_msg_global(wpa_s->parent, MSG_INFO,
 			       P2P_EVENT_GROUP_REMOVED "%s %s%s",
 			       wpa_s->ifname, gtype, reason);
 	}
@@ -872,7 +868,7 @@ static int wpas_p2p_group_delete(struct wpa_supplicant *wpa_s,
 	if (eloop_cancel_timeout(wpas_p2p_group_idle_timeout, wpa_s, NULL) > 0)
 		wpa_printf(MSG_DEBUG, "P2P: Cancelled P2P group idle timeout");
 	if (eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-				 wpa_s->p2pdev, NULL) > 0) {
+				 wpa_s->parent, NULL) > 0) {
 		wpa_printf(MSG_DEBUG, "P2P: Cancelled P2P group formation "
 			   "timeout");
 		wpa_s->p2p_in_provisioning = 0;
@@ -904,16 +900,8 @@ static int wpas_p2p_group_delete(struct wpa_supplicant *wpa_s,
 		return 1;
 	}
 
-	/*
-	 * The primary interface was used for P2P group operations, so
-	 * need to reset its p2pdev.
-	 */
-	wpa_s->p2pdev = wpa_s->parent;
-
-	if (!wpa_s->p2p_go_group_formation_completed) {
-		wpa_s->global->p2p_group_formation = NULL;
-		wpa_s->p2p_in_provisioning = 0;
-	}
+	wpa_s->global->p2p_group_formation = NULL;
+	wpa_s->p2p_in_provisioning = 0;
 
 	wpa_s->show_group_started = 0;
 	os_free(wpa_s->go_params);
@@ -1083,8 +1071,7 @@ static int wpas_p2p_store_persistent_group(struct wpa_supplicant *wpa_s,
 	s->auth_alg = WPA_AUTH_ALG_OPEN;
 	s->key_mgmt = WPA_KEY_MGMT_PSK;
 	s->proto = WPA_PROTO_RSN;
-	s->pbss = ssid->pbss;
-	s->pairwise_cipher = ssid->pbss ? WPA_CIPHER_GCMP : WPA_CIPHER_CCMP;
+	s->pairwise_cipher = WPA_CIPHER_CCMP;
 	s->export_keys = 1;
 	if (ssid->passphrase) {
 		os_free(s->passphrase);
@@ -1224,7 +1211,7 @@ static void wpas_p2p_group_started(struct wpa_supplicant *wpa_s,
 	 * Include PSK/passphrase only in the control interface message and
 	 * leave it out from the debug log entry.
 	 */
-	wpa_msg_global_ctrl(wpa_s->p2pdev, MSG_INFO,
+	wpa_msg_global_ctrl(wpa_s->parent, MSG_INFO,
 			    P2P_EVENT_GROUP_STARTED
 			    "%s %s ssid=\"%s\" freq=%d%s%s%s%s%s go_dev_addr="
 			    MACSTR "%s%s",
@@ -1267,7 +1254,7 @@ static void wpas_group_formation_completed(struct wpa_supplicant *wpa_s,
 	wpa_s->group_formation_reported = 1;
 
 	if (!success) {
-		wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+		wpa_msg_global(wpa_s->parent, MSG_INFO,
 			       P2P_EVENT_GROUP_FORMATION_FAILURE);
 		if (already_deleted)
 			return;
@@ -1276,7 +1263,7 @@ static void wpas_group_formation_completed(struct wpa_supplicant *wpa_s,
 		return;
 	}
 
-	wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+	wpa_msg_global(wpa_s->parent, MSG_INFO,
 		       P2P_EVENT_GROUP_FORMATION_SUCCESS);
 
 	ssid = wpa_s->current_ssid;
@@ -1324,7 +1311,7 @@ static void wpas_group_formation_completed(struct wpa_supplicant *wpa_s,
 	}
 
 	if (persistent)
-		network_id = wpas_p2p_store_persistent_group(wpa_s->p2pdev,
+		network_id = wpas_p2p_store_persistent_group(wpa_s->parent,
 							     ssid, go_dev_addr);
 	else {
 		os_free(wpa_s->global->add_psk);
@@ -1429,7 +1416,7 @@ static void wpas_p2p_send_action_tx_status(struct wpa_supplicant *wpa_s,
 		wpa_s->pending_pd_before_join = 0;
 		wpa_dbg(wpa_s, MSG_DEBUG, "P2P: No ACK for PD Req "
 			"during p2p_connect-auto");
-		wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+		wpa_msg_global(wpa_s->parent, MSG_INFO,
 			       P2P_EVENT_FALLBACK_TO_GO_NEG
 			       "reason=no-ACK-to-PD-Req");
 		wpas_p2p_fallback_to_go_neg(wpa_s, 0);
@@ -1572,11 +1559,11 @@ static void wpas_start_wps_enrollee(struct wpa_supplicant *wpa_s,
 	} else if (res->wps_method == WPS_NFC) {
 		wpas_wps_start_nfc(wpa_s, res->peer_device_addr,
 				   res->peer_interface_addr,
-				   wpa_s->p2pdev->p2p_oob_dev_pw,
-				   wpa_s->p2pdev->p2p_oob_dev_pw_id, 1,
-				   wpa_s->p2pdev->p2p_oob_dev_pw_id ==
+				   wpa_s->parent->p2p_oob_dev_pw,
+				   wpa_s->parent->p2p_oob_dev_pw_id, 1,
+				   wpa_s->parent->p2p_oob_dev_pw_id ==
 				   DEV_PW_NFC_CONNECTION_HANDOVER ?
-				   wpa_s->p2pdev->p2p_peer_oob_pubkey_hash :
+				   wpa_s->parent->p2p_peer_oob_pubkey_hash :
 				   NULL,
 				   NULL, 0, 0);
 #endif /* CONFIG_WPS_NFC */
@@ -1602,7 +1589,7 @@ static void wpas_p2p_add_psk_list(struct wpa_supplicant *wpa_s,
 	if (!wpa_s->ap_iface)
 		return;
 
-	persistent = wpas_p2p_get_persistent(wpa_s->p2pdev, NULL, ssid->ssid,
+	persistent = wpas_p2p_get_persistent(wpa_s->parent, NULL, ssid->ssid,
 					     ssid->ssid_len);
 	if (persistent == NULL)
 		return;
@@ -1667,8 +1654,8 @@ static void p2p_go_save_group_common_freqs(struct wpa_supplicant *wpa_s,
 static void p2p_config_write(struct wpa_supplicant *wpa_s)
 {
 #ifndef CONFIG_NO_CONFIG_WRITE
-	if (wpa_s->p2pdev->conf->update_config &&
-	    wpa_config_write(wpa_s->p2pdev->confname, wpa_s->p2pdev->conf))
+	if (wpa_s->parent->conf->update_config &&
+	    wpa_config_write(wpa_s->parent->confname, wpa_s->parent->conf))
 		wpa_printf(MSG_DEBUG, "P2P: Failed to update configuration");
 #endif /* CONFIG_NO_CONFIG_WRITE */
 }
@@ -1697,20 +1684,20 @@ static void p2p_go_configured(void *ctx, void *data)
 				       params->persistent_group, "");
 		wpa_s->group_formation_reported = 1;
 
-		if (wpa_s->p2pdev->p2ps_join_addr_valid) {
+		if (wpa_s->parent->p2ps_join_addr_valid) {
 			wpa_dbg(wpa_s, MSG_DEBUG,
 				"P2PS: Setting default PIN for " MACSTR,
-				MAC2STR(wpa_s->p2pdev->p2ps_join_addr));
+				MAC2STR(wpa_s->parent->p2ps_join_addr));
 			wpa_supplicant_ap_wps_pin(wpa_s,
-						  wpa_s->p2pdev->p2ps_join_addr,
+						  wpa_s->parent->p2ps_join_addr,
 						  "12345670", NULL, 0, 0);
-			wpa_s->p2pdev->p2ps_join_addr_valid = 0;
+			wpa_s->parent->p2ps_join_addr_valid = 0;
 		}
 
 		os_get_reltime(&wpa_s->global->p2p_go_wait_client);
 		if (params->persistent_group) {
 			network_id = wpas_p2p_store_persistent_group(
-				wpa_s->p2pdev, ssid,
+				wpa_s->parent, ssid,
 				wpa_s->global->p2p_dev_addr);
 			wpas_p2p_add_psk_list(wpa_s, ssid);
 		}
@@ -1727,11 +1714,11 @@ static void p2p_go_configured(void *ctx, void *data)
 			wpa_s->p2p_go_group_formation_completed = 0;
 			wpa_s->global->p2p_group_formation = wpa_s;
 			eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-					     wpa_s->p2pdev, NULL);
+					     wpa_s->parent, NULL);
 			eloop_register_timeout(
 				wpa_s->p2p_first_connection_timeout, 0,
 				wpas_p2p_group_formation_timeout,
-				wpa_s->p2pdev, NULL);
+				wpa_s->parent, NULL);
 		}
 
 		return;
@@ -1749,17 +1736,17 @@ static void p2p_go_configured(void *ctx, void *data)
 					  params->peer_device_addr);
 #ifdef CONFIG_WPS_NFC
 	} else if (params->wps_method == WPS_NFC) {
-		if (wpa_s->p2pdev->p2p_oob_dev_pw_id !=
+		if (wpa_s->parent->p2p_oob_dev_pw_id !=
 		    DEV_PW_NFC_CONNECTION_HANDOVER &&
-		    !wpa_s->p2pdev->p2p_oob_dev_pw) {
+		    !wpa_s->parent->p2p_oob_dev_pw) {
 			wpa_printf(MSG_DEBUG, "P2P: No NFC Dev Pw known");
 			return;
 		}
 		wpas_ap_wps_add_nfc_pw(
-			wpa_s, wpa_s->p2pdev->p2p_oob_dev_pw_id,
-			wpa_s->p2pdev->p2p_oob_dev_pw,
-			wpa_s->p2pdev->p2p_peer_oob_pk_hash_known ?
-			wpa_s->p2pdev->p2p_peer_oob_pubkey_hash : NULL);
+			wpa_s, wpa_s->parent->p2p_oob_dev_pw_id,
+			wpa_s->parent->p2p_oob_dev_pw,
+			wpa_s->parent->p2p_peer_oob_pk_hash_known ?
+			wpa_s->parent->p2p_peer_oob_pubkey_hash : NULL);
 #endif /* CONFIG_WPS_NFC */
 	} else if (wpa_s->p2p_pin[0])
 		wpa_supplicant_ap_wps_pin(wpa_s, params->peer_interface_addr,
@@ -1801,8 +1788,6 @@ static void wpas_start_wps_go(struct wpa_supplicant *wpa_s,
 	ssid->frequency = params->freq;
 	ssid->ht40 = params->ht40;
 	ssid->vht = params->vht;
-	ssid->max_oper_chwidth = params->max_oper_chwidth;
-	ssid->vht_center_freq2 = params->vht_center_freq2;
 	ssid->ssid = os_zalloc(params->ssid_len + 1);
 	if (ssid->ssid) {
 		os_memcpy(ssid->ssid, params->ssid, params->ssid_len);
@@ -1820,8 +1805,6 @@ static void wpas_start_wps_go(struct wpa_supplicant *wpa_s,
 		 */
 		ssid->pairwise_cipher = WPA_CIPHER_GCMP;
 		ssid->group_cipher = WPA_CIPHER_GCMP;
-		/* P2P GO in 60 GHz is always a PCP (PBSS) */
-		ssid->pbss = 1;
 	}
 	if (os_strlen(params->passphrase) > 0) {
 		ssid->passphrase = os_strdup(params->passphrase);
@@ -1838,7 +1821,7 @@ static void wpas_start_wps_go(struct wpa_supplicant *wpa_s,
 		os_memcpy(ssid->psk, params->psk, sizeof(ssid->psk));
 	else if (ssid->passphrase)
 		wpa_config_update_psk(ssid);
-	ssid->ap_max_inactivity = wpa_s->p2pdev->conf->p2p_go_max_inactivity;
+	ssid->ap_max_inactivity = wpa_s->parent->conf->p2p_go_max_inactivity;
 
 	wpa_s->ap_configured_cb = p2p_go_configured;
 	wpa_s->ap_configured_cb_ctx = wpa_s;
@@ -1897,23 +1880,6 @@ static void wpas_p2p_clone_config(struct wpa_supplicant *dst,
 }
 
 
-static void wpas_p2p_clone_config_dh(struct wpa_supplicant *dst,
-				     const struct wpa_supplicant *src)
-{
-	struct wpa_config *d;
-	const struct wpa_config *s;
-
-	d = dst->conf;
-	s = src->conf;
-
-	if (s->wps_nfc_dh_privkey && s->wps_nfc_dh_pubkey &&
-	    !d->wps_nfc_dh_privkey && !d->wps_nfc_dh_pubkey) {
-		d->wps_nfc_dh_privkey = wpabuf_dup(s->wps_nfc_dh_privkey);
-		d->wps_nfc_dh_pubkey = wpabuf_dup(s->wps_nfc_dh_pubkey);
-	}
-}
-
-
 static void wpas_p2p_get_group_ifname(struct wpa_supplicant *wpa_s,
 				      char *ifname, size_t len)
 {
@@ -2064,7 +2030,7 @@ static void wpas_p2p_group_formation_failed(struct wpa_supplicant *wpa_s,
 					    int already_deleted)
 {
 	eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-			     wpa_s->p2pdev, NULL);
+			     wpa_s->parent, NULL);
 	if (wpa_s->global->p2p)
 		p2p_group_formation_failed(wpa_s->global->p2p);
 	wpas_group_formation_completed(wpa_s, 0, already_deleted);
@@ -2075,9 +2041,9 @@ static void wpas_p2p_grpform_fail_after_wps(struct wpa_supplicant *wpa_s)
 {
 	wpa_printf(MSG_DEBUG, "P2P: Reject group formation due to WPS provisioning failure");
 	eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-			     wpa_s->p2pdev, NULL);
+			     wpa_s->parent, NULL);
 	eloop_register_timeout(0, 0, wpas_p2p_group_formation_timeout,
-			       wpa_s->p2pdev, NULL);
+			       wpa_s->parent, NULL);
 	wpa_s->global->p2p_fail_on_wps_complete = 0;
 }
 
@@ -2088,16 +2054,15 @@ void wpas_p2p_ap_setup_failed(struct wpa_supplicant *wpa_s)
 		return;
 	/* Speed up group formation timeout since this cannot succeed */
 	eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-			     wpa_s->p2pdev, NULL);
+			     wpa_s->parent, NULL);
 	eloop_register_timeout(0, 0, wpas_p2p_group_formation_timeout,
-			       wpa_s->p2pdev, NULL);
+			       wpa_s->parent, NULL);
 }
 
 
 static void wpas_go_neg_completed(void *ctx, struct p2p_go_neg_results *res)
 {
 	struct wpa_supplicant *wpa_s = ctx;
-	struct wpa_supplicant *group_wpa_s;
 
 	if (wpa_s->off_channel_freq || wpa_s->roc_waiting_drv_freq) {
 		wpa_drv_cancel_remain_on_channel(wpa_s);
@@ -2114,17 +2079,10 @@ static void wpas_go_neg_completed(void *ctx, struct p2p_go_neg_results *res)
 		return;
 	}
 
-	if (!res->role_go) {
-		/* Inform driver of the operating channel of GO. */
-		wpa_drv_set_prob_oper_freq(wpa_s, res->freq);
-	}
-
 	if (wpa_s->p2p_go_ht40)
 		res->ht40 = 1;
 	if (wpa_s->p2p_go_vht)
 		res->vht = 1;
-	res->max_oper_chwidth = wpa_s->p2p_go_max_oper_chwidth;
-	res->vht_center_freq2 = wpa_s->p2p_go_vht_center_freq2;
 
 	wpa_msg_global(wpa_s, MSG_INFO, P2P_EVENT_GO_NEG_SUCCESS "role=%s "
 		       "freq=%d ht40=%d peer_dev=" MACSTR " peer_iface=" MACSTR
@@ -2150,7 +2108,7 @@ static void wpas_go_neg_completed(void *ctx, struct p2p_go_neg_results *res)
 	}
 
 	if (wpa_s->create_p2p_iface) {
-		group_wpa_s =
+		struct wpa_supplicant *group_wpa_s =
 			wpas_p2p_init_group_interface(wpa_s, res->role_go);
 		if (group_wpa_s == NULL) {
 			wpas_p2p_remove_pending_group_interface(wpa_s);
@@ -2159,27 +2117,27 @@ static void wpas_go_neg_completed(void *ctx, struct p2p_go_neg_results *res)
 			wpas_p2p_group_formation_failed(wpa_s, 1);
 			return;
 		}
+		if (group_wpa_s != wpa_s) {
+			os_memcpy(group_wpa_s->p2p_pin, wpa_s->p2p_pin,
+				  sizeof(group_wpa_s->p2p_pin));
+			group_wpa_s->p2p_wps_method = wpa_s->p2p_wps_method;
+		}
 		os_memset(wpa_s->pending_interface_addr, 0, ETH_ALEN);
 		wpa_s->pending_interface_name[0] = '\0';
-	} else {
-		group_wpa_s = wpa_s->parent;
-		wpa_s->global->p2p_group_formation = group_wpa_s;
-		if (group_wpa_s != wpa_s)
-			wpas_p2p_clone_config_dh(group_wpa_s, wpa_s);
-	}
+		group_wpa_s->p2p_in_provisioning = 1;
 
-	group_wpa_s->p2p_in_provisioning = 1;
-	group_wpa_s->p2pdev = wpa_s;
-	if (group_wpa_s != wpa_s) {
-		os_memcpy(group_wpa_s->p2p_pin, wpa_s->p2p_pin,
-			  sizeof(group_wpa_s->p2p_pin));
-		group_wpa_s->p2p_wps_method = wpa_s->p2p_wps_method;
-	}
-	if (res->role_go) {
-		wpas_start_wps_go(group_wpa_s, res, 1);
+		if (res->role_go)
+			wpas_start_wps_go(group_wpa_s, res, 1);
+		else
+			wpas_start_wps_enrollee(group_wpa_s, res);
 	} else {
-		os_get_reltime(&group_wpa_s->scan_min_time);
-		wpas_start_wps_enrollee(group_wpa_s, res);
+		wpa_s->p2p_in_provisioning = 1;
+		wpa_s->global->p2p_group_formation = wpa_s;
+
+		if (res->role_go)
+			wpas_start_wps_go(wpa_s, res, 1);
+		else
+			wpas_start_wps_enrollee(ctx, res);
 	}
 
 	wpa_s->p2p_long_listen = 0;
@@ -2581,7 +2539,7 @@ static void wpas_prov_disc_fail(void *ctx, const u8 *peer,
 	if (wpa_s->p2p_fallback_to_go_neg) {
 		wpa_dbg(wpa_s, MSG_DEBUG, "P2P: PD for p2p_connect-auto "
 			"failed - fall back to GO Negotiation");
-		wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+		wpa_msg_global(wpa_s->parent, MSG_INFO,
 			       P2P_EVENT_FALLBACK_TO_GO_NEG
 			       "reason=PD-failed");
 		wpas_p2p_fallback_to_go_neg(wpa_s, 0);
@@ -2753,11 +2711,7 @@ static u8 wpas_invitation_process(void *ctx, const u8 *sa, const u8 *bssid,
 				   "invitation");
 			return P2P_SC_FAIL_UNABLE_TO_ACCOMMODATE;
 		}
-		if (wpa_s->p2p_mgmt)
-			os_memcpy(group_bssid, wpa_s->parent->own_addr,
-				  ETH_ALEN);
-		else
-			os_memcpy(group_bssid, wpa_s->own_addr, ETH_ALEN);
+		os_memcpy(group_bssid, wpa_s->own_addr, ETH_ALEN);
 	} else if (s->mode == WPAS_MODE_P2P_GO) {
 		*go = 1;
 		if (wpas_p2p_add_group_interface(wpa_s, WPA_IF_P2P_GO) < 0)
@@ -2839,31 +2793,11 @@ static void wpas_invitation_received(void *ctx, const u8 *sa, const u8 *bssid,
 			   MAC2STR(sa), op_freq, wpa_ssid_txt(ssid, ssid_len));
 		if (s) {
 			int go = s->mode == WPAS_MODE_P2P_GO;
-			if (go) {
-				wpa_msg_global(wpa_s, MSG_INFO,
-					       P2P_EVENT_INVITATION_ACCEPTED
-					       "sa=" MACSTR
-					       " persistent=%d freq=%d",
-					       MAC2STR(sa), s->id, op_freq);
-			} else {
-				wpa_msg_global(wpa_s, MSG_INFO,
-					       P2P_EVENT_INVITATION_ACCEPTED
-					       "sa=" MACSTR
-					       " persistent=%d",
-					       MAC2STR(sa), s->id);
-			}
 			wpas_p2p_group_add_persistent(
-				wpa_s, s, go, 0, op_freq, 0, 0, 0, 0, NULL,
-				go ? P2P_MAX_INITIAL_CONN_WAIT_GO_REINVOKE : 0,
-				1);
+				wpa_s, s, go, 0, op_freq, 0, 0, NULL,
+				go ? P2P_MAX_INITIAL_CONN_WAIT_GO_REINVOKE : 0);
 		} else if (bssid) {
 			wpa_s->user_initiated_pd = 0;
-			wpa_msg_global(wpa_s, MSG_INFO,
-				       P2P_EVENT_INVITATION_ACCEPTED
-				       "sa=" MACSTR " go_dev_addr=" MACSTR
-				       " bssid=" MACSTR " unknown-network",
-				       MAC2STR(sa), MAC2STR(go_dev_addr),
-				       MAC2STR(bssid));
 			wpas_p2p_join(wpa_s, bssid, go_dev_addr,
 				      wpa_s->p2p_wps_method, 0, op_freq,
 				      ssid, ssid_len);
@@ -2960,7 +2894,7 @@ static void wpas_remove_persistent_client(struct wpa_supplicant *wpa_s,
 	if (ssid == NULL || ssid->mode != WPAS_MODE_P2P_GO ||
 	    !ssid->p2p_persistent_group)
 		return; /* Not operating as a GO in persistent group */
-	ssid = wpas_p2p_get_persistent(wpa_s->p2pdev, peer,
+	ssid = wpas_p2p_get_persistent(wpa_s->parent, peer,
 				       ssid->ssid, ssid->ssid_len);
 	wpas_remove_persistent_peer(wpa_s, ssid, peer, 1);
 }
@@ -3044,13 +2978,11 @@ static void wpas_invitation_result(void *ctx, int status, const u8 *bssid,
 				      ssid->mode == WPAS_MODE_P2P_GO,
 				      wpa_s->p2p_persistent_go_freq,
 				      freq,
-				      wpa_s->p2p_go_vht_center_freq2,
 				      wpa_s->p2p_go_ht40, wpa_s->p2p_go_vht,
-				      wpa_s->p2p_go_max_oper_chwidth,
 				      channels,
 				      ssid->mode == WPAS_MODE_P2P_GO ?
 				      P2P_MAX_INITIAL_CONN_WAIT_GO_REINVOKE :
-				      0, 1);
+				      0);
 }
 
 
@@ -3186,7 +3118,7 @@ struct p2p_oper_class_map {
 	u8 min_chan;
 	u8 max_chan;
 	u8 inc;
-	enum { BW20, BW40PLUS, BW40MINUS, BW80, BW2160, BW160, BW80P80 } bw;
+	enum { BW20, BW40PLUS, BW40MINUS, BW80, BW2160 } bw;
 };
 
 static const struct p2p_oper_class_map op_class[] = {
@@ -3212,8 +3144,6 @@ static const struct p2p_oper_class_map op_class[] = {
 	 * removing invalid channels.
 	 */
 	{ HOSTAPD_MODE_IEEE80211A, 128, 36, 161, 4, BW80 },
-	{ HOSTAPD_MODE_IEEE80211A, 130, 36, 161, 4, BW80P80 },
-	{ HOSTAPD_MODE_IEEE80211A, 129, 50, 114, 16, BW160 },
 	{ HOSTAPD_MODE_IEEE80211AD, 180, 1, 4, 1, BW2160 },
 	{ -1, 0, 0, 0, 0, BW20 }
 };
@@ -3280,75 +3210,6 @@ static enum chan_allowed wpas_p2p_verify_80mhz(struct wpa_supplicant *wpa_s,
 }
 
 
-static int wpas_p2p_get_center_160mhz(struct wpa_supplicant *wpa_s,
-				     struct hostapd_hw_modes *mode,
-				     u8 channel)
-{
-	u8 center_channels[] = { 50, 114 };
-	unsigned int i;
-
-	if (mode->mode != HOSTAPD_MODE_IEEE80211A)
-		return 0;
-
-	for (i = 0; i < ARRAY_SIZE(center_channels); i++)
-		/*
-		 * In 160 MHz, the bandwidth "spans" 28 channels (e.g., 36-64),
-		 * so the center channel is 14 channels away from the start/end.
-		 */
-		if (channel >= center_channels[i] - 14 &&
-		    channel <= center_channels[i] + 14)
-			return center_channels[i];
-
-	return 0;
-}
-
-
-static enum chan_allowed wpas_p2p_verify_160mhz(struct wpa_supplicant *wpa_s,
-					       struct hostapd_hw_modes *mode,
-					       u8 channel, u8 bw)
-{
-	u8 center_chan;
-	int i, flags;
-	enum chan_allowed res, ret = ALLOWED;
-
-	center_chan = wpas_p2p_get_center_160mhz(wpa_s, mode, channel);
-	if (!center_chan)
-		return NOT_ALLOWED;
-	/* VHT 160 MHz uses DFS channels in most countries. */
-
-	/* Check all the channels are available */
-	for (i = 0; i < 8; i++) {
-		int adj_chan = center_chan - 14 + i * 4;
-
-		res = has_channel(wpa_s->global, mode, adj_chan, &flags);
-		if (res == NOT_ALLOWED)
-			return NOT_ALLOWED;
-
-		if (res == NO_IR)
-			ret = NO_IR;
-
-		if (i == 0 && !(flags & HOSTAPD_CHAN_VHT_10_150))
-			return NOT_ALLOWED;
-		if (i == 1 && !(flags & HOSTAPD_CHAN_VHT_30_130))
-			return NOT_ALLOWED;
-		if (i == 2 && !(flags & HOSTAPD_CHAN_VHT_50_110))
-			return NOT_ALLOWED;
-		if (i == 3 && !(flags & HOSTAPD_CHAN_VHT_70_90))
-			return NOT_ALLOWED;
-		if (i == 4 && !(flags & HOSTAPD_CHAN_VHT_90_70))
-			return NOT_ALLOWED;
-		if (i == 5 && !(flags & HOSTAPD_CHAN_VHT_110_50))
-			return NOT_ALLOWED;
-		if (i == 6 && !(flags & HOSTAPD_CHAN_VHT_130_30))
-			return NOT_ALLOWED;
-		if (i == 7 && !(flags & HOSTAPD_CHAN_VHT_150_10))
-			return NOT_ALLOWED;
-	}
-
-	return ret;
-}
-
-
 static enum chan_allowed wpas_p2p_verify_channel(struct wpa_supplicant *wpa_s,
 						 struct hostapd_hw_modes *mode,
 						 u8 channel, u8 bw)
@@ -3367,8 +3228,6 @@ static enum chan_allowed wpas_p2p_verify_channel(struct wpa_supplicant *wpa_s,
 		res2 = has_channel(wpa_s->global, mode, channel + 4, NULL);
 	} else if (bw == BW80) {
 		res2 = wpas_p2p_verify_80mhz(wpa_s, mode, channel, bw);
-	} else if (bw == BW160) {
-		res2 = wpas_p2p_verify_160mhz(wpa_s, mode, channel, bw);
 	}
 
 	if (res == NOT_ALLOWED || res2 == NOT_ALLOWED)
@@ -3482,15 +3341,6 @@ int wpas_p2p_get_vht80_center(struct wpa_supplicant *wpa_s,
 }
 
 
-int wpas_p2p_get_vht160_center(struct wpa_supplicant *wpa_s,
-			       struct hostapd_hw_modes *mode, u8 channel)
-{
-	if (!wpas_p2p_verify_channel(wpa_s, mode, channel, BW160))
-		return 0;
-	return wpas_p2p_get_center_160mhz(wpa_s, mode, channel);
-}
-
-
 static int wpas_get_noa(void *ctx, const u8 *interface_addr, u8 *buf,
 			size_t buf_len)
 {
@@ -3627,7 +3477,6 @@ int wpas_p2p_add_p2pdev_interface(struct wpa_supplicant *wpa_s,
 		return -1;
 	}
 
-	p2pdev_wpa_s->p2pdev = p2pdev_wpa_s;
 	wpa_s->pending_interface_name[0] = '\0';
 	return 0;
 }
@@ -3909,13 +3758,13 @@ static void wpas_p2ps_prov_complete(void *ctx, u8 status, const u8 *dev,
 			if (response_done && persistent_go) {
 				wpas_p2p_group_add_persistent(
 					wpa_s, persistent_go,
-					0, 0, 0, 0, 0, 0, 0, NULL,
+					0, 0, 0, 0, 0, NULL,
 					persistent_go->mode ==
 					WPAS_MODE_P2P_GO ?
 					P2P_MAX_INITIAL_CONN_WAIT_GO_REINVOKE :
-					0, 0);
+					0);
 			} else if (response_done) {
-				wpas_p2p_group_add(wpa_s, 1, 0, 0, 0, 0, 0);
+				wpas_p2p_group_add(wpa_s, 1, 0, 0, 0);
 			}
 
 			if (passwd_id == DEV_PW_P2PS_DEFAULT) {
@@ -4009,28 +3858,17 @@ static int wpas_prov_disc_resp_cb(void *ctx)
 
 	if (persistent_go) {
 		wpas_p2p_group_add_persistent(
-			wpa_s, persistent_go, 0, 0, 0, 0, 0, 0, 0, NULL,
+			wpa_s, persistent_go, 0, 0, 0, 0, 0, NULL,
 			persistent_go->mode == WPAS_MODE_P2P_GO ?
-			P2P_MAX_INITIAL_CONN_WAIT_GO_REINVOKE : 0, 0);
+			P2P_MAX_INITIAL_CONN_WAIT_GO_REINVOKE : 0);
 	} else {
-		wpas_p2p_group_add(wpa_s, 1, 0, 0, 0, 0, 0);
+		wpas_p2p_group_add(wpa_s, 1, 0, 0, 0);
 	}
 
 	return 1;
 }
 
 
-static int wpas_p2p_get_pref_freq_list(void *ctx, int go,
-				       unsigned int *len,
-				       unsigned int *freq_list)
-{
-	struct wpa_supplicant *wpa_s = ctx;
-
-	return wpa_drv_get_pref_freq_list(wpa_s, go ? WPA_IF_P2P_GO :
-					  WPA_IF_P2P_CLIENT, len, freq_list);
-}
-
-
 /**
  * wpas_p2p_init - Initialize P2P module for %wpa_supplicant
  * @global: Pointer to global data from wpa_supplicant_init()
@@ -4084,7 +3922,6 @@ int wpas_p2p_init(struct wpa_global *global, struct wpa_supplicant *wpa_s)
 	p2p.p2ps_prov_complete = wpas_p2ps_prov_complete;
 	p2p.prov_disc_resp_cb = wpas_prov_disc_resp_cb;
 	p2p.p2ps_group_capability = p2ps_group_capability;
-	p2p.get_pref_freq_list = wpas_p2p_get_pref_freq_list;
 
 	os_memcpy(wpa_s->global->p2p_dev_addr, wpa_s->own_addr, ETH_ALEN);
 	os_memcpy(p2p.dev_addr, wpa_s->global->p2p_dev_addr, ETH_ALEN);
@@ -4305,7 +4142,8 @@ static void wpas_p2p_deinit_global(struct wpa_global *global)
 
 static int wpas_p2p_create_iface(struct wpa_supplicant *wpa_s)
 {
-	if (wpa_s->conf->p2p_no_group_iface)
+	if (!(wpa_s->drv_flags & WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE) &&
+	    wpa_s->conf->p2p_no_group_iface)
 		return 0; /* separate interface disabled per configuration */
 	if (wpa_s->drv_flags &
 	    (WPA_DRIVER_FLAGS_P2P_DEDICATED_INTERFACE |
@@ -4386,7 +4224,7 @@ static void wpas_p2p_check_join_scan_limit(struct wpa_supplicant *wpa_s)
 				       MAC2STR(wpa_s->pending_join_dev_addr));
 			return;
 		}
-		wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+		wpa_msg_global(wpa_s->parent, MSG_INFO,
 			       P2P_EVENT_GROUP_FORMATION_FAILURE);
 	}
 }
@@ -4521,7 +4359,7 @@ static void wpas_p2p_scan_res_join(struct wpa_supplicant *wpa_s,
 		if (join < 0) {
 			wpa_printf(MSG_DEBUG, "P2P: Peer was not found to be "
 				   "running a GO -> use GO Negotiation");
-			wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+			wpa_msg_global(wpa_s->parent, MSG_INFO,
 				       P2P_EVENT_FALLBACK_TO_GO_NEG
 				       "reason=peer-not-running-GO");
 			wpas_p2p_connect(wpa_s, wpa_s->pending_join_dev_addr,
@@ -4529,12 +4367,10 @@ static void wpas_p2p_scan_res_join(struct wpa_supplicant *wpa_s,
 					 wpa_s->p2p_persistent_group, 0, 0, 0,
 					 wpa_s->p2p_go_intent,
 					 wpa_s->p2p_connect_freq,
-					 wpa_s->p2p_go_vht_center_freq2,
 					 wpa_s->p2p_persistent_id,
 					 wpa_s->p2p_pd_before_go_neg,
 					 wpa_s->p2p_go_ht40,
-					 wpa_s->p2p_go_vht,
-					 wpa_s->p2p_go_max_oper_chwidth);
+					 wpa_s->p2p_go_vht);
 			return;
 		}
 
@@ -4542,7 +4378,7 @@ static void wpas_p2p_scan_res_join(struct wpa_supplicant *wpa_s,
 			   "try to join the group", join ? "" :
 			   " in older scan");
 		if (!join) {
-			wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+			wpa_msg_global(wpa_s->parent, MSG_INFO,
 				       P2P_EVENT_FALLBACK_TO_GO_NEG_ENABLED);
 			wpa_s->p2p_fallback_to_go_neg = 1;
 		}
@@ -4612,7 +4448,7 @@ static void wpas_p2p_scan_res_join(struct wpa_supplicant *wpa_s,
 		u16 method;
 
 		if (wpas_check_freq_conflict(wpa_s, freq) > 0) {
-			wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+			wpa_msg_global(wpa_s->parent, MSG_INFO,
 				       P2P_EVENT_GROUP_FORMATION_FAILURE
 				       "reason=FREQ_CONFLICT");
 			return;
@@ -4687,7 +4523,6 @@ static void wpas_p2p_join_scan_req(struct wpa_supplicant *wpa_s, int freq,
 	struct wpabuf *wps_ie, *ies;
 	size_t ielen;
 	int freqs[2] = { 0, 0 };
-	unsigned int bands;
 
 	os_memset(&params, 0, sizeof(params));
 
@@ -4713,6 +4548,22 @@ static void wpas_p2p_join_scan_req(struct wpa_supplicant *wpa_s, int freq,
 		return;
 	}
 
+	ielen = p2p_scan_ie_buf_len(wpa_s->global->p2p);
+	ies = wpabuf_alloc(wpabuf_len(wps_ie) + ielen);
+	if (ies == NULL) {
+		wpabuf_free(wps_ie);
+		wpas_p2p_scan_res_join(wpa_s, NULL);
+		return;
+	}
+	wpabuf_put_buf(ies, wps_ie);
+	wpabuf_free(wps_ie);
+
+	p2p_scan_ie(wpa_s->global->p2p, ies, NULL);
+
+	params.p2p_probe = 1;
+	params.extra_ies = wpabuf_head(ies);
+	params.extra_ies_len = wpabuf_len(ies);
+
 	if (!freq) {
 		int oper_freq;
 		/*
@@ -4729,23 +4580,6 @@ static void wpas_p2p_join_scan_req(struct wpa_supplicant *wpa_s, int freq,
 		params.freqs = freqs;
 	}
 
-	ielen = p2p_scan_ie_buf_len(wpa_s->global->p2p);
-	ies = wpabuf_alloc(wpabuf_len(wps_ie) + ielen);
-	if (ies == NULL) {
-		wpabuf_free(wps_ie);
-		wpas_p2p_scan_res_join(wpa_s, NULL);
-		return;
-	}
-	wpabuf_put_buf(ies, wps_ie);
-	wpabuf_free(wps_ie);
-
-	bands = wpas_get_bands(wpa_s, freqs);
-	p2p_scan_ie(wpa_s->global->p2p, ies, NULL, bands);
-
-	params.p2p_probe = 1;
-	params.extra_ies = wpabuf_head(ies);
-	params.extra_ies_len = wpabuf_len(ies);
-
 	/*
 	 * Run a scan to update BSS table and start Provision Discovery once
 	 * the new scan results become available.
@@ -4878,16 +4712,11 @@ static int wpas_p2p_join_start(struct wpa_supplicant *wpa_s, int freq,
 
 
 static int wpas_p2p_setup_freqs(struct wpa_supplicant *wpa_s, int freq,
-				int *force_freq, int *pref_freq, int go,
-				unsigned int *pref_freq_list,
-				unsigned int *num_pref_freq)
+				int *force_freq, int *pref_freq, int go)
 {
 	struct wpa_used_freq_data *freqs;
 	int res, best_freq, num_unused;
-	unsigned int freq_in_use = 0, num, i, max_pref_freq;
-
-	max_pref_freq = *num_pref_freq;
-	*num_pref_freq = 0;
+	unsigned int freq_in_use = 0, num, i;
 
 	freqs = os_calloc(wpa_s->num_multichan_concurrent,
 			  sizeof(struct wpa_used_freq_data));
@@ -4952,47 +4781,6 @@ static int wpas_p2p_setup_freqs(struct wpa_supplicant *wpa_s, int freq,
 
 	best_freq = wpas_p2p_pick_best_used_freq(wpa_s, freqs, num);
 
-	if (!wpa_s->conf->num_p2p_pref_chan && *pref_freq == 0) {
-		enum wpa_driver_if_type iface_type;
-
-		if (go)
-			iface_type = WPA_IF_P2P_GO;
-		else
-			iface_type = WPA_IF_P2P_CLIENT;
-
-		wpa_printf(MSG_DEBUG, "P2P: best_freq=%d, go=%d",
-			   best_freq, go);
-
-		res = wpa_drv_get_pref_freq_list(wpa_s, iface_type,
-						 &max_pref_freq,
-						 pref_freq_list);
-		if (!res && max_pref_freq > 0) {
-			*num_pref_freq = max_pref_freq;
-			i = 0;
-			while (wpas_p2p_disallowed_freq(wpa_s->global,
-							pref_freq_list[i]) &&
-			       i < *num_pref_freq) {
-				wpa_printf(MSG_DEBUG,
-					   "P2P: preferred_freq_list[%d]=%d is disallowed",
-					   i, pref_freq_list[i]);
-				i++;
-			}
-			if (i != *num_pref_freq) {
-				best_freq = pref_freq_list[i];
-				wpa_printf(MSG_DEBUG,
-					   "P2P: Using preferred_freq_list[%d]=%d",
-					   i, best_freq);
-			} else {
-				wpa_printf(MSG_DEBUG,
-					   "P2P: All driver preferred frequencies are disallowed for P2P use");
-				*num_pref_freq = 0;
-			}
-		} else {
-			wpa_printf(MSG_DEBUG,
-				   "P2P: No preferred frequency list available");
-		}
-	}
-
 	/* We have a candidate frequency to use */
 	if (best_freq > 0) {
 		if (*pref_freq == 0 && num_unused > 0) {
@@ -5036,15 +4824,12 @@ exit_free:
  *	initiating Group Owner negotiation
  * @go_intent: GO Intent or -1 to use default
  * @freq: Frequency for the group or 0 for auto-selection
- * @freq2: Center frequency of segment 1 for the GO operating in VHT 80P80 mode
  * @persistent_id: Persistent group credentials to use for forcing GO
  *	parameters or -1 to generate new values (SSID/passphrase)
  * @pd: Whether to send Provision Discovery prior to GO Negotiation as an
  *	interoperability workaround when initiating group formation
  * @ht40: Start GO with 40 MHz channel width
  * @vht:  Start GO with VHT support
- * @vht_chwidth: Channel width supported by GO operating with VHT support
- *	(VHT_CHANWIDTH_*).
  * Returns: 0 or new PIN (if pin was %NULL) on success, -1 on unspecified
  *	failure, -2 on failure due to channel not currently available,
  *	-3 if forced channel is not supported
@@ -5052,16 +4837,14 @@ exit_free:
 int wpas_p2p_connect(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 		     const char *pin, enum p2p_wps_method wps_method,
 		     int persistent_group, int auto_join, int join, int auth,
-		     int go_intent, int freq, unsigned int vht_center_freq2,
-		     int persistent_id, int pd, int ht40, int vht,
-		     unsigned int vht_chwidth)
+		     int go_intent, int freq, int persistent_id, int pd,
+		     int ht40, int vht)
 {
 	int force_freq = 0, pref_freq = 0;
 	int ret = 0, res;
 	enum wpa_driver_if_type iftype;
 	const u8 *if_addr;
 	struct wpa_ssid *ssid = NULL;
-	unsigned int pref_freq_list[P2P_MAX_PREF_CHANNELS], size;
 
 	if (wpa_s->global->p2p_disabled || wpa_s->global->p2p == NULL)
 		return -1;
@@ -5094,8 +4877,6 @@ int wpas_p2p_connect(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 	wpa_s->p2p_pd_before_go_neg = !!pd;
 	wpa_s->p2p_go_ht40 = !!ht40;
 	wpa_s->p2p_go_vht = !!vht;
-	wpa_s->p2p_go_vht_center_freq2 = vht_center_freq2;
-	wpa_s->p2p_go_max_oper_chwidth = vht_chwidth;
 
 	if (pin)
 		os_strlcpy(wpa_s->p2p_pin, pin, sizeof(wpa_s->p2p_pin));
@@ -5140,16 +4921,13 @@ int wpas_p2p_connect(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 		return ret;
 	}
 
-	size = P2P_MAX_PREF_CHANNELS;
 	res = wpas_p2p_setup_freqs(wpa_s, freq, &force_freq, &pref_freq,
-				   go_intent == 15, pref_freq_list, &size);
+				   go_intent == 15);
 	if (res)
 		return res;
 	wpas_p2p_set_own_freq_preference(wpa_s,
 					 force_freq ? force_freq : pref_freq);
 
-	p2p_set_own_pref_freq_list(wpa_s->global->p2p, pref_freq_list, size);
-
 	wpa_s->create_p2p_iface = wpas_p2p_create_iface(wpa_s);
 
 	if (wpa_s->create_p2p_iface) {
@@ -5164,12 +4942,8 @@ int wpas_p2p_connect(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 		}
 
 		if_addr = wpa_s->pending_interface_addr;
-	} else {
-		if (wpa_s->p2p_mgmt)
-			if_addr = wpa_s->parent->own_addr;
-		else
-			if_addr = wpa_s->own_addr;
-	}
+	} else
+		if_addr = wpa_s->own_addr;
 
 	if (auth) {
 		if (wpas_p2p_auth_go_neg(wpa_s, peer_addr, wps_method,
@@ -5314,38 +5088,6 @@ static int wpas_p2p_select_go_freq(struct wpa_supplicant *wpa_s, int freq)
 {
 	unsigned int r;
 
-	if (!wpa_s->conf->num_p2p_pref_chan && !freq) {
-		unsigned int i, size = P2P_MAX_PREF_CHANNELS;
-		unsigned int pref_freq_list[P2P_MAX_PREF_CHANNELS];
-		int res;
-
-		res = wpa_drv_get_pref_freq_list(wpa_s, WPA_IF_P2P_GO,
-						 &size, pref_freq_list);
-		if (!res && size > 0) {
-			i = 0;
-			while (wpas_p2p_disallowed_freq(wpa_s->global,
-							pref_freq_list[i]) &&
-			       i < size) {
-				wpa_printf(MSG_DEBUG,
-					   "P2P: preferred_freq_list[%d]=%d is disallowed",
-					   i, pref_freq_list[i]);
-				i++;
-			}
-			if (i != size) {
-				freq = pref_freq_list[i];
-				wpa_printf(MSG_DEBUG,
-					   "P2P: Using preferred_freq_list[%d]=%d",
-					   i, freq);
-			} else {
-				wpa_printf(MSG_DEBUG,
-					   "P2P: All driver preferred frequencies are disallowed for P2P use");
-			}
-		} else {
-			wpa_printf(MSG_DEBUG,
-				   "P2P: No preferred frequency list available");
-		}
-	}
-
 	if (freq == 2) {
 		wpa_printf(MSG_DEBUG, "P2P: Request to start GO on 2.4 GHz "
 			   "band");
@@ -5481,8 +5223,7 @@ out:
 
 static int wpas_p2p_init_go_params(struct wpa_supplicant *wpa_s,
 				   struct p2p_go_neg_results *params,
-				   int freq, int vht_center_freq2, int ht40,
-				   int vht, int max_oper_chwidth,
+				   int freq, int ht40, int vht,
 				   const struct p2p_channels *channels)
 {
 	struct wpa_used_freq_data *freqs;
@@ -5493,8 +5234,6 @@ static int wpas_p2p_init_go_params(struct wpa_supplicant *wpa_s,
 	params->role_go = 1;
 	params->ht40 = ht40;
 	params->vht = vht;
-	params->max_oper_chwidth = max_oper_chwidth;
-	params->vht_center_freq2 = vht_center_freq2;
 	if (freq) {
 		if (!freq_included(channels, freq)) {
 			wpa_printf(MSG_DEBUG, "P2P: Forced GO freq %d MHz not "
@@ -5622,20 +5361,9 @@ wpas_p2p_get_group_iface(struct wpa_supplicant *wpa_s, int addr_allocated,
 	struct wpa_supplicant *group_wpa_s;
 
 	if (!wpas_p2p_create_iface(wpa_s)) {
-		if (wpa_s->p2p_mgmt) {
-			/*
-			 * We may be called on the p2p_dev interface which
-			 * cannot be used for group operations, so always use
-			 * the primary interface.
-			 */
-			wpa_s->parent->p2pdev = wpa_s;
-			wpa_s = wpa_s->parent;
-		}
-		wpa_dbg(wpa_s, MSG_DEBUG,
-			"P2P: Use primary interface for group operations");
+		wpa_dbg(wpa_s, MSG_DEBUG, "P2P: Use same interface for group "
+			"operations");
 		wpa_s->p2p_first_connection_timeout = 0;
-		if (wpa_s != wpa_s->p2pdev)
-			wpas_p2p_clone_config_dh(wpa_s, wpa_s->p2pdev);
 		return wpa_s;
 	}
 
@@ -5665,18 +5393,15 @@ wpas_p2p_get_group_iface(struct wpa_supplicant *wpa_s, int addr_allocated,
  * @wpa_s: Pointer to wpa_supplicant data from wpa_supplicant_add_iface()
  * @persistent_group: Whether to create a persistent group
  * @freq: Frequency for the group or 0 to indicate no hardcoding
- * @vht_center_freq2: segment_1 center frequency for GO operating in VHT 80P80
  * @ht40: Start GO with 40 MHz channel width
  * @vht:  Start GO with VHT support
- * @vht_chwidth: channel bandwidth for GO operating with VHT support
  * Returns: 0 on success, -1 on failure
  *
  * This function creates a new P2P group with the local end as the Group Owner,
  * i.e., without using Group Owner Negotiation.
  */
 int wpas_p2p_group_add(struct wpa_supplicant *wpa_s, int persistent_group,
-		       int freq, int vht_center_freq2, int ht40, int vht,
-		       int max_oper_chwidth)
+		       int freq, int ht40, int vht)
 {
 	struct p2p_go_neg_results params;
 
@@ -5694,8 +5419,7 @@ int wpas_p2p_group_add(struct wpa_supplicant *wpa_s, int persistent_group,
 	if (freq < 0)
 		return -1;
 
-	if (wpas_p2p_init_go_params(wpa_s, &params, freq, vht_center_freq2,
-				    ht40, vht, max_oper_chwidth, NULL))
+	if (wpas_p2p_init_go_params(wpa_s, &params, freq, ht40, vht, NULL))
 		return -1;
 	if (params.freq &&
 	    !p2p_supported_freq_go(wpa_s->global->p2p, params.freq)) {
@@ -5729,15 +5453,13 @@ int wpas_p2p_group_add(struct wpa_supplicant *wpa_s, int persistent_group,
 
 static int wpas_start_p2p_client(struct wpa_supplicant *wpa_s,
 				 struct wpa_ssid *params, int addr_allocated,
-				 int freq, int force_scan)
+				 int freq)
 {
 	struct wpa_ssid *ssid;
 
 	wpa_s = wpas_p2p_get_group_iface(wpa_s, addr_allocated, 0);
 	if (wpa_s == NULL)
 		return -1;
-	if (force_scan)
-		os_get_reltime(&wpa_s->scan_min_time);
 	wpa_s->p2p_last_4way_hs_fail = NULL;
 
 	wpa_supplicant_ap_deinit(wpa_s);
@@ -5748,10 +5470,8 @@ static int wpas_start_p2p_client(struct wpa_supplicant *wpa_s,
 	wpa_config_set_network_defaults(ssid);
 	ssid->temporary = 1;
 	ssid->proto = WPA_PROTO_RSN;
-	ssid->pbss = params->pbss;
-	ssid->pairwise_cipher = params->pbss ? WPA_CIPHER_GCMP :
-		WPA_CIPHER_CCMP;
-	ssid->group_cipher = params->pbss ? WPA_CIPHER_GCMP : WPA_CIPHER_CCMP;
+	ssid->pairwise_cipher = WPA_CIPHER_CCMP;
+	ssid->group_cipher = WPA_CIPHER_CCMP;
 	ssid->key_mgmt = WPA_KEY_MGMT_PSK;
 	ssid->ssid = os_malloc(params->ssid_len);
 	if (ssid->ssid == NULL) {
@@ -5772,14 +5492,12 @@ static int wpas_start_p2p_client(struct wpa_supplicant *wpa_s,
 	wpa_s->show_group_started = 1;
 	wpa_s->p2p_in_invitation = 1;
 	wpa_s->p2p_invite_go_freq = freq;
-	wpa_s->p2p_go_group_formation_completed = 0;
-	wpa_s->global->p2p_group_formation = wpa_s;
 
-	eloop_cancel_timeout(wpas_p2p_group_formation_timeout, wpa_s->p2pdev,
+	eloop_cancel_timeout(wpas_p2p_group_formation_timeout, wpa_s->parent,
 			     NULL);
 	eloop_register_timeout(P2P_MAX_INITIAL_CONN_WAIT, 0,
 			       wpas_p2p_group_formation_timeout,
-			       wpa_s->p2pdev, NULL);
+			       wpa_s->parent, NULL);
 	wpa_supplicant_select_network(wpa_s, ssid);
 
 	return 0;
@@ -5788,11 +5506,9 @@ static int wpas_start_p2p_client(struct wpa_supplicant *wpa_s,
 
 int wpas_p2p_group_add_persistent(struct wpa_supplicant *wpa_s,
 				  struct wpa_ssid *ssid, int addr_allocated,
-				  int force_freq, int neg_freq,
-				  int vht_center_freq2, int ht40,
-				  int vht, int max_oper_chwidth,
-				  const struct p2p_channels *channels,
-				  int connection_timeout, int force_scan)
+				  int force_freq, int neg_freq, int ht40,
+				  int vht, const struct p2p_channels *channels,
+				  int connection_timeout)
 {
 	struct p2p_go_neg_results params;
 	int go = 0, freq;
@@ -5806,7 +5522,7 @@ int wpas_p2p_group_add_persistent(struct wpa_supplicant *wpa_s,
 			   "already running");
 		if (go == 0 &&
 		    eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-					 wpa_s->p2pdev, NULL)) {
+					 wpa_s->parent, NULL)) {
 			/*
 			 * This can happen if Invitation Response frame was lost
 			 * and the peer (GO of a persistent group) tries to
@@ -5819,7 +5535,7 @@ int wpas_p2p_group_add_persistent(struct wpa_supplicant *wpa_s,
 				   "P2P: Reschedule group formation timeout since peer is still trying to invite us");
 			eloop_register_timeout(P2P_MAX_INITIAL_CONN_WAIT, 0,
 					       wpas_p2p_group_formation_timeout,
-					       wpa_s->p2pdev, NULL);
+					       wpa_s->parent, NULL);
 		}
 		return 0;
 	}
@@ -5859,14 +5575,12 @@ int wpas_p2p_group_add_persistent(struct wpa_supplicant *wpa_s,
 				freq = 0;
 		}
 
-		return wpas_start_p2p_client(wpa_s, ssid, addr_allocated, freq,
-					     force_scan);
+		return wpas_start_p2p_client(wpa_s, ssid, addr_allocated, freq);
 	} else {
 		return -1;
 	}
 
-	if (wpas_p2p_init_go_params(wpa_s, &params, freq, vht_center_freq2,
-				    ht40, vht, max_oper_chwidth, channels))
+	if (wpas_p2p_init_go_params(wpa_s, &params, freq, ht40, vht, channels))
 		return -1;
 
 	params.role_go = 1;
@@ -6002,7 +5716,7 @@ void wpas_p2p_wps_success(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 		p2p_clear_provisioning_info(wpa_s->global->p2p, go_dev_addr);
 	}
 
-	eloop_cancel_timeout(wpas_p2p_group_formation_timeout, wpa_s->p2pdev,
+	eloop_cancel_timeout(wpas_p2p_group_formation_timeout, wpa_s->parent,
 			     NULL);
 	wpa_s->p2p_go_group_formation_completed = 1;
 	if (ssid && ssid->mode == WPAS_MODE_INFRA) {
@@ -6017,7 +5731,7 @@ void wpas_p2p_wps_success(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 			P2P_MAX_INITIAL_CONN_WAIT);
 		eloop_register_timeout(P2P_MAX_INITIAL_CONN_WAIT, 0,
 				       wpas_p2p_group_formation_timeout,
-				       wpa_s->p2pdev, NULL);
+				       wpa_s->parent, NULL);
 	} else if (ssid) {
 		/*
 		 * Use a separate timeout for initial data connection to
@@ -6029,7 +5743,7 @@ void wpas_p2p_wps_success(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 			P2P_MAX_INITIAL_CONN_WAIT_GO);
 		eloop_register_timeout(P2P_MAX_INITIAL_CONN_WAIT_GO, 0,
 				       wpas_p2p_group_formation_timeout,
-				       wpa_s->p2pdev, NULL);
+				       wpa_s->parent, NULL);
 		/*
 		 * Complete group formation on first successful data connection
 		 */
@@ -6068,7 +5782,7 @@ void wpas_p2p_wps_failed(struct wpa_supplicant *wpa_s,
 		wpa_s->global->p2p_fail_on_wps_complete = 1;
 		eloop_deplete_timeout(0, 50000,
 				      wpas_p2p_group_formation_timeout,
-				      wpa_s->p2pdev, NULL);
+				      wpa_s->parent, NULL);
 	}
 }
 
@@ -6354,15 +6068,12 @@ void wpas_p2p_rx_action(struct wpa_supplicant *wpa_s, const u8 *da,
 
 void wpas_p2p_scan_ie(struct wpa_supplicant *wpa_s, struct wpabuf *ies)
 {
-	unsigned int bands;
-
 	if (wpa_s->global->p2p_disabled)
 		return;
 	if (wpa_s->global->p2p == NULL)
 		return;
 
-	bands = wpas_get_bands(wpa_s, NULL);
-	p2p_scan_ie(wpa_s->global->p2p, ies, NULL, bands);
+	p2p_scan_ie(wpa_s->global->p2p, ies, NULL);
 }
 
 
@@ -6392,15 +6103,13 @@ int wpas_p2p_reject(struct wpa_supplicant *wpa_s, const u8 *addr)
 /* Invite to reinvoke a persistent group */
 int wpas_p2p_invite(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 		    struct wpa_ssid *ssid, const u8 *go_dev_addr, int freq,
-		    int vht_center_freq2, int ht40, int vht, int max_chwidth,
-		    int pref_freq)
+		    int ht40, int vht, int pref_freq)
 {
 	enum p2p_invite_role role;
 	u8 *bssid = NULL;
 	int force_freq = 0;
 	int res;
 	int no_pref_freq_given = pref_freq == 0;
-	unsigned int pref_freq_list[P2P_MAX_PREF_CHANNELS], size;
 
 	wpa_s->global->p2p_invite_group = NULL;
 	if (peer_addr)
@@ -6410,9 +6119,6 @@ int wpas_p2p_invite(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 
 	wpa_s->p2p_persistent_go_freq = freq;
 	wpa_s->p2p_go_ht40 = !!ht40;
-	wpa_s->p2p_go_vht = !!vht;
-	wpa_s->p2p_go_max_oper_chwidth = max_chwidth;
-	wpa_s->p2p_go_vht_center_freq2 = vht_center_freq2;
 	if (ssid->mode == WPAS_MODE_P2P_GO) {
 		role = P2P_INVITE_ROLE_GO;
 		if (peer_addr == NULL) {
@@ -6429,9 +6135,7 @@ int wpas_p2p_invite(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 				return -1;
 			}
 			bssid = wpa_s->pending_interface_addr;
-		} else if (wpa_s->p2p_mgmt)
-			bssid = wpa_s->parent->own_addr;
-		else
+		} else
 			bssid = wpa_s->own_addr;
 	} else {
 		role = P2P_INVITE_ROLE_CLIENT;
@@ -6439,13 +6143,10 @@ int wpas_p2p_invite(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 	}
 	wpa_s->pending_invite_ssid_id = ssid->id;
 
-	size = P2P_MAX_PREF_CHANNELS;
 	res = wpas_p2p_setup_freqs(wpa_s, freq, &force_freq, &pref_freq,
-				   role == P2P_INVITE_ROLE_GO,
-				   pref_freq_list, &size);
+				   role == P2P_INVITE_ROLE_GO);
 	if (res)
 		return res;
-	p2p_set_own_pref_freq_list(wpa_s->global->p2p, pref_freq_list, size);
 
 	if (wpa_s->global->p2p_disabled || wpa_s->global->p2p == NULL)
 		return -1;
@@ -6482,13 +6183,10 @@ int wpas_p2p_invite_group(struct wpa_supplicant *wpa_s, const char *ifname,
 	int persistent;
 	int freq = 0, force_freq = 0, pref_freq = 0;
 	int res;
-	unsigned int pref_freq_list[P2P_MAX_PREF_CHANNELS], size;
 
 	wpa_s->p2p_persistent_go_freq = 0;
 	wpa_s->p2p_go_ht40 = 0;
 	wpa_s->p2p_go_vht = 0;
-	wpa_s->p2p_go_vht_center_freq2 = 0;
-	wpa_s->p2p_go_max_oper_chwidth = 0;
 
 	for (wpa_s = global->ifaces; wpa_s; wpa_s = wpa_s->next) {
 		if (os_strcmp(wpa_s->ifname, ifname) == 0)
@@ -6508,7 +6206,7 @@ int wpas_p2p_invite_group(struct wpa_supplicant *wpa_s, const char *ifname,
 
 	wpa_s->global->p2p_invite_group = wpa_s;
 	persistent = ssid->p2p_persistent_group &&
-		wpas_p2p_get_persistent(wpa_s->p2pdev, peer_addr,
+		wpas_p2p_get_persistent(wpa_s->parent, peer_addr,
 					ssid->ssid, ssid->ssid_len);
 
 	if (ssid->mode == WPAS_MODE_P2P_GO) {
@@ -6531,15 +6229,13 @@ int wpas_p2p_invite_group(struct wpa_supplicant *wpa_s, const char *ifname,
 		freq = wpa_s->current_bss ? wpa_s->current_bss->freq :
 			(int) wpa_s->assoc_freq;
 	}
-	wpa_s->p2pdev->pending_invite_ssid_id = -1;
+	wpa_s->parent->pending_invite_ssid_id = -1;
 
 	if (wpa_s->global->p2p_disabled || wpa_s->global->p2p == NULL)
 		return -1;
 
-	size = P2P_MAX_PREF_CHANNELS;
 	res = wpas_p2p_setup_freqs(wpa_s, freq, &force_freq, &pref_freq,
-				   role == P2P_INVITE_ROLE_ACTIVE_GO,
-				   pref_freq_list, &size);
+				   role == P2P_INVITE_ROLE_ACTIVE_GO);
 	if (res)
 		return res;
 	wpas_p2p_set_own_freq_preference(wpa_s, force_freq);
@@ -6562,7 +6258,7 @@ void wpas_p2p_completed(struct wpa_supplicant *wpa_s)
 
 	if (ssid == NULL || ssid->mode != WPAS_MODE_P2P_GROUP_FORMATION) {
 		eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-				     wpa_s->p2pdev, NULL);
+				     wpa_s->parent, NULL);
 	}
 
 	if (!wpa_s->show_group_started || !ssid)
@@ -6604,7 +6300,7 @@ void wpas_p2p_completed(struct wpa_supplicant *wpa_s)
 			       ip_addr);
 
 	if (persistent)
-		network_id = wpas_p2p_store_persistent_group(wpa_s->p2pdev,
+		network_id = wpas_p2p_store_persistent_group(wpa_s->parent,
 							     ssid, go_dev_addr);
 	if (network_id < 0)
 		network_id = ssid->id;
@@ -6941,7 +6637,7 @@ int wpas_p2p_set_cross_connect(struct wpa_supplicant *wpa_s, int enabled)
 
 			iface->cross_connect_enabled = 0;
 			iface->cross_connect_in_use = 0;
-			wpa_msg_global(iface->p2pdev, MSG_INFO,
+			wpa_msg_global(iface->parent, MSG_INFO,
 				       P2P_EVENT_CROSS_CONNECT_DISABLE "%s %s",
 				       iface->ifname,
 				       iface->cross_connect_uplink);
@@ -6971,7 +6667,7 @@ static void wpas_p2p_enable_cross_connect(struct wpa_supplicant *uplink)
 			continue;
 
 		iface->cross_connect_in_use = 1;
-		wpa_msg_global(iface->p2pdev, MSG_INFO,
+		wpa_msg_global(iface->parent, MSG_INFO,
 			       P2P_EVENT_CROSS_CONNECT_ENABLE "%s %s",
 			       iface->ifname, iface->cross_connect_uplink);
 	}
@@ -6991,7 +6687,7 @@ static void wpas_p2p_disable_cross_connect(struct wpa_supplicant *uplink)
 		if (!iface->cross_connect_in_use)
 			continue;
 
-		wpa_msg_global(iface->p2pdev, MSG_INFO,
+		wpa_msg_global(iface->parent, MSG_INFO,
 			       P2P_EVENT_CROSS_CONNECT_DISABLE "%s %s",
 			       iface->ifname, iface->cross_connect_uplink);
 		iface->cross_connect_in_use = 0;
@@ -7054,7 +6750,7 @@ static void wpas_p2p_cross_connect_setup(struct wpa_supplicant *wpa_s)
 			break;
 
 		wpa_s->cross_connect_in_use = 1;
-		wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+		wpa_msg_global(wpa_s->parent, MSG_INFO,
 			       P2P_EVENT_CROSS_CONNECT_ENABLE "%s %s",
 			       wpa_s->ifname, wpa_s->cross_connect_uplink);
 		break;
@@ -7070,8 +6766,8 @@ int wpas_p2p_notif_pbc_overlap(struct wpa_supplicant *wpa_s)
 
 	wpa_printf(MSG_DEBUG, "P2P: Terminate connection due to WPS PBC "
 		   "session overlap");
-	if (wpa_s != wpa_s->p2pdev)
-		wpa_msg_ctrl(wpa_s->p2pdev, MSG_INFO, WPS_EVENT_OVERLAP);
+	if (wpa_s != wpa_s->parent)
+		wpa_msg_ctrl(wpa_s->parent, MSG_INFO, WPS_EVENT_OVERLAP);
 	wpas_p2p_group_formation_failed(wpa_s, 0);
 	return 1;
 }
@@ -7180,7 +6876,7 @@ int wpas_p2p_cancel(struct wpa_supplicant *wpa_s)
 				   wpa_s->ifname);
 			found = 1;
 			eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-					     wpa_s->p2pdev, NULL);
+					     wpa_s->parent, NULL);
 			if (wpa_s->p2p_in_provisioning) {
 				wpas_group_formation_completed(wpa_s, 0, 0);
 				break;
@@ -7193,7 +6889,6 @@ int wpas_p2p_cancel(struct wpa_supplicant *wpa_s)
 				   wpa_s->ifname);
 			found = 1;
 			wpas_p2p_group_formation_failed(wpa_s, 0);
-			break;
 		}
 	}
 
@@ -7310,7 +7005,7 @@ void wpas_p2p_network_removed(struct wpa_supplicant *wpa_s,
 {
 	if (wpa_s->p2p_in_provisioning && ssid->p2p_group &&
 	    eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-				 wpa_s->p2pdev, NULL) > 0) {
+				 wpa_s->parent, NULL) > 0) {
 		/**
 		 * Remove the network by scheduling the group formation
 		 * timeout to happen immediately. The teardown code
@@ -7322,7 +7017,7 @@ void wpas_p2p_network_removed(struct wpa_supplicant *wpa_s,
 		wpa_printf(MSG_DEBUG, "P2P: Canceled group formation due to "
 			   "P2P group network getting removed");
 		eloop_register_timeout(0, 0, wpas_p2p_group_formation_timeout,
-				       wpa_s->p2pdev, NULL);
+				       wpa_s->parent, NULL);
 	}
 }
 
@@ -7366,7 +7061,7 @@ void wpas_p2p_notify_ap_sta_authorized(struct wpa_supplicant *wpa_s,
 				       const u8 *addr)
 {
 	if (eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
-				 wpa_s->p2pdev, NULL) > 0) {
+				 wpa_s->parent, NULL) > 0) {
 		/*
 		 * This can happen if WPS provisioning step is not terminated
 		 * cleanly (e.g., P2P Client does not send WSC_Done). Since the
@@ -7422,12 +7117,10 @@ static int wpas_p2p_fallback_to_go_neg(struct wpa_supplicant *wpa_s,
 	wpas_p2p_connect(wpa_s, wpa_s->pending_join_dev_addr, wpa_s->p2p_pin,
 			 wpa_s->p2p_wps_method, wpa_s->p2p_persistent_group, 0,
 			 0, 0, wpa_s->p2p_go_intent, wpa_s->p2p_connect_freq,
-			 wpa_s->p2p_go_vht_center_freq2,
 			 wpa_s->p2p_persistent_id,
 			 wpa_s->p2p_pd_before_go_neg,
 			 wpa_s->p2p_go_ht40,
-			 wpa_s->p2p_go_vht,
-			 wpa_s->p2p_go_max_oper_chwidth);
+			 wpa_s->p2p_go_vht);
 	return ret;
 }
 
@@ -7445,7 +7138,7 @@ int wpas_p2p_scan_no_go_seen(struct wpa_supplicant *wpa_s)
 
 	wpa_dbg(wpa_s, MSG_DEBUG, "P2P: GO not found for p2p_connect-auto - "
 		"fallback to GO Negotiation");
-	wpa_msg_global(wpa_s->p2pdev, MSG_INFO, P2P_EVENT_FALLBACK_TO_GO_NEG
+	wpa_msg_global(wpa_s->parent, MSG_INFO, P2P_EVENT_FALLBACK_TO_GO_NEG
 		       "reason=GO-not-found");
 	res = wpas_p2p_fallback_to_go_neg(wpa_s, 1);
 
@@ -7554,7 +7247,7 @@ void wpas_p2p_new_psk_cb(struct wpa_supplicant *wpa_s, const u8 *mac_addr,
 		return;
 	}
 
-	persistent = wpas_p2p_get_persistent(wpa_s->p2pdev, NULL, ssid->ssid,
+	persistent = wpas_p2p_get_persistent(wpa_s->parent, NULL, ssid->ssid,
 					     ssid->ssid_len);
 	if (!persistent) {
 		wpa_dbg(wpa_s, MSG_DEBUG, "P2P: Could not find persistent group information to store the new PSK");
@@ -7583,7 +7276,7 @@ void wpas_p2p_new_psk_cb(struct wpa_supplicant *wpa_s, const u8 *mac_addr,
 		os_free(last);
 	}
 
-	wpas_p2p_remove_psk_entry(wpa_s->p2pdev, persistent,
+	wpas_p2p_remove_psk_entry(wpa_s->parent, persistent,
 				  p2p_dev_addr ? p2p_dev_addr : mac_addr,
 				  p2p_dev_addr == NULL);
 	if (p2p_dev_addr) {
@@ -7595,8 +7288,8 @@ void wpas_p2p_new_psk_cb(struct wpa_supplicant *wpa_s, const u8 *mac_addr,
 	}
 	dl_list_add(&persistent->psk_list, &p->list);
 
-	if (wpa_s->p2pdev->conf->update_config &&
-	    wpa_config_write(wpa_s->p2pdev->confname, wpa_s->p2pdev->conf))
+	if (wpa_s->parent->conf->update_config &&
+	    wpa_config_write(wpa_s->parent->confname, wpa_s->parent->conf))
 		wpa_printf(MSG_DEBUG, "P2P: Failed to update configuration");
 }
 
@@ -7775,14 +7468,14 @@ int wpas_p2p_4way_hs_failed(struct wpa_supplicant *wpa_s)
 
 		wpa_dbg(wpa_s, MSG_DEBUG, "P2P: Two 4-way handshake failures for a P2P group - go_dev_addr="
 			MACSTR, MAC2STR(go_dev_addr));
-		persistent = wpas_p2p_get_persistent(wpa_s->p2pdev, go_dev_addr,
+		persistent = wpas_p2p_get_persistent(wpa_s->parent, go_dev_addr,
 						     ssid->ssid,
 						     ssid->ssid_len);
 		if (persistent == NULL || persistent->mode != WPAS_MODE_INFRA) {
 			wpa_dbg(wpa_s, MSG_DEBUG, "P2P: No matching persistent group stored");
 			goto disconnect;
 		}
-		wpa_msg_global(wpa_s->p2pdev, MSG_INFO,
+		wpa_msg_global(wpa_s->parent, MSG_INFO,
 			       P2P_EVENT_PERSISTENT_PSK_FAIL "%d",
 			       persistent->id);
 	disconnect:
@@ -7961,8 +7654,7 @@ static int wpas_p2p_nfc_join_group(struct wpa_supplicant *wpa_s,
 
 	return wpas_p2p_connect(wpa_s, params->peer->p2p_device_addr, NULL,
 				WPS_NFC, 0, 0, 1, 0, wpa_s->conf->p2p_go_intent,
-				params->go_freq, wpa_s->p2p_go_vht_center_freq2,
-				-1, 0, 1, 1, wpa_s->p2p_go_max_oper_chwidth);
+				params->go_freq, -1, 0, 1, 1);
 }
 
 
@@ -8038,8 +7730,7 @@ static int wpas_p2p_nfc_init_go_neg(struct wpa_supplicant *wpa_s,
 		   "connection handover");
 	return wpas_p2p_connect(wpa_s, params->peer->p2p_device_addr, NULL,
 				WPS_NFC, 0, 0, 0, 0, wpa_s->conf->p2p_go_intent,
-				forced_freq, wpa_s->p2p_go_vht_center_freq2,
-				-1, 0, 1, 1, wpa_s->p2p_go_max_oper_chwidth);
+				forced_freq, -1, 0, 1, 1);
 }
 
 
@@ -8053,8 +7744,7 @@ static int wpas_p2p_nfc_resp_go_neg(struct wpa_supplicant *wpa_s,
 		   "connection handover");
 	res = wpas_p2p_connect(wpa_s, params->peer->p2p_device_addr, NULL,
 			       WPS_NFC, 0, 0, 0, 1, wpa_s->conf->p2p_go_intent,
-			       forced_freq, wpa_s->p2p_go_vht_center_freq2,
-			       -1, 0, 1, 1, wpa_s->p2p_go_max_oper_chwidth);
+			       forced_freq, -1, 0, 1, 1);
 	if (res)
 		return res;
 
@@ -8345,9 +8035,7 @@ int wpas_p2p_nfc_tag_enabled(struct wpa_supplicant *wpa_s, int enabled)
 		}
 
 		if_addr = wpa_s->pending_interface_addr;
-	} else if (wpa_s->p2p_mgmt)
-		if_addr = wpa_s->parent->own_addr;
-	else
+	} else
 		if_addr = wpa_s->own_addr;
 
 	wpa_s->p2p_nfc_tag_enabled = enabled;
diff --git a/wpa_supplicant/p2p_supplicant.h b/wpa_supplicant/p2p_supplicant.h
index 2b46ca0..1df34d0 100644
--- a/wpa_supplicant/p2p_supplicant.h
+++ b/wpa_supplicant/p2p_supplicant.h
@@ -26,21 +26,17 @@ struct wpa_supplicant * wpas_get_p2p_client_iface(struct wpa_supplicant *wpa_s,
 int wpas_p2p_connect(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 		     const char *pin, enum p2p_wps_method wps_method,
 		     int persistent_group, int auto_join, int join,
-		     int auth, int go_intent, int freq,
-		     unsigned int vht_center_freq2, int persistent_id,
-		     int pd, int ht40, int vht, unsigned int max_oper_chwidth);
+		     int auth, int go_intent, int freq, int persistent_id,
+		     int pd, int ht40, int vht);
 int wpas_p2p_handle_frequency_conflicts(struct wpa_supplicant *wpa_s,
                                           int freq, struct wpa_ssid *ssid);
 int wpas_p2p_group_add(struct wpa_supplicant *wpa_s, int persistent_group,
-		       int freq, int vht_center_freq2, int ht40, int vht,
-		       int max_oper_chwidth);
+		       int freq, int ht40, int vht);
 int wpas_p2p_group_add_persistent(struct wpa_supplicant *wpa_s,
 				  struct wpa_ssid *ssid, int addr_allocated,
-				  int force_freq, int neg_freq,
-				  int vht_center_freq2, int ht40,
-				  int vht, int max_oper_chwidth,
-				  const struct p2p_channels *channels,
-				  int connection_timeout, int force_scan);
+				  int force_freq, int neg_freq, int ht40,
+				  int vht, const struct p2p_channels *channels,
+				  int connection_timeout);
 struct p2p_group * wpas_p2p_group_init(struct wpa_supplicant *wpa_s,
 				       struct wpa_ssid *ssid);
 enum wpas_p2p_prov_disc_use {
@@ -105,8 +101,7 @@ void wpas_sd_response(void *ctx, const u8 *sa, u16 update_indic,
 int wpas_p2p_reject(struct wpa_supplicant *wpa_s, const u8 *addr);
 int wpas_p2p_invite(struct wpa_supplicant *wpa_s, const u8 *peer_addr,
 		    struct wpa_ssid *ssid, const u8 *go_dev_addr, int freq,
-		    int vht_center_freq2, int ht40, int vht,
-		    int max_oper_chwidth, int pref_freq);
+		    int ht40, int vht, int pref_freq);
 int wpas_p2p_invite_group(struct wpa_supplicant *wpa_s, const char *ifname,
 			  const u8 *peer_addr, const u8 *go_dev_addr);
 int wpas_p2p_presence_req(struct wpa_supplicant *wpa_s, u32 duration1,
@@ -135,8 +130,6 @@ int wpas_p2p_get_ht40_mode(struct wpa_supplicant *wpa_s,
 			   struct hostapd_hw_modes *mode, u8 channel);
 int wpas_p2p_get_vht80_center(struct wpa_supplicant *wpa_s,
 			      struct hostapd_hw_modes *mode, u8 channel);
-int wpas_p2p_get_vht160_center(struct wpa_supplicant *wpa_s,
-			       struct hostapd_hw_modes *mode, u8 channel);
 unsigned int wpas_p2p_search_delay(struct wpa_supplicant *wpa_s);
 void wpas_p2p_new_psk_cb(struct wpa_supplicant *wpa_s, const u8 *mac_addr,
 			 const u8 *p2p_dev_addr,
diff --git a/wpa_supplicant/scan.c b/wpa_supplicant/scan.c
index 03a8cc3..e81465c 100644
--- a/wpa_supplicant/scan.c
+++ b/wpa_supplicant/scan.c
@@ -485,12 +485,6 @@ static struct wpabuf * wpa_supplicant_extra_ies(struct wpa_supplicant *wpa_s)
 		wpas_hs20_add_indication(extra_ie, -1);
 #endif /* CONFIG_HS20 */
 
-#ifdef CONFIG_FST
-	if (wpa_s->fst_ies &&
-	    wpabuf_resize(&extra_ie, wpabuf_len(wpa_s->fst_ies)) == 0)
-		wpabuf_put_buf(extra_ie, wpa_s->fst_ies);
-#endif /* CONFIG_FST */
-
 	return extra_ie;
 }
 
@@ -1013,27 +1007,6 @@ ssid_list_set:
 		}
 	}
 
-	if (!is_zero_ether_addr(wpa_s->next_scan_bssid)) {
-		struct wpa_bss *bss;
-
-		params.bssid = wpa_s->next_scan_bssid;
-		bss = wpa_bss_get_bssid_latest(wpa_s, params.bssid);
-		if (bss && bss->ssid_len && params.num_ssids == 1 &&
-		    params.ssids[0].ssid_len == 0) {
-			params.ssids[0].ssid = bss->ssid;
-			params.ssids[0].ssid_len = bss->ssid_len;
-			wpa_dbg(wpa_s, MSG_DEBUG,
-				"Scan a previously specified BSSID " MACSTR
-				" and SSID %s",
-				MAC2STR(params.bssid),
-				wpa_ssid_txt(bss->ssid, bss->ssid_len));
-		} else {
-			wpa_dbg(wpa_s, MSG_DEBUG,
-				"Scan a previously specified BSSID " MACSTR,
-				MAC2STR(params.bssid));
-		}
-	}
-
 	scan_params = &params;
 
 scan:
@@ -1094,8 +1067,6 @@ scan:
 #ifdef CONFIG_INTERWORKING
 		wpa_s->interworking_fast_assoc_tried = 0;
 #endif /* CONFIG_INTERWORKING */
-		if (params.bssid)
-			os_memset(wpa_s->next_scan_bssid, 0, ETH_ALEN);
 	}
 }
 
@@ -1159,13 +1130,6 @@ void wpa_supplicant_req_scan(struct wpa_supplicant *wpa_s, int sec, int usec)
 }
 
 
-#ifdef MTK_HARDWARE
-int wpa_supplicant_pending_scan(struct wpa_supplicant *wpa_s)
-{
-	return eloop_is_timeout_registered(wpa_supplicant_scan, wpa_s, NULL);
-}
-#endif
-
 /**
  * wpa_supplicant_delayed_sched_scan - Request a delayed scheduled scan
  * @wpa_s: Pointer to wpa_supplicant data
@@ -1715,7 +1679,7 @@ static int wpa_scan_result_compar(const void *a, const void *b)
 		snr_a_full = wa->snr;
 		snr_a = MIN(wa->snr, GREAT_SNR);
 		snr_b_full = wb->snr;
-		snr_b = MIN(wb->snr, GREAT_SNR);
+		snr_b = MIN(wa->snr, GREAT_SNR);
 	} else {
 		/* Level is not in dBm, so we can't calculate
 		 * SNR. Just use raw level (units unknown). */
@@ -1859,8 +1823,8 @@ int wpa_supplicant_filter_bssid_match(struct wpa_supplicant *wpa_s,
 }
 
 
-void filter_scan_res(struct wpa_supplicant *wpa_s,
-		     struct wpa_scan_results *res)
+static void filter_scan_res(struct wpa_supplicant *wpa_s,
+			    struct wpa_scan_results *res)
 {
 	size_t i, j;
 
@@ -1893,7 +1857,7 @@ void filter_scan_res(struct wpa_supplicant *wpa_s,
 #define DEFAULT_NOISE_FLOOR_2GHZ (-89)
 #define DEFAULT_NOISE_FLOOR_5GHZ (-92)
 
-void scan_snr(struct wpa_scan_res *res)
+static void scan_snr(struct wpa_scan_res *res)
 {
 	if (res->flags & WPA_SCAN_NOISE_INVALID) {
 		res->noise = IS_5GHZ(res->freq) ?
@@ -1977,8 +1941,8 @@ static unsigned int max_vht80_rate(int snr)
 }
 
 
-void scan_est_throughput(struct wpa_supplicant *wpa_s,
-			 struct wpa_scan_res *res)
+static void scan_est_throughput(struct wpa_supplicant *wpa_s,
+				struct wpa_scan_res *res)
 {
 	enum local_hw_capab capab = wpa_s->hw_capab;
 	int rate; /* max legacy rate in 500 kb/s units */
@@ -2258,17 +2222,6 @@ wpa_scan_clone_params(const struct wpa_driver_scan_params *src)
 			params->mac_addr_mask = mac_addr + ETH_ALEN;
 		}
 	}
-
-	if (src->bssid) {
-		u8 *bssid;
-
-		bssid = os_malloc(ETH_ALEN);
-		if (!bssid)
-			goto failed;
-		os_memcpy(bssid, src->bssid, ETH_ALEN);
-		params->bssid = bssid;
-	}
-
 	return params;
 
 failed:
@@ -2296,8 +2249,6 @@ void wpa_scan_free_params(struct wpa_driver_scan_params *params)
 	 */
 	os_free((u8 *) params->mac_addr);
 
-	os_free((u8 *) params->bssid);
-
 	os_free(params);
 }
 
@@ -2502,14 +2453,3 @@ int wpas_mac_addr_rand_scan_set(struct wpa_supplicant *wpa_s,
 	wpa_s->mac_addr_rand_enable |= type;
 	return 0;
 }
-
-
-int wpas_abort_ongoing_scan(struct wpa_supplicant *wpa_s)
-{
-	if (wpa_s->scan_work && wpa_s->own_scan_running) {
-		wpa_dbg(wpa_s, MSG_DEBUG, "Abort an ongoing scan");
-		return wpa_drv_abort_scan(wpa_s);
-	}
-
-	return 0;
-}
diff --git a/wpa_supplicant/scan.h b/wpa_supplicant/scan.h
index 893c3c0..7650f5a 100644
--- a/wpa_supplicant/scan.h
+++ b/wpa_supplicant/scan.h
@@ -54,11 +54,5 @@ void wpas_mac_addr_rand_scan_clear(struct wpa_supplicant *wpa_s,
 int wpas_mac_addr_rand_scan_set(struct wpa_supplicant *wpa_s,
 				unsigned int type, const u8 *addr,
 				const u8 *mask);
-int wpas_abort_ongoing_scan(struct wpa_supplicant *wpa_s);
-void filter_scan_res(struct wpa_supplicant *wpa_s,
-		     struct wpa_scan_results *res);
-void scan_snr(struct wpa_scan_res *res);
-void scan_est_throughput(struct wpa_supplicant *wpa_s,
-			 struct wpa_scan_res *res);
 
 #endif /* SCAN_H */
diff --git a/wpa_supplicant/sme.c b/wpa_supplicant/sme.c
index 2176453..a472feb 100644
--- a/wpa_supplicant/sme.c
+++ b/wpa_supplicant/sme.c
@@ -438,21 +438,6 @@ static void sme_send_authentication(struct wpa_supplicant *wpa_s,
 	}
 #endif /* CONFIG_HS20 */
 
-#ifdef CONFIG_FST
-	if (wpa_s->fst_ies) {
-		int fst_ies_len = wpabuf_len(wpa_s->fst_ies);
-
-		if (wpa_s->sme.assoc_req_ie_len + fst_ies_len <=
-		    sizeof(wpa_s->sme.assoc_req_ie)) {
-			os_memcpy(wpa_s->sme.assoc_req_ie +
-				  wpa_s->sme.assoc_req_ie_len,
-				  wpabuf_head(wpa_s->fst_ies),
-				  fst_ies_len);
-			wpa_s->sme.assoc_req_ie_len += fst_ies_len;
-		}
-	}
-#endif /* CONFIG_FST */
-
 	ext_capab_len = wpas_build_ext_capab(wpa_s, ext_capab,
 					     sizeof(ext_capab));
 	if (ext_capab_len > 0) {
@@ -598,8 +583,7 @@ static void sme_auth_start_cb(struct wpa_radio_work *work, int deinit)
 	wpa_s->connect_work = work;
 
 	if (cwork->bss_removed ||
-	    !wpas_valid_bss_ssid(wpa_s, cwork->bss, cwork->ssid) ||
-	    wpas_network_disabled(wpa_s, cwork->ssid)) {
+	    !wpas_valid_bss_ssid(wpa_s, cwork->bss, cwork->ssid)) {
 		wpa_dbg(wpa_s, MSG_DEBUG, "SME: BSS/SSID entry for authentication not valid anymore - drop connection attempt");
 		wpas_connect_work_done(wpa_s);
 		return;
@@ -632,8 +616,6 @@ void sme_authenticate(struct wpa_supplicant *wpa_s,
 		radio_remove_works(wpa_s, "sme-connect", 0);
 	}
 
-	wpas_abort_ongoing_scan(wpa_s);
-
 	cwork = os_zalloc(sizeof(*cwork));
 	if (cwork == NULL)
 		return;
@@ -963,8 +945,8 @@ void sme_associate(struct wpa_supplicant *wpa_s, enum wpas_mode mode,
 	if (wpa_s->current_ssid && wpa_s->current_ssid->p2p_group)
 		params.p2p = 1;
 
-	if (wpa_s->p2pdev->set_sta_uapsd)
-		params.uapsd = wpa_s->p2pdev->sta_uapsd;
+	if (wpa_s->parent->set_sta_uapsd)
+		params.uapsd = wpa_s->parent->sta_uapsd;
 	else
 		params.uapsd = -1;
 
diff --git a/wpa_supplicant/wnm_sta.c b/wpa_supplicant/wnm_sta.c
index 7a1d366..7d79499 100644
--- a/wpa_supplicant/wnm_sta.c
+++ b/wpa_supplicant/wnm_sta.c
@@ -24,7 +24,6 @@
 #define MAX_TFS_IE_LEN  1024
 #define WNM_MAX_NEIGHBOR_REPORT 10
 
-#define WNM_SCAN_RESULT_AGE 2 /* 2 seconds */
 
 /* get the TFS IE from driver */
 static int ieee80211_11_get_tfs_ie(struct wpa_supplicant *wpa_s, u8 *buf,
@@ -138,8 +137,6 @@ int ieee802_11_send_wnmsleep_req(struct wpa_supplicant *wpa_s,
 	if (res < 0)
 		wpa_printf(MSG_DEBUG, "Failed to send WNM-Sleep Request "
 			   "(action=%d, intval=%d)", action, intval);
-	else
-		wpa_s->wnmsleep_used = 1;
 
 	os_free(wnmsleep_ie);
 	os_free(wnmtfs_ie);
@@ -256,12 +253,6 @@ static void ieee802_11_rx_wnmsleep_resp(struct wpa_supplicant *wpa_s,
 	u8 *tfsresp_ie_end = NULL;
 	size_t left;
 
-	if (!wpa_s->wnmsleep_used) {
-		wpa_printf(MSG_DEBUG,
-			   "WNM: Ignore WNM-Sleep Mode Response frame since WNM-Sleep Mode has not been used in this association");
-		return;
-	}
-
 	if (len < 3)
 		return;
 	key_len_total = WPA_GET_LE16(frm + 1);
@@ -428,7 +419,6 @@ static int wnm_nei_get_chan(struct wpa_supplicant *wpa_s, u8 op_class, u8 chan)
 {
 	struct wpa_bss *bss = wpa_s->current_bss;
 	const char *country = NULL;
-	int freq;
 
 	if (bss) {
 		const u8 *elem = wpa_bss_get_ie(bss, WLAN_EID_COUNTRY);
@@ -437,21 +427,7 @@ static int wnm_nei_get_chan(struct wpa_supplicant *wpa_s, u8 op_class, u8 chan)
 			country = (const char *) (elem + 2);
 	}
 
-	freq = ieee80211_chan_to_freq(country, op_class, chan);
-	if (freq <= 0 && op_class == 0) {
-		/*
-		 * Some APs do not advertise correct operating class
-		 * information. Try to determine the most likely operating
-		 * frequency based on the channel number.
-		 */
-		if (chan >= 1 && chan <= 13)
-			freq = 2407 + chan * 5;
-		else if (chan == 14)
-			freq = 2484;
-		else if (chan >= 36 && chan <= 169)
-			freq = 5000 + chan * 5;
-	}
-	return freq;
+	return ieee80211_chan_to_freq(country, op_class, chan);
 }
 
 
@@ -498,7 +474,7 @@ static void wnm_parse_neighbor_report(struct wpa_supplicant *wpa_s,
 
 
 static struct wpa_bss *
-compare_scan_neighbor_results(struct wpa_supplicant *wpa_s, os_time_t age_secs)
+compare_scan_neighbor_results(struct wpa_supplicant *wpa_s)
 {
 
 	u8 i;
@@ -531,19 +507,6 @@ compare_scan_neighbor_results(struct wpa_supplicant *wpa_s, os_time_t age_secs)
 			continue;
 		}
 
-		if (age_secs) {
-			struct os_reltime now;
-
-			if (os_get_reltime(&now) == 0 &&
-			    os_reltime_expired(&now, &target->last_update,
-					       age_secs)) {
-				wpa_printf(MSG_DEBUG,
-					   "Candidate BSS is more than %ld seconds old",
-					   age_secs);
-				continue;
-			}
-		}
-
 		if (bss->ssid_len != target->ssid_len ||
 		    os_memcmp(bss->ssid, target->ssid, bss->ssid_len) != 0) {
 			/*
@@ -636,41 +599,6 @@ static void wnm_send_bss_transition_mgmt_resp(
 }
 
 
-static void wnm_bss_tm_connect(struct wpa_supplicant *wpa_s,
-			       struct wpa_bss *bss, struct wpa_ssid *ssid,
-			       int after_new_scan)
-{
-	wpa_dbg(wpa_s, MSG_DEBUG,
-		"WNM: Transition to BSS " MACSTR
-		" based on BSS Transition Management Request (old BSSID "
-		MACSTR " after_new_scan=%d)",
-		MAC2STR(bss->bssid), MAC2STR(wpa_s->bssid), after_new_scan);
-
-	/* Send the BSS Management Response - Accept */
-	if (wpa_s->wnm_reply) {
-		wpa_s->wnm_reply = 0;
-		wpa_printf(MSG_DEBUG,
-			   "WNM: Sending successful BSS Transition Management Response");
-		wnm_send_bss_transition_mgmt_resp(wpa_s,
-						  wpa_s->wnm_dialog_token,
-						  WNM_BSS_TM_ACCEPT,
-						  0, bss->bssid);
-	}
-
-	if (bss == wpa_s->current_bss) {
-		wpa_printf(MSG_DEBUG,
-			   "WNM: Already associated with the preferred candidate");
-		wnm_deallocate_memory(wpa_s);
-		return;
-	}
-
-	wpa_s->reassociate = 1;
-	wpa_printf(MSG_DEBUG, "WNM: Issuing connect");
-	wpa_supplicant_connect(wpa_s, bss, ssid);
-	wnm_deallocate_memory(wpa_s);
-}
-
-
 int wnm_scan_process(struct wpa_supplicant *wpa_s, int reply_on_fail)
 {
 	struct wpa_bss *bss;
@@ -680,8 +608,6 @@ int wnm_scan_process(struct wpa_supplicant *wpa_s, int reply_on_fail)
 	if (!wpa_s->wnm_neighbor_report_elements)
 		return 0;
 
-	wpa_dbg(wpa_s, MSG_DEBUG,
-		"WNM: Process scan results for BSS Transition Management");
 	if (os_reltime_before(&wpa_s->wnm_cand_valid_until,
 			      &wpa_s->scan_trigger_time)) {
 		wpa_printf(MSG_DEBUG, "WNM: Previously stored BSS transition candidate list is not valid anymore - drop it");
@@ -697,7 +623,7 @@ int wnm_scan_process(struct wpa_supplicant *wpa_s, int reply_on_fail)
 	}
 
 	/* Compare the Neighbor Report and scan results */
-	bss = compare_scan_neighbor_results(wpa_s, 0);
+	bss = compare_scan_neighbor_results(wpa_s);
 	if (!bss) {
 		wpa_printf(MSG_DEBUG, "WNM: No BSS transition candidate match found");
 		status = WNM_BSS_TM_REJECT_NO_SUITABLE_CANDIDATES;
@@ -705,7 +631,24 @@ int wnm_scan_process(struct wpa_supplicant *wpa_s, int reply_on_fail)
 	}
 
 	/* Associate to the network */
-	wnm_bss_tm_connect(wpa_s, bss, ssid, 1);
+	/* Send the BSS Management Response - Accept */
+	if (wpa_s->wnm_reply) {
+		wpa_s->wnm_reply = 0;
+		wnm_send_bss_transition_mgmt_resp(wpa_s,
+						  wpa_s->wnm_dialog_token,
+						  WNM_BSS_TM_ACCEPT,
+						  0, bss->bssid);
+	}
+
+	if (bss == wpa_s->current_bss) {
+		wpa_printf(MSG_DEBUG,
+			   "WNM: Already associated with the preferred candidate");
+		return 1;
+	}
+
+	wpa_s->reassociate = 1;
+	wpa_supplicant_connect(wpa_s, bss, ssid);
+	wnm_deallocate_memory(wpa_s);
 	return 1;
 
 send_bss_resp_fail:
@@ -846,79 +789,6 @@ static void wnm_set_scan_freqs(struct wpa_supplicant *wpa_s)
 }
 
 
-static int wnm_fetch_scan_results(struct wpa_supplicant *wpa_s)
-{
-	struct wpa_scan_results *scan_res;
-	struct wpa_bss *bss;
-	struct wpa_ssid *ssid = wpa_s->current_ssid;
-	u8 i, found = 0;
-	size_t j;
-
-	wpa_dbg(wpa_s, MSG_DEBUG,
-		"WNM: Fetch current scan results from the driver for checking transition candidates");
-	scan_res = wpa_drv_get_scan_results2(wpa_s);
-	if (!scan_res) {
-		wpa_dbg(wpa_s, MSG_DEBUG, "WNM: Failed to get scan results");
-		return 0;
-	}
-
-	if (scan_res->fetch_time.sec == 0)
-		os_get_reltime(&scan_res->fetch_time);
-
-	filter_scan_res(wpa_s, scan_res);
-
-	for (i = 0; i < wpa_s->wnm_num_neighbor_report; i++) {
-		struct neighbor_report *nei;
-
-		nei = &wpa_s->wnm_neighbor_report_elements[i];
-		if (nei->preference_present && nei->preference == 0)
-			continue;
-
-		for (j = 0; j < scan_res->num; j++) {
-			struct wpa_scan_res *res;
-			const u8 *ssid_ie;
-
-			res = scan_res->res[j];
-			if (os_memcmp(nei->bssid, res->bssid, ETH_ALEN) != 0 ||
-			    res->age > WNM_SCAN_RESULT_AGE * 1000)
-				continue;
-			bss = wpa_s->current_bss;
-			ssid_ie = wpa_scan_get_ie(res, WLAN_EID_SSID);
-			if (bss && ssid_ie &&
-			    (bss->ssid_len != ssid_ie[1] ||
-			     os_memcmp(bss->ssid, ssid_ie + 2,
-				       bss->ssid_len) != 0))
-				continue;
-
-			/* Potential candidate found */
-			found = 1;
-			scan_snr(res);
-			scan_est_throughput(wpa_s, res);
-			wpa_bss_update_scan_res(wpa_s, res,
-						&scan_res->fetch_time);
-		}
-	}
-
-	wpa_scan_results_free(scan_res);
-	if (!found) {
-		wpa_dbg(wpa_s, MSG_DEBUG,
-			"WNM: No transition candidate matches existing scan results");
-		return 0;
-	}
-
-	bss = compare_scan_neighbor_results(wpa_s, WNM_SCAN_RESULT_AGE);
-	if (!bss) {
-		wpa_dbg(wpa_s, MSG_DEBUG,
-			"WNM: Comparison of scan results against transition candidates did not find matches");
-		return 0;
-	}
-
-	/* Associate to the network */
-	wnm_bss_tm_connect(wpa_s, bss, ssid, 0);
-	return 1;
-}
-
-
 static void ieee802_11_rx_bss_trans_mgmt_req(struct wpa_supplicant *wpa_s,
 					     const u8 *pos, const u8 *end,
 					     int reply)
@@ -1031,20 +901,6 @@ static void ieee802_11_rx_bss_trans_mgmt_req(struct wpa_supplicant *wpa_s,
 		wpa_s->wnm_cand_valid_until.usec %= 1000000;
 		os_memcpy(wpa_s->wnm_cand_from_bss, wpa_s->bssid, ETH_ALEN);
 
-		/*
-		 * Fetch the latest scan results from the kernel and check for
-		 * candidates based on those results first. This can help in
-		 * finding more up-to-date information should the driver has
-		 * done some internal scanning operations after the last scan
-		 * result update in wpa_supplicant.
-		 */
-		if (wnm_fetch_scan_results(wpa_s) > 0)
-			return;
-
-		/*
-		 * Try to use previously received scan results, if they are
-		 * recent enough to use for a connection.
-		 */
 		if (wpa_s->last_scan_res_used > 0) {
 			struct os_reltime now;
 
@@ -1060,14 +916,6 @@ static void ieee802_11_rx_bss_trans_mgmt_req(struct wpa_supplicant *wpa_s,
 		}
 
 		wnm_set_scan_freqs(wpa_s);
-		if (wpa_s->wnm_num_neighbor_report == 1) {
-			os_memcpy(wpa_s->next_scan_bssid,
-				  wpa_s->wnm_neighbor_report_elements[0].bssid,
-				  ETH_ALEN);
-			wpa_printf(MSG_DEBUG,
-				   "WNM: Scan only for a specific BSSID since there is only a single candidate "
-				   MACSTR, MAC2STR(wpa_s->next_scan_bssid));
-		}
 		wpa_supplicant_req_scan(wpa_s, 0, 0);
 	} else if (reply) {
 		enum bss_trans_mgmt_status_code status;
diff --git a/wpa_supplicant/wpa_cli.c b/wpa_supplicant/wpa_cli.c
index f71cd5c..c5d8333 100644
--- a/wpa_supplicant/wpa_cli.c
+++ b/wpa_supplicant/wpa_cli.c
@@ -76,7 +76,6 @@ static int wpa_cli_last_id = 0;
 #define CONFIG_CTRL_IFACE_DIR "/var/run/wpa_supplicant"
 #endif /* CONFIG_CTRL_IFACE_DIR */
 static const char *ctrl_iface_dir = CONFIG_CTRL_IFACE_DIR;
-static const char *client_socket_dir = NULL;
 static char *ctrl_ifname = NULL;
 static const char *pid_file = NULL;
 static const char *action_file = NULL;
@@ -108,9 +107,7 @@ static void usage(void)
 {
 	printf("wpa_cli [-p<path to ctrl sockets>] [-i<ifname>] [-hvB] "
 	       "[-a<action file>] \\\n"
-	       "        [-P<pid file>] [-g<global ctrl>] [-G<ping interval>] "
-	       "\\\n"
-	       "        [-s<wpa_client_socket_file_path>] "
+	       "        [-P<pid file>] [-g<global ctrl>] [-G<ping interval>]  "
 	       "[command..]\n"
 	       "  -h = help (show this usage text)\n"
 	       "  -v = shown version information\n"
@@ -333,13 +330,6 @@ static int wpa_cli_open_connection(const char *ifname, int attach)
 	}
 #endif /* ANDROID */
 
-	if (client_socket_dir && client_socket_dir[0] &&
-	    access(client_socket_dir, F_OK) < 0) {
-		perror(client_socket_dir);
-		os_free(cfile);
-		return -1;
-	}
-
 	if (cfile == NULL) {
 		flen = os_strlen(ctrl_iface_dir) + os_strlen(ifname) + 2;
 		cfile = os_malloc(flen);
@@ -353,14 +343,14 @@ static int wpa_cli_open_connection(const char *ifname, int attach)
 		}
 	}
 
-	ctrl_conn = wpa_ctrl_open2(cfile, client_socket_dir);
+	ctrl_conn = wpa_ctrl_open(cfile);
 	if (ctrl_conn == NULL) {
 		os_free(cfile);
 		return -1;
 	}
 
 	if (attach && interactive)
-		mon_conn = wpa_ctrl_open2(cfile, client_socket_dir);
+		mon_conn = wpa_ctrl_open(cfile);
 	else
 		mon_conn = NULL;
 	os_free(cfile);
@@ -1543,7 +1533,7 @@ static const char *network_fields[] = {
 	"ssid", "scan_ssid", "bssid", "bssid_blacklist",
 	"bssid_whitelist", "psk", "proto", "key_mgmt",
 	"bg_scan_period", "pairwise", "group", "auth_alg", "scan_freq",
-	"freq_list", "max_oper_chwidth",
+	"freq_list",
 #ifdef IEEE8021X_EAPOL
 	"eap", "identity", "anonymous_identity", "password", "ca_cert",
 	"ca_path", "client_cert", "private_key", "private_key_passwd",
@@ -1601,7 +1591,7 @@ static const char *network_fields[] = {
 #ifdef CONFIG_HS20
 	"update_identifier",
 #endif /* CONFIG_HS20 */
-	"mac_addr", "pbss"
+	"mac_addr"
 };
 
 
@@ -1759,13 +1749,6 @@ static int wpa_cli_cmd_scan_results(struct wpa_ctrl *ctrl, int argc,
 }
 
 
-static int wpa_cli_cmd_abort_scan(struct wpa_ctrl *ctrl, int argc,
-				  char *argv[])
-{
-	return wpa_ctrl_command(ctrl, "ABORT_SCAN");
-}
-
-
 static int wpa_cli_cmd_bss(struct wpa_ctrl *ctrl, int argc, char *argv[])
 {
 	return wpa_cli_cmd(ctrl, "BSS", 1, argc, argv);
@@ -2818,13 +2801,6 @@ static int wpa_cli_cmd_mac_rand_scan(struct wpa_ctrl *ctrl, int argc,
 }
 
 
-static int wpa_cli_cmd_get_pref_freq_list(struct wpa_ctrl *ctrl, int argc,
-					  char *argv[])
-{
-	return wpa_cli_cmd(ctrl, "GET_PREF_FREQ_LIST", 1, argc, argv);
-}
-
-
 enum wpa_cli_cmd_flags {
 	cli_cmd_flag_none		= 0x00,
 	cli_cmd_flag_sensitive		= 0x01
@@ -3003,9 +2979,6 @@ static const struct wpa_cli_cmd wpa_cli_commands[] = {
 	{ "scan_results", wpa_cli_cmd_scan_results, NULL,
 	  cli_cmd_flag_none,
 	  "= get latest scan results" },
-	{ "abort_scan", wpa_cli_cmd_abort_scan, NULL,
-	  cli_cmd_flag_none,
-	  "= request ongoing scan to be aborted" },
 	{ "bss", wpa_cli_cmd_bss, wpa_cli_complete_bss,
 	  cli_cmd_flag_none,
 	  "<<idx> | <bssid>> = get detailed scan result info" },
@@ -3382,9 +3355,6 @@ static const struct wpa_cli_cmd wpa_cli_commands[] = {
 	  "<scan|sched|pno|all> enable=<0/1> [addr=mac-address "
 	  "mask=mac-address-mask] = scan MAC randomization"
 	},
-	{ "get_pref_freq_list", wpa_cli_cmd_get_pref_freq_list, NULL,
-	  cli_cmd_flag_none,
-	  "<interface type> = retrieve preferred freq list for the specified interface type" },
 	{ NULL, NULL, NULL, cli_cmd_flag_none, NULL }
 };
 
@@ -4267,7 +4237,7 @@ int main(int argc, char *argv[])
 		return -1;
 
 	for (;;) {
-		c = getopt(argc, argv, "a:Bg:G:hi:p:P:s:v");
+		c = getopt(argc, argv, "a:Bg:G:hi:p:P:v");
 		if (c < 0)
 			break;
 		switch (c) {
@@ -4299,9 +4269,6 @@ int main(int argc, char *argv[])
 		case 'P':
 			pid_file = optarg;
 			break;
-		case 's':
-			client_socket_dir = optarg;
-			break;
 		default:
 			usage();
 			return -1;
diff --git a/wpa_supplicant/wpa_supplicant.c b/wpa_supplicant/wpa_supplicant.c
index 84a42b9..2a16c66 100644
--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -35,7 +35,6 @@
 #include "common/ieee802_11_defs.h"
 #include "common/hw_features_common.h"
 #include "p2p/p2p.h"
-#include "fst/fst.h"
 #include "blacklist.h"
 #include "wpas_glue.h"
 #include "wps_supplicant.h"
@@ -107,6 +106,9 @@ const char *const wpa_supplicant_full_license5 =
 "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
 "\n";
 #endif /* CONFIG_NO_STDOUT_DEBUG */
+#ifdef CONFIG_WAPI
+extern struct wpa_global *global_priv;
+#endif
 
 /* Configure default/group WEP keys for static WEP */
 int wpa_set_wep_keys(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid)
@@ -409,6 +411,10 @@ static void wpa_supplicant_cleanup(struct wpa_supplicant *wpa_s)
 	eapol_sm_register_scard_ctx(wpa_s->eapol, NULL);
 	l2_packet_deinit(wpa_s->l2);
 	wpa_s->l2 = NULL;
+#ifdef CONFIG_WAPI
+	l2_packet_deinit(wpa_s->l2_wapi);
+	wpa_s->l2_wapi = NULL;
+#endif
 	if (wpa_s->l2_br) {
 		l2_packet_deinit(wpa_s->l2_br);
 		wpa_s->l2_br = NULL;
@@ -1694,8 +1700,6 @@ void wpa_supplicant_associate(struct wpa_supplicant *wpa_s,
 		return;
 	}
 
-	wpas_abort_ongoing_scan(wpa_s);
-
 	cwork = os_zalloc(sizeof(*cwork));
 	if (cwork == NULL)
 		return;
@@ -1729,10 +1733,8 @@ void ibss_mesh_setup_freq(struct wpa_supplicant *wpa_s,
 	struct hostapd_channel_data *pri_chan = NULL, *sec_chan = NULL;
 	u8 channel;
 	int i, chan_idx, ht40 = -1, res, obss_scan = 1;
-	unsigned int j, k;
+	unsigned int j;
 	struct hostapd_freq_params vht_freq;
-	int chwidth, seg0, seg1;
-	u32 vht_caps = 0;
 
 	freq->freq = ssid->frequency;
 
@@ -1918,45 +1920,12 @@ void ibss_mesh_setup_freq(struct wpa_supplicant *wpa_s,
 			return;
 	}
 
-	chwidth = VHT_CHANWIDTH_80MHZ;
-	seg0 = vht80[j] + 6;
-	seg1 = 0;
-
-	if (ssid->max_oper_chwidth == VHT_CHANWIDTH_80P80MHZ) {
-		/* setup center_freq2, bandwidth */
-		for (k = 0; k < ARRAY_SIZE(vht80); k++) {
-			/* Only accept 80 MHz segments separated by a gap */
-			if (j == k || abs(vht80[j] - vht80[k]) == 16)
-				continue;
-			for (i = vht80[k]; i < vht80[k] + 16; i += 4) {
-				struct hostapd_channel_data *chan;
-
-				chan = hw_get_channel_chan(mode, i, NULL);
-				if (!chan)
-					continue;
-
-				if (chan->flag & (HOSTAPD_CHAN_DISABLED |
-						  HOSTAPD_CHAN_NO_IR |
-						  HOSTAPD_CHAN_RADAR))
-					continue;
-
-				/* Found a suitable second segment for 80+80 */
-				chwidth = VHT_CHANWIDTH_80P80MHZ;
-				vht_caps |=
-					VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ;
-				seg1 = vht80[k] + 6;
-			}
-
-			if (chwidth == VHT_CHANWIDTH_80P80MHZ)
-				break;
-		}
-	}
-
 	if (hostapd_set_freq_params(&vht_freq, mode->mode, freq->freq,
 				    freq->channel, freq->ht_enabled,
 				    vht_freq.vht_enabled,
 				    freq->sec_channel_offset,
-				    chwidth, seg0, seg1, vht_caps) != 0)
+				    VHT_CHANWIDTH_80MHZ,
+				    vht80[j] + 6, 0, 0) != 0)
 		return;
 
 	*freq = vht_freq;
@@ -2004,8 +1973,7 @@ static void wpas_start_assoc_cb(struct wpa_radio_work *work, int deinit)
 
 	wpa_s->connect_work = work;
 
-	if (cwork->bss_removed || !wpas_valid_bss_ssid(wpa_s, bss, ssid) ||
-	    wpas_network_disabled(wpa_s, ssid)) {
+	if (cwork->bss_removed || !wpas_valid_bss_ssid(wpa_s, bss, ssid)) {
 		wpa_dbg(wpa_s, MSG_DEBUG, "BSS/SSID entry for association not valid anymore - drop connection attempt");
 		wpas_connect_work_done(wpa_s);
 		return;
@@ -2054,14 +2022,77 @@ static void wpas_start_assoc_cb(struct wpa_radio_work *work, int deinit)
 			wpa_ssid_txt(ssid->ssid, ssid->ssid_len));
 		os_memset(wpa_s->pending_bssid, 0, ETH_ALEN);
 	}
+	wpa_supplicant_cancel_sched_scan(wpa_s);
+	wpa_supplicant_cancel_scan(wpa_s);
 
-#ifdef ANDROID
-	if (!wpa_s->pno)
-#endif
-		wpa_supplicant_cancel_sched_scan(wpa_s);
+#ifdef CONFIG_WAPI
+	if (ssid->proto & WPA_PROTO_WAPI) { /* associating to a WAPI network */
+		/* Begin of initialize wapi lib parameters */
+		CNTAP_PARA lib_param;
+		char *wapi_cert_name = "/data/misc/wifi/wapi_merge.cer";
+		if (ssid->key_mgmt & WPA_KEY_MGMT_WAPI_CERT) lib_param.authType = AUTH_TYPE_WAPI;
+		else if (ssid->key_mgmt & WPA_KEY_MGMT_WAPI_PSK) lib_param.authType = AUTH_TYPE_WAPI_PSK;
+		else lib_param.authType = AUTH_TYPE_NONE_WAPI;
+		if (ssid->key_mgmt & WPA_KEY_MGMT_WAPI_CERT) {
+			if ( (ssid->wapi_as_cert) && (ssid->wapi_user_cert) ) {
+				/* create merged cert using the specific file name */
+				if (wapi_merge_cert_files(ssid->wapi_as_cert, ssid->wapi_user_cert, wapi_cert_name)) {
+					wpa_printf(MSG_ERROR, "%s: wapi_merge_cert_files() failed, exit...\n", __FUNCTION__);
+					wpas_connect_work_done(wpa_s);
+					return;
+				}
+				/* merge the as.cer with user.cer to make a mixed.cer */
+				change_cert_format(wapi_cert_name, lib_param.para.user, 2048, lib_param.para.as, 2048);
+			} else {
+				wpas_connect_work_done(wpa_s);
+				wpa_printf(MSG_ERROR, "WAPI: %s: wapi cert mode but no enough cert files, quit association\n", __FUNCTION__);
+				return;
+			}
+		}
+		if (ssid->key_mgmt & WPA_KEY_MGMT_WAPI_PSK) {
+			if(ssid->passphrase == NULL) return;
+			lib_param.para.kt = ssid->psk_key_type;
+			lib_param.para.kl = strlen(ssid->passphrase);
+			memcpy(lib_param.para.kv, ssid->passphrase, lib_param.para.kl);
+		}
+		if (WAI_CNTAPPARA_SET(&lib_param) != 0) {
+			wpa_printf(MSG_DEBUG, "WAPI: %s: WAI_CNTAPPARA_SET error\n", __FUNCTION__);
+			wpas_connect_work_done(wpa_s);
+			return;
+		}
+		/* End of initialize wapi lib parameters */
 
-	wpa_supplicant_cancel_scan(wpa_s);
+		if (bss) {
+			/* set parameters to driver */
+			params.ssid = bss->ssid;
+			params.ssid_len = bss->ssid_len;
+			params.bssid = bss->bssid;
+			params.freq.freq = bss->freq;
+			params.mode = ssid->mode;
+			params.auth_alg = ssid->auth_alg;
+			params.wpa_proto = ssid->proto;
+			params.key_mgmt_suite = ssid->key_mgmt;
+			params.pairwise_suite = WPA_CIPHER_SMS4;
+			params.group_suite = WPA_CIPHER_SMS4;
+			params.wpa_ie = wpa_s->assoc_wapi_ie;
+			params.wpa_ie_len = wpa_s->assoc_wapi_ie_len;
+		} else {
+			wpa_printf(MSG_DEBUG, "bss=null\n");
+			wpas_connect_work_done(wpa_s);
+			return;
+		}
 
+		if (!memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN)) {
+			wpa_supplicant_req_auth_timeout(wpa_s, 20, 0);
+			wpa_supplicant_set_state(wpa_s, WPA_ASSOCIATING);
+			if (wpa_drv_associate(wpa_s, &params))
+				wpa_printf(MSG_ERROR, "WAPI: wapi_drv_associate() failed\n");
+		}
+		wpa_s->current_ssid = ssid;
+		wpa_s->current_bss = bss;
+		return;
+	}
+#endif
 	/* Starting new association, so clear the possibly used WPA IE from the
 	 * previous association. */
 	wpa_sm_set_assoc_wpa_ie(wpa_s->wpa, NULL, 0);
@@ -2232,18 +2263,6 @@ static void wpas_start_assoc_cb(struct wpa_radio_work *work, int deinit)
 		}
 	}
 
-#ifdef CONFIG_FST
-	if (wpa_s->fst_ies) {
-		int fst_ies_len = wpabuf_len(wpa_s->fst_ies);
-
-		if (wpa_ie_len + fst_ies_len <= sizeof(wpa_ie)) {
-			os_memcpy(wpa_ie + wpa_ie_len,
-				  wpabuf_head(wpa_s->fst_ies), fst_ies_len);
-			wpa_ie_len += fst_ies_len;
-		}
-	}
-#endif /* CONFIG_FST */
-
 	wpa_clear_keys(wpa_s, bss ? bss->bssid : NULL);
 	use_crypt = 1;
 	cipher_pairwise = wpa_s->pairwise_cipher;
@@ -2294,18 +2313,11 @@ static void wpas_start_assoc_cb(struct wpa_radio_work *work, int deinit)
 			params.bssid = bss->bssid;
 			params.freq.freq = bss->freq;
 		}
-#ifdef MTK_HARDWARE
-		else {
-  			params.freq.freq = bss->freq;
-		}
-#endif
 		params.bssid_hint = bss->bssid;
 		params.freq_hint = bss->freq;
-		params.pbss = bss_is_pbss(bss);
 	} else {
 		params.ssid = ssid->ssid;
 		params.ssid_len = ssid->ssid_len;
-		params.pbss = (ssid->pbss != 2) ? ssid->pbss : 0;
 	}
 
 	if (ssid->mode == WPAS_MODE_IBSS && ssid->bssid_set &&
@@ -2389,8 +2401,8 @@ static void wpas_start_assoc_cb(struct wpa_radio_work *work, int deinit)
 
 	params.p2p = ssid->p2p_group;
 
-	if (wpa_s->p2pdev->set_sta_uapsd)
-		params.uapsd = wpa_s->p2pdev->sta_uapsd;
+	if (wpa_s->parent->set_sta_uapsd)
+		params.uapsd = wpa_s->parent->sta_uapsd;
 	else
 		params.uapsd = -1;
 
@@ -2688,9 +2700,6 @@ void wpa_supplicant_disable_network(struct wpa_supplicant *wpa_s,
 	}
 }
 
-#ifdef MTK_HARDWARE
-extern int wpa_supplicant_pending_scan(struct wpa_supplicant *wpa_s);
-#endif
 
 /**
  * wpa_supplicant_select_network - Attempt association with a network
@@ -2733,8 +2742,7 @@ void wpa_supplicant_select_network(struct wpa_supplicant *wpa_s,
 			wpas_notify_network_enabled_changed(wpa_s, other_ssid);
 	}
 
-	if (ssid && ssid == wpa_s->current_ssid && wpa_s->current_ssid &&
-	    wpa_s->wpa_state >= WPA_AUTHENTICATING) {
+	if (ssid && ssid == wpa_s->current_ssid && wpa_s->current_ssid) {
 		/* We are already associated with the selected network */
 		wpa_printf(MSG_DEBUG, "Already associated with the "
 			   "selected network - do nothing");
@@ -2759,27 +2767,10 @@ void wpa_supplicant_select_network(struct wpa_supplicant *wpa_s,
 
 	wpa_s->disconnected = 0;
 	wpa_s->reassociate = 1;
-#ifdef MTK_HARDWARE
-       if (wpa_s->connect_without_scan ||
-		       wpa_supplicant_fast_associate(wpa_s) != 1) {
-	       /*
-		* Can't connect to AP when WFD is connected.
-		*/
-	       if (radio_work_pending(wpa_s, "scan") ||
-			       wpa_supplicant_pending_scan(wpa_s)) {
-		       wpa_printf(MSG_INFO, "[channel conflict revise] there're pending"
-				       " scan request, clear it");
-		       wpa_supplicant_cancel_scan(wpa_s);
-		       /* radio_remove_works(wpa_s, "scan", 0); */
-		       wpa_s->scan_res_handler = NULL;
-	       }
-	       wpa_supplicant_req_scan(wpa_s, 0, disconnected ? 100000 : 0);
-       }
-#else
+
 	if (wpa_s->connect_without_scan ||
 	    wpa_supplicant_fast_associate(wpa_s) != 1)
 		wpa_supplicant_req_scan(wpa_s, 0, disconnected ? 100000 : 0);
-#endif
 
 	if (ssid)
 		wpas_notify_network_selected(wpa_s, ssid);
@@ -3340,6 +3331,19 @@ int wpa_supplicant_driver_init(struct wpa_supplicant *wpa_s)
 	if (wpa_supplicant_update_mac_addr(wpa_s) < 0)
 		return -1;
 
+#ifdef CONFIG_WAPI
+		if(os_strcmp(wpa_s->ifname,"wlan0") == 0) {
+			/*wapi only works under station mode*/
+			wpa_printf(MSG_DEBUG, "WAPI: Create layer2 socket for WAI TX/RX ");
+			wpa_s->l2_wapi = l2_packet_init(wpa_s->ifname,
+							wpa_drv_get_mac_addr(wpa_s),
+							ETH_P_WAI,
+							wapi_rx_wai, wpa_s, 0);
+			if (wpa_s->l2_wapi == NULL)
+				return -1;
+		}
+#endif
+
 	wpa_dbg(wpa_s, MSG_DEBUG, "Own MAC address: " MACSTR,
 		MAC2STR(wpa_s->own_addr));
 	os_memcpy(wpa_s->perm_addr, wpa_s->own_addr, ETH_ALEN);
@@ -3411,7 +3415,6 @@ wpa_supplicant_alloc(struct wpa_supplicant *parent)
 	wpa_s->scan_interval = 5;
 	wpa_s->new_connection = 1;
 	wpa_s->parent = parent ? parent : wpa_s;
-	wpa_s->p2pdev = wpa_s->parent;
 	wpa_s->sched_scanning = 0;
 
 	return wpa_s;
@@ -3785,124 +3788,6 @@ int wpas_init_ext_pw(struct wpa_supplicant *wpa_s)
 }
 
 
-#ifdef CONFIG_FST
-
-static const u8 * wpas_fst_get_bssid_cb(void *ctx)
-{
-	struct wpa_supplicant *wpa_s = ctx;
-
-	return (is_zero_ether_addr(wpa_s->bssid) ||
-		wpa_s->wpa_state != WPA_COMPLETED) ? NULL : wpa_s->bssid;
-}
-
-
-static void wpas_fst_get_channel_info_cb(void *ctx,
-					 enum hostapd_hw_mode *hw_mode,
-					 u8 *channel)
-{
-	struct wpa_supplicant *wpa_s = ctx;
-
-	if (wpa_s->current_bss) {
-		*hw_mode = ieee80211_freq_to_chan(wpa_s->current_bss->freq,
-						  channel);
-	} else if (wpa_s->hw.num_modes) {
-		*hw_mode = wpa_s->hw.modes[0].mode;
-	} else {
-		WPA_ASSERT(0);
-		*hw_mode = 0;
-	}
-}
-
-
-static int wpas_fst_get_hw_modes(void *ctx, struct hostapd_hw_modes **modes)
-{
-	struct wpa_supplicant *wpa_s = ctx;
-
-	*modes = wpa_s->hw.modes;
-	return wpa_s->hw.num_modes;
-}
-
-
-static void wpas_fst_set_ies_cb(void *ctx, const struct wpabuf *fst_ies)
-{
-	struct wpa_supplicant *wpa_s = ctx;
-
-	wpa_hexdump_buf(MSG_DEBUG, "FST: Set IEs", fst_ies);
-	wpa_s->fst_ies = fst_ies;
-}
-
-
-static int wpas_fst_send_action_cb(void *ctx, const u8 *da, struct wpabuf *data)
-{
-	struct wpa_supplicant *wpa_s = ctx;
-
-	WPA_ASSERT(os_memcmp(wpa_s->bssid, da, ETH_ALEN) == 0);
-	return wpa_drv_send_action(wpa_s, wpa_s->assoc_freq, 0, wpa_s->bssid,
-					  wpa_s->own_addr, wpa_s->bssid,
-					  wpabuf_head(data), wpabuf_len(data),
-				   0);
-}
-
-
-static const struct wpabuf * wpas_fst_get_mb_ie_cb(void *ctx, const u8 *addr)
-{
-	struct wpa_supplicant *wpa_s = ctx;
-
-	WPA_ASSERT(os_memcmp(wpa_s->bssid, addr, ETH_ALEN) == 0);
-	return wpa_s->received_mb_ies;
-}
-
-
-static void wpas_fst_update_mb_ie_cb(void *ctx, const u8 *addr,
-				     const u8 *buf, size_t size)
-{
-	struct wpa_supplicant *wpa_s = ctx;
-	struct mb_ies_info info;
-
-	WPA_ASSERT(os_memcmp(wpa_s->bssid, addr, ETH_ALEN) == 0);
-
-	if (!mb_ies_info_by_ies(&info, buf, size)) {
-		wpabuf_free(wpa_s->received_mb_ies);
-		wpa_s->received_mb_ies = mb_ies_by_info(&info);
-	}
-}
-
-
-const u8 * wpas_fst_get_peer_first(void *ctx, struct fst_get_peer_ctx **get_ctx,
-				   Boolean mb_only)
-{
-	struct wpa_supplicant *wpa_s = ctx;
-
-	*get_ctx = NULL;
-	if (!is_zero_ether_addr(wpa_s->bssid))
-		return (wpa_s->received_mb_ies || !mb_only) ?
-			wpa_s->bssid : NULL;
-	return NULL;
-}
-
-
-const u8 * wpas_fst_get_peer_next(void *ctx, struct fst_get_peer_ctx **get_ctx,
-				  Boolean mb_only)
-{
-	return NULL;
-}
-
-void fst_wpa_supplicant_fill_iface_obj(struct wpa_supplicant *wpa_s,
-				       struct fst_wpa_obj *iface_obj)
-{
-	iface_obj->ctx              = wpa_s;
-	iface_obj->get_bssid        = wpas_fst_get_bssid_cb;
-	iface_obj->get_channel_info = wpas_fst_get_channel_info_cb;
-	iface_obj->get_hw_modes     = wpas_fst_get_hw_modes;
-	iface_obj->set_ies          = wpas_fst_set_ies_cb;
-	iface_obj->send_action      = wpas_fst_send_action_cb;
-	iface_obj->get_mb_ie        = wpas_fst_get_mb_ie_cb;
-	iface_obj->update_mb_ie     = wpas_fst_update_mb_ie_cb;
-	iface_obj->get_peer_first   = wpas_fst_get_peer_first;
-	iface_obj->get_peer_next    = wpas_fst_get_peer_next;
-}
-#endif /* CONFIG_FST */
-
 static int wpas_set_wowlan_triggers(struct wpa_supplicant *wpa_s,
 				    const struct wpa_driver_capa *capa)
 {
@@ -3921,55 +3806,6 @@ static int wpas_set_wowlan_triggers(struct wpa_supplicant *wpa_s,
 }
 
 
-enum wpa_radio_work_band wpas_freq_to_band(int freq)
-{
-	if (freq < 3000)
-		return BAND_2_4_GHZ;
-	if (freq > 50000)
-		return BAND_60_GHZ;
-	return BAND_5_GHZ;
-}
-
-
-unsigned int wpas_get_bands(struct wpa_supplicant *wpa_s, const int *freqs)
-{
-	int i;
-	unsigned int band = 0;
-
-	if (freqs) {
-		/* freqs are specified for the radio work */
-		for (i = 0; freqs[i]; i++)
-			band |= wpas_freq_to_band(freqs[i]);
-	} else {
-		/*
-		 * freqs are not specified, implies all
-		 * the supported freqs by HW
-		 */
-		for (i = 0; i < wpa_s->hw.num_modes; i++) {
-			if (wpa_s->hw.modes[i].num_channels != 0) {
-				if (wpa_s->hw.modes[i].mode ==
-				    HOSTAPD_MODE_IEEE80211B ||
-				    wpa_s->hw.modes[i].mode ==
-				    HOSTAPD_MODE_IEEE80211G)
-					band |= BAND_2_4_GHZ;
-				else if (wpa_s->hw.modes[i].mode ==
-					 HOSTAPD_MODE_IEEE80211A)
-					band |= BAND_5_GHZ;
-				else if (wpa_s->hw.modes[i].mode ==
-					 HOSTAPD_MODE_IEEE80211AD)
-					band |= BAND_60_GHZ;
-				else if (wpa_s->hw.modes[i].mode ==
-					 HOSTAPD_MODE_IEEE80211ANY)
-					band = BAND_2_4_GHZ | BAND_5_GHZ |
-						BAND_60_GHZ;
-			}
-		}
-	}
-
-	return band;
-}
-
-
 static struct wpa_radio * radio_add_interface(struct wpa_supplicant *wpa_s,
 					      const char *rn)
 {
@@ -4022,103 +3858,11 @@ static void radio_work_free(struct wpa_radio_work *work)
 	}
 #endif /* CONFIG_P2P */
 
-	if (work->started) {
-		work->wpa_s->radio->num_active_works--;
-		wpa_dbg(work->wpa_s, MSG_DEBUG,
-			"radio_work_free('%s'@%p: num_active_works --> %u",
-			work->type, work,
-			work->wpa_s->radio->num_active_works);
-	}
-
 	dl_list_del(&work->list);
 	os_free(work);
 }
 
 
-static struct wpa_radio_work * radio_work_get_next_work(struct wpa_radio *radio)
-{
-	struct wpa_radio_work *active_work = NULL;
-	struct wpa_radio_work *tmp;
-
-	/* Get the active work to know the type and band. */
-	dl_list_for_each(tmp, &radio->work, struct wpa_radio_work, list) {
-		if (tmp->started) {
-			active_work = tmp;
-			break;
-		}
-	}
-
-	if (!active_work) {
-		/* No active work, start one */
-		radio->num_active_works = 0;
-		dl_list_for_each(tmp, &radio->work, struct wpa_radio_work,
-				 list) {
-			if (os_strcmp(tmp->type, "scan") == 0 &&
-			    radio->external_scan_running &&
-			    (((struct wpa_driver_scan_params *)
-			      tmp->ctx)->only_new_results ||
-			     tmp->wpa_s->clear_driver_scan_cache))
-				continue;
-			return tmp;
-		}
-		return NULL;
-	}
-
-	if (os_strcmp(active_work->type, "sme-connect") == 0 ||
-	    os_strcmp(active_work->type, "connect") == 0) {
-		/*
-		 * If the active work is either connect or sme-connect,
-		 * do not parallelize them with other radio works.
-		 */
-		wpa_dbg(active_work->wpa_s, MSG_DEBUG,
-			"Do not parallelize radio work with %s",
-			active_work->type);
-		return NULL;
-	}
-
-	dl_list_for_each(tmp, &radio->work, struct wpa_radio_work, list) {
-		if (tmp->started)
-			continue;
-
-		/*
-		 * If connect or sme-connect are enqueued, parallelize only
-		 * those operations ahead of them in the queue.
-		 */
-		if (os_strcmp(tmp->type, "connect") == 0 ||
-		    os_strcmp(tmp->type, "sme-connect") == 0)
-			break;
-
-		/*
-		 * Check that the radio works are distinct and
-		 * on different bands.
-		 */
-		if (os_strcmp(active_work->type, tmp->type) != 0 &&
-		    (active_work->bands != tmp->bands)) {
-			/*
-			 * If a scan has to be scheduled through nl80211 scan
-			 * interface and if an external scan is already running,
-			 * do not schedule the scan since it is likely to get
-			 * rejected by kernel.
-			 */
-			if (os_strcmp(tmp->type, "scan") == 0 &&
-			    radio->external_scan_running &&
-			    (((struct wpa_driver_scan_params *)
-			      tmp->ctx)->only_new_results ||
-			     tmp->wpa_s->clear_driver_scan_cache))
-				continue;
-
-			wpa_dbg(active_work->wpa_s, MSG_DEBUG,
-				"active_work:%s new_work:%s",
-				active_work->type, tmp->type);
-			return tmp;
-		}
-	}
-
-	/* Did not find a radio work to schedule in parallel. */
-	return NULL;
-}
-
-
 static void radio_start_next_work(void *eloop_ctx, void *timeout_ctx)
 {
 	struct wpa_radio *radio = eloop_ctx;
@@ -4127,48 +3871,26 @@ static void radio_start_next_work(void *eloop_ctx, void *timeout_ctx)
 	struct wpa_supplicant *wpa_s;
 
 	work = dl_list_first(&radio->work, struct wpa_radio_work, list);
-	if (work == NULL) {
-		radio->num_active_works = 0;
+	if (work == NULL)
 		return;
-	}
+
+	if (work->started)
+		return; /* already started and still in progress */
 
 	wpa_s = dl_list_first(&radio->ifaces, struct wpa_supplicant,
 			      radio_list);
-
-	if (!(wpa_s &&
-	      wpa_s->drv_flags & WPA_DRIVER_FLAGS_OFFCHANNEL_SIMULTANEOUS)) {
-		if (work->started)
-			return; /* already started and still in progress */
-
-		if (wpa_s && wpa_s->radio->external_scan_running) {
-			wpa_printf(MSG_DEBUG, "Delay radio work start until externally triggered scan completes");
-			return;
-		}
-	} else {
-		work = NULL;
-		if (radio->num_active_works < MAX_ACTIVE_WORKS) {
-			/* get the work to schedule next */
-			work = radio_work_get_next_work(radio);
-		}
-		if (!work)
-			return;
+	if (wpa_s && wpa_s->radio->external_scan_running) {
+		wpa_printf(MSG_DEBUG, "Delay radio work start until externally triggered scan completes");
+		return;
 	}
 
-	wpa_s = work->wpa_s;
 	os_get_reltime(&now);
 	os_reltime_sub(&now, &work->time, &diff);
-	wpa_dbg(wpa_s, MSG_DEBUG,
-		"Starting radio work '%s'@%p after %ld.%06ld second wait",
+	wpa_dbg(work->wpa_s, MSG_DEBUG, "Starting radio work '%s'@%p after %ld.%06ld second wait",
 		work->type, work, diff.sec, diff.usec);
 	work->started = 1;
 	work->time = now;
-	radio->num_active_works++;
-
 	work->cb(work, 0);
-
-	if ((wpa_s->drv_flags & WPA_DRIVER_FLAGS_OFFCHANNEL_SIMULTANEOUS) &&
-	    radio->num_active_works < MAX_ACTIVE_WORKS)
-		radio_work_check_next(wpa_s);
 }
 
 
@@ -4276,7 +3998,6 @@ int radio_add_work(struct wpa_supplicant *wpa_s, unsigned int freq,
 		   void (*cb)(struct wpa_radio_work *work, int deinit),
 		   void *ctx)
 {
-	struct wpa_radio *radio = wpa_s->radio;
 	struct wpa_radio_work *work;
 	int was_empty;
 
@@ -4291,16 +4012,6 @@ int radio_add_work(struct wpa_supplicant *wpa_s, unsigned int freq,
 	work->cb = cb;
 	work->ctx = ctx;
 
-	if (freq)
-		work->bands = wpas_freq_to_band(freq);
-	else if (os_strcmp(type, "scan") == 0 ||
-		 os_strcmp(type, "p2p-scan") == 0)
-		work->bands = wpas_get_bands(wpa_s,
-					     ((struct wpa_driver_scan_params *)
-					      ctx)->freqs);
-	else
-		work->bands = wpas_get_bands(wpa_s, NULL);
-
 	was_empty = dl_list_empty(&wpa_s->radio->work);
 	if (next)
 		dl_list_add(&wpa_s->radio->work, &work->list);
@@ -4309,12 +4020,6 @@ int radio_add_work(struct wpa_supplicant *wpa_s, unsigned int freq,
 	if (was_empty) {
 		wpa_dbg(wpa_s, MSG_DEBUG, "First radio work item in the queue - schedule start immediately");
 		radio_work_check_next(wpa_s);
-	} else if ((wpa_s->drv_flags & WPA_DRIVER_FLAGS_OFFCHANNEL_SIMULTANEOUS)
-		   && radio->num_active_works < MAX_ACTIVE_WORKS) {
-		wpa_dbg(wpa_s, MSG_DEBUG,
-			"Try to schedule a radio work (num_active_works=%u)",
-			radio->num_active_works);
-		radio_work_check_next(wpa_s);
 	}
 
 	return 0;
@@ -4437,6 +4142,15 @@ static int wpa_supplicant_init_iface(struct wpa_supplicant *wpa_s,
 		wpa_s->confname = os_strdup(iface->confname);
 #endif /* CONFIG_BACKEND_FILE */
 		wpa_s->conf = wpa_config_read(wpa_s->confname, NULL);
+#ifdef CONFIG_WAPI
+		if(os_strcmp(iface->ifname, "wlan0") == 0) {
+			wpa_printf(MSG_DEBUG, "WAPI:  WIFI_lib_init \n");
+			if (WIFI_lib_init()) {
+				wpa_printf(MSG_ERROR, "WAPI: WIFI_lib_init failed\n");
+				return -1;
+			}
+		}
+#endif
 		if (wpa_s->conf == NULL) {
 			wpa_printf(MSG_ERROR, "Failed to read or parse "
 				   "configuration '%s'.", wpa_s->confname);
@@ -4621,28 +4335,6 @@ static int wpa_supplicant_init_iface(struct wpa_supplicant *wpa_s,
 		return -1;
 	}
 
-#ifdef CONFIG_FST
-	if (wpa_s->conf->fst_group_id) {
-		struct fst_iface_cfg cfg;
-		struct fst_wpa_obj iface_obj;
-
-		fst_wpa_supplicant_fill_iface_obj(wpa_s, &iface_obj);
-		os_strlcpy(cfg.group_id, wpa_s->conf->fst_group_id,
-			   sizeof(cfg.group_id));
-		cfg.priority = wpa_s->conf->fst_priority;
-		cfg.llt = wpa_s->conf->fst_llt;
-
-		wpa_s->fst = fst_attach(wpa_s->ifname, wpa_s->own_addr,
-					&iface_obj, &cfg);
-		if (!wpa_s->fst) {
-			wpa_msg(wpa_s, MSG_ERROR,
-				"FST: Cannot attach iface %s to group %s",
-				wpa_s->ifname, cfg.group_id);
-			return -1;
-		}
-	}
-#endif /* CONFIG_FST */
-
 	if (wpas_wps_init(wpa_s))
 		return -1;
 
@@ -4724,8 +4416,6 @@ static void wpa_supplicant_deinit_iface(struct wpa_supplicant *wpa_s,
 
 	iface = global->ifaces;
 	while (iface) {
-		if (iface->p2pdev == wpa_s)
-			iface->p2pdev = iface->parent;
 		if (iface == wpa_s || iface->parent != wpa_s) {
 			iface = iface->next;
 			continue;
@@ -4753,17 +4443,6 @@ static void wpa_supplicant_deinit_iface(struct wpa_supplicant *wpa_s,
 	wpas_ctrl_radio_work_flush(wpa_s);
 	radio_remove_interface(wpa_s);
 
-#ifdef CONFIG_FST
-	if (wpa_s->fst) {
-		fst_detach(wpa_s->fst);
-		wpa_s->fst = NULL;
-	}
-	if (wpa_s->received_mb_ies) {
-		wpabuf_free(wpa_s->received_mb_ies);
-		wpa_s->received_mb_ies = NULL;
-	}
-#endif /* CONFIG_FST */
-
 	if (wpa_s->drv_priv)
 		wpa_drv_deinit(wpa_s);
 
@@ -5070,11 +4749,9 @@ struct wpa_global * wpa_supplicant_init(struct wpa_params *params)
 	if (params->override_ctrl_interface)
 		global->params.override_ctrl_interface =
 			os_strdup(params->override_ctrl_interface);
-#ifdef CONFIG_P2P
 	if (params->conf_p2p_dev)
 		global->params.conf_p2p_dev =
 			os_strdup(params->conf_p2p_dev);
-#endif /* CONFIG_P2P */
 	wpa_debug_level = global->params.wpa_debug_level =
 		params->wpa_debug_level;
 	wpa_debug_show_keys = global->params.wpa_debug_show_keys =
@@ -5084,6 +4761,9 @@ struct wpa_global * wpa_supplicant_init(struct wpa_params *params)
 
 	wpa_printf(MSG_DEBUG, "wpa_supplicant v" VERSION_STR);
 
+#ifdef CONFIG_WAPI
+	global_priv = global;
+#endif
 	if (eloop_init()) {
 		wpa_printf(MSG_ERROR, "Failed to initialize event loop");
 		wpa_supplicant_deinit(global);
@@ -5175,6 +4855,9 @@ void wpa_supplicant_deinit(struct wpa_global *global)
 	if (global == NULL)
 		return;
 
+#ifdef CONFIG_WAPI
+	WIFI_lib_exit();
+#endif
 #ifdef CONFIG_WIFI_DISPLAY
 	wifi_display_deinit(global);
 #endif /* CONFIG_WIFI_DISPLAY */
@@ -5211,9 +4894,7 @@ void wpa_supplicant_deinit(struct wpa_global *global)
 	os_free(global->params.ctrl_interface_group);
 	os_free(global->params.override_driver);
 	os_free(global->params.override_ctrl_interface);
-#ifdef CONFIG_P2P
 	os_free(global->params.conf_p2p_dev);
-#endif /* CONFIG_P2P */
 
 	os_free(global->p2p_disallow_freq.range);
 	os_free(global->p2p_go_avoid_freq.range);
@@ -5428,11 +5109,7 @@ int wpa_supplicant_ctrl_iface_ctrl_rsp_handle(struct wpa_supplicant *wpa_s,
 		eap->identity = (u8 *) os_strdup(value);
 		eap->identity_len = os_strlen(value);
 		eap->pending_req_identity = 0;
-		if (ssid == wpa_s->current_ssid
-#ifndef CONFIG_EAP_PROXY
-			&& wpa_s->wpa_state < WPA_ASSOCIATING
-#endif
-		)
+		if (ssid == wpa_s->current_ssid)
 			wpa_s->reassociate = 1;
 		break;
 	case WPA_CTRL_REQ_EAP_PASSWORD:
@@ -6072,4 +5749,3 @@ void wpas_rrm_handle_link_measurement_request(struct wpa_supplicant *wpa_s,
 	}
 	wpabuf_free(buf);
 }
-
diff --git a/wpa_supplicant/wpa_supplicant.conf b/wpa_supplicant/wpa_supplicant.conf
index af6684b..d380965 100644
--- a/wpa_supplicant/wpa_supplicant.conf
+++ b/wpa_supplicant/wpa_supplicant.conf
@@ -654,17 +654,6 @@ fast_reauth=1
 # an IBSS network with the configured SSID is already present, the frequency of
 # the network will be used instead of this configured value.
 #
-# pbss: Whether to use PBSS. Relevant to IEEE 802.11ad networks only.
-# 0 = do not use PBSS
-# 1 = use PBSS
-# 2 = don't care (not allowed in AP mode)
-# Used together with mode configuration. When mode is AP, it means to start a
-# PCP instead of a regular AP. When mode is infrastructure it means connect
-# to a PCP instead of AP. In this mode you can also specify 2 (don't care)
-# which means connect to either PCP or AP.
-# P2P_GO and P2P_GROUP_FORMATION modes must use PBSS in IEEE 802.11ad network.
-# For more details, see IEEE Std 802.11ad-2012.
-#
 # scan_freq: List of frequencies to scan
 # Space-separated list of frequencies in MHz to scan when searching for this
 # BSS. If the subset of channels used by the network is known, this option can
@@ -1147,32 +1136,6 @@ fast_reauth=1
 #  2: MCS 0-9
 #  3: not supported
 
-##### Fast Session Transfer (FST) support #####################################
-#
-# The options in this section are only available when the build configuration
-# option CONFIG_FST is set while compiling hostapd. They allow this interface
-# to be a part of FST setup.
-#
-# FST is the transfer of a session from a channel to another channel, in the
-# same or different frequency bands.
-#
-# For detals, see IEEE Std 802.11ad-2012.
-
-# Identifier of an FST Group  the interface belongs to.
-#fst_group_id=bond0
-
-# Interface priority within the FST Group.
-# Announcing a higher priority for an interface means declaring it more
-# preferable for FST switch.
-# fst_priority is in 1..255 range with 1 being the lowest priority.
-#fst_priority=100
-
-# Default LLT value for this interface in milliseconds. The value used in case
-# no value provided during session setup. Default is 50 msec.
-# fst_llt is in 1..4294967 range (due to spec limitation, see 10.32.2.2
-# Transitioning between states).
-#fst_llt=100
-
 # Example blocks:
 
 # Simple case: WPA-PSK, PSK as an ASCII passphrase, allow all valid ciphers
diff --git a/wpa_supplicant/wpa_supplicant_conf.mk b/wpa_supplicant/wpa_supplicant_conf.mk
index 8a5aca7..74986ea 100644
--- a/wpa_supplicant/wpa_supplicant_conf.mk
+++ b/wpa_supplicant/wpa_supplicant_conf.mk
@@ -20,7 +20,7 @@ LOCAL_MODULE_PATH := $(TARGET_OUT_ETC)/wifi
 
 include $(BUILD_SYSTEM)/base_rules.mk
 
-WPA_SUPPLICANT_CONF_TEMPLATE ?= $(LOCAL_PATH)/wpa_supplicant_template.conf
+WPA_SUPPLICANT_CONF_TEMPLATE := $(LOCAL_PATH)/wpa_supplicant_template.conf
 WPA_SUPPLICANT_CONF_SCRIPT := $(LOCAL_PATH)/wpa_supplicant_conf.sh
 $(LOCAL_BUILT_MODULE): PRIVATE_WIFI_DRIVER_SOCKET_IFACE := $(WIFI_DRIVER_SOCKET_IFACE)
 $(LOCAL_BUILT_MODULE): PRIVATE_WPA_SUPPLICANT_CONF_TEMPLATE := $(WPA_SUPPLICANT_CONF_TEMPLATE)
diff --git a/wpa_supplicant/wpa_supplicant_i.h b/wpa_supplicant/wpa_supplicant_i.h
index 852f7a6..9ea61e9 100644
--- a/wpa_supplicant/wpa_supplicant_i.h
+++ b/wpa_supplicant/wpa_supplicant_i.h
@@ -16,6 +16,11 @@
 #include "wps/wps_defs.h"
 #include "config_ssid.h"
 #include "wmm_ac.h"
+#ifdef CONFIG_WAPI
+#include "../wapi_lib/wapi_interface.h"
+#include "wapi/wapi_interface_priv.h"
+struct wpa_global *global_priv;
+#endif
 
 extern const char *const wpa_supplicant_version;
 extern const char *const wpa_supplicant_license;
@@ -225,7 +230,7 @@ struct wpa_params {
 	 * This can also be %NULL. In such a case, if a P2P Device dedicated
 	 * interfaces is created, the main configuration file will be used.
 	 */
-	char *conf_p2p_dev;
+	const char *conf_p2p_dev;
 #endif /* CONFIG_P2P */
 
 };
@@ -300,14 +305,10 @@ struct wpa_radio {
 	char name[16]; /* from driver_ops get_radio_name() or empty if not
 			* available */
 	unsigned int external_scan_running:1;
-	unsigned int num_active_works;
 	struct dl_list ifaces; /* struct wpa_supplicant::radio_list entries */
 	struct dl_list work; /* struct wpa_radio_work::list entries */
 };
 
-#define MAX_ACTIVE_WORKS 2
-
-
 /**
  * struct wpa_radio_work - Radio work item
  */
@@ -320,7 +321,6 @@ struct wpa_radio_work {
 	void *ctx;
 	unsigned int started:1;
 	struct os_reltime time;
-	unsigned int bands;
 };
 
 int radio_add_work(struct wpa_supplicant *wpa_s, unsigned int freq,
@@ -352,9 +352,6 @@ struct wpa_external_work {
 	unsigned int timeout;
 };
 
-enum wpa_radio_work_band wpas_freq_to_band(int freq);
-unsigned int wpas_get_bands(struct wpa_supplicant *wpa_s, const int *freqs);
-
 /**
  * offchannel_send_action_result - Result of offchannel send Action frame
  */
@@ -435,7 +432,6 @@ struct wpa_supplicant {
 	struct wpa_radio *radio; /* shared radio context */
 	struct dl_list radio_list; /* list head: struct wpa_radio::ifaces */
 	struct wpa_supplicant *parent;
-	struct wpa_supplicant *p2pdev;
 	struct wpa_supplicant *next;
 	struct l2_packet_data *l2;
 	struct l2_packet_data *l2_br;
@@ -491,7 +487,7 @@ struct wpa_supplicant {
 	struct wpa_ssid_value *disallow_aps_ssid;
 	size_t disallow_aps_ssid_count;
 
-	enum set_band setband;
+	enum { WPA_SETBAND_AUTO, WPA_SETBAND_5G, WPA_SETBAND_2G } setband;
 
 	/* Preferred network for the next connection attempt */
 	struct wpa_ssid *next_ssid;
@@ -602,8 +598,6 @@ struct wpa_supplicant {
 	} scan_req, last_scan_req;
 	enum wpa_states scan_prev_wpa_state;
 	struct os_reltime scan_trigger_time, scan_start_time;
-	/* Minimum freshness requirement for connection purposes */
-	struct os_reltime scan_min_time;
 	int scan_runs; /* number of scan runs since WPS was started */
 	int *next_scan_freqs;
 	int *manual_scan_freqs;
@@ -622,7 +616,6 @@ struct wpa_supplicant {
 #define MAX_SCAN_ID 16
 	int scan_id[MAX_SCAN_ID];
 	unsigned int scan_id_count;
-	u8 next_scan_bssid[ETH_ALEN];
 
 	struct wpa_ssid_value *ssids_from_scan_req;
 	unsigned int num_ssids_from_scan_req;
@@ -668,7 +661,6 @@ struct wpa_supplicant {
 	unsigned int reattach:1; /* reassociation to the same BSS requested */
 	unsigned int mac_addr_changed:1;
 	unsigned int added_vif:1;
-	unsigned int wnmsleep_used:1;
 
 	struct os_reltime last_mac_addr_change;
 	int last_mac_addr_style;
@@ -855,9 +847,6 @@ struct wpa_supplicant {
 	int *p2p_group_common_freqs;
 	unsigned int p2p_group_common_freqs_num;
 	u8 p2ps_join_addr[ETH_ALEN];
-
-	unsigned int p2p_go_max_oper_chwidth;
-	unsigned int p2p_go_vht_center_freq2;
 #endif /* CONFIG_P2P */
 
 	struct wpa_ssid *bgscan_ssid;
@@ -993,12 +982,11 @@ struct wpa_supplicant {
 	u8 last_tspecs_count;
 
 	struct rrm_data rrm;
-
-#ifdef CONFIG_FST
-	struct fst_iface *fst;
-	const struct wpabuf *fst_ies;
-	struct wpabuf *received_mb_ies;
-#endif /* CONFIG_FST */
+#ifdef CONFIG_WAPI
+	struct l2_packet_data *l2_wapi;
+	u8 assoc_wapi_ie[256];
+	u8 assoc_wapi_ie_len;
+#endif
 };
 
 
@@ -1171,14 +1159,4 @@ int get_shared_radio_freqs(struct wpa_supplicant *wpa_s,
 			   int *freq_array, unsigned int len);
 
 void wpas_network_reenabled(void *eloop_ctx, void *timeout_ctx);
-
-#ifdef CONFIG_FST
-
-struct fst_wpa_obj;
-
-void fst_wpa_supplicant_fill_iface_obj(struct wpa_supplicant *wpa_s,
-				       struct fst_wpa_obj *iface_obj);
-
-#endif /* CONFIG_FST */
-
 #endif /* WPA_SUPPLICANT_I_H */
diff --git a/wpa_supplicant/wpa_supplicant_template.conf b/wpa_supplicant/wpa_supplicant_template.conf
index f3f2a64..e337eac 100644
--- a/wpa_supplicant/wpa_supplicant_template.conf
+++ b/wpa_supplicant/wpa_supplicant_template.conf
@@ -3,4 +3,5 @@ update_config=1
 eapol_version=1
 ap_scan=1
 fast_reauth=1
-pmf=1
+p2p_no_group_iface=1
+wowlan_triggers=any
diff --git a/wpa_supplicant/wps_supplicant.c b/wpa_supplicant/wps_supplicant.c
index 09a3c05..4360f6c 100644
--- a/wpa_supplicant/wps_supplicant.c
+++ b/wpa_supplicant/wps_supplicant.c
@@ -36,7 +36,7 @@
 
 
 #ifndef WPS_PIN_SCAN_IGNORE_SEL_REG
-#define WPS_PIN_SCAN_IGNORE_SEL_REG 3
+#define WPS_PIN_SCAN_IGNORE_SEL_REG 20
 #endif /* WPS_PIN_SCAN_IGNORE_SEL_REG */
 
 /*
@@ -517,7 +517,8 @@ static int wpa_supplicant_wps_cred(void *ctx,
 	case WPS_AUTH_WPA2PSK:
 		ssid->auth_alg = WPA_AUTH_ALG_OPEN;
 		ssid->key_mgmt = WPA_KEY_MGMT_PSK;
-		ssid->proto = WPA_PROTO_RSN;
+		//handle the case of receiving the wpa2-psk credential from the wpa-psk ap
+		//ssid->proto = WPA_PROTO_RSN;
 		break;
 	}
 
@@ -583,8 +584,8 @@ static void wpa_supplicant_wps_event_m2d(struct wpa_supplicant *wpa_s,
 		m2d->dev_password_id, m2d->config_error);
 	wpas_notify_wps_event_m2d(wpa_s, m2d);
 #ifdef CONFIG_P2P
-	if (wpa_s->p2pdev && wpa_s->p2pdev != wpa_s) {
-		wpa_msg(wpa_s->p2pdev, MSG_INFO, WPS_EVENT_M2D
+	if (wpa_s->parent && wpa_s->parent != wpa_s) {
+		wpa_msg(wpa_s->parent, MSG_INFO, WPS_EVENT_M2D
 			"dev_password_id=%d config_error=%d",
 			m2d->dev_password_id, m2d->config_error);
 	}
@@ -617,8 +618,8 @@ static void wpa_supplicant_wps_event_fail(struct wpa_supplicant *wpa_s,
 			WPS_EVENT_FAIL "msg=%d config_error=%d reason=%d (%s)",
 			fail->msg, fail->config_error, fail->error_indication,
 			wps_ei_str(fail->error_indication));
-		if (wpa_s->p2pdev && wpa_s->p2pdev != wpa_s)
-			wpa_msg(wpa_s->p2pdev, MSG_INFO, WPS_EVENT_FAIL
+		if (wpa_s->parent && wpa_s->parent != wpa_s)
+			wpa_msg(wpa_s->parent, MSG_INFO, WPS_EVENT_FAIL
 				"msg=%d config_error=%d reason=%d (%s)",
 				fail->msg, fail->config_error,
 				fail->error_indication,
@@ -627,8 +628,8 @@ static void wpa_supplicant_wps_event_fail(struct wpa_supplicant *wpa_s,
 		wpa_msg(wpa_s, MSG_INFO,
 			WPS_EVENT_FAIL "msg=%d config_error=%d",
 			fail->msg, fail->config_error);
-		if (wpa_s->p2pdev && wpa_s->p2pdev != wpa_s)
-			wpa_msg(wpa_s->p2pdev, MSG_INFO, WPS_EVENT_FAIL
+		if (wpa_s->parent && wpa_s->parent != wpa_s)
+			wpa_msg(wpa_s->parent, MSG_INFO, WPS_EVENT_FAIL
 				"msg=%d config_error=%d",
 				fail->msg, fail->config_error);
 	}
@@ -683,13 +684,6 @@ static void wpas_wps_reenable_networks_cb(void *eloop_ctx, void *timeout_ctx)
 }
 
 
-int wpas_wps_reenable_networks_pending(struct wpa_supplicant *wpa_s)
-{
-	return eloop_is_timeout_registered(wpas_wps_reenable_networks_cb,
-					   wpa_s, NULL);
-}
-
-
 static void wpa_supplicant_wps_event_success(struct wpa_supplicant *wpa_s)
 {
 	wpa_msg(wpa_s, MSG_INFO, WPS_EVENT_SUCCESS);
@@ -1130,13 +1124,6 @@ int wpas_wps_start_pbc(struct wpa_supplicant *wpa_s, const u8 *bssid,
 		return -1;
 	ssid->temporary = 1;
 	ssid->p2p_group = p2p_group;
-	/*
-	 * When starting a regular WPS process (not P2P group formation)
-	 * the registrar/final station can be either AP or PCP
-	 * so use a "don't care" value for the pbss flag.
-	 */
-	if (!p2p_group)
-		ssid->pbss = 2;
 #ifdef CONFIG_P2P
 	if (p2p_group && wpa_s->go_params && wpa_s->go_params->ssid_len) {
 		ssid->ssid = os_zalloc(wpa_s->go_params->ssid_len + 1);
@@ -1144,10 +1131,6 @@ int wpas_wps_start_pbc(struct wpa_supplicant *wpa_s, const u8 *bssid,
 			ssid->ssid_len = wpa_s->go_params->ssid_len;
 			os_memcpy(ssid->ssid, wpa_s->go_params->ssid,
 				  ssid->ssid_len);
-			if (wpa_s->go_params->freq > 56160) {
-				/* P2P in 60 GHz uses PBSS */
-				ssid->pbss = 1;
-			}
 			wpa_hexdump_ascii(MSG_DEBUG, "WPS: Use specific AP "
 					  "SSID", ssid->ssid, ssid->ssid_len);
 		}
@@ -1192,13 +1175,6 @@ static int wpas_wps_start_dev_pw(struct wpa_supplicant *wpa_s,
 	}
 	ssid->temporary = 1;
 	ssid->p2p_group = p2p_group;
-	/*
-	 * When starting a regular WPS process (not P2P group formation)
-	 * the registrar/final station can be either AP or PCP
-	 * so use a "don't care" value for the pbss flag.
-	 */
-	if (!p2p_group)
-		ssid->pbss = 2;
 	if (ssid_val) {
 		ssid->ssid = os_malloc(ssid_len);
 		if (ssid->ssid) {
@@ -1222,10 +1198,6 @@ static int wpas_wps_start_dev_pw(struct wpa_supplicant *wpa_s,
 			ssid->ssid_len = wpa_s->go_params->ssid_len;
 			os_memcpy(ssid->ssid, wpa_s->go_params->ssid,
 				  ssid->ssid_len);
-			if (wpa_s->go_params->freq > 56160) {
-				/* P2P in 60 GHz uses PBSS */
-				ssid->pbss = 1;
-			}
 			wpa_hexdump_ascii(MSG_DEBUG, "WPS: Use specific AP "
 					  "SSID", ssid->ssid, ssid->ssid_len);
 		}
diff --git a/wpa_supplicant/wps_supplicant.h b/wpa_supplicant/wps_supplicant.h
index 22c5482..683bd50 100644
--- a/wpa_supplicant/wps_supplicant.h
+++ b/wpa_supplicant/wps_supplicant.h
@@ -84,7 +84,6 @@ int wpas_er_wps_nfc_report_handover(struct wpa_supplicant *wpa_s,
 void wpas_wps_update_ap_info(struct wpa_supplicant *wpa_s,
 			     struct wpa_scan_results *scan_res);
 void wpas_wps_notify_assoc(struct wpa_supplicant *wpa_s, const u8 *bssid);
-int wpas_wps_reenable_networks_pending(struct wpa_supplicant *wpa_s);
 
 #else /* CONFIG_WPS */
 
@@ -147,12 +146,6 @@ static inline void wpas_wps_notify_assoc(struct wpa_supplicant *wpa_s,
 {
 }
 
-static inline int
-wpas_wps_reenable_networks_pending(struct wpa_supplicant *wpa_s)
-{
-	return 0;
-}
-
 #endif /* CONFIG_WPS */
 
 #endif /* WPS_SUPPLICANT_H */
